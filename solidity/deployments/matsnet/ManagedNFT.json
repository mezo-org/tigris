{
  "address": "0x4E1d74B093a0d2835AAaCA6f93a3BFe69bFa66c4",
  "abi": [
    {
      "inputs": [],
      "name": "InvalidManagedNFTId",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NonExistentToken",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotEmergencyCouncilOrGovernor",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotGovernor",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotGovernorOrManager",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotLockedNFT",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotManagedNFT",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotNormalNFT",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotPermanentLock",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotVoter",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OwnershipChange",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SafeCastOverflow",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SafeCastUnderflow",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SameAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SameState",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroBalance",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "_mTokenId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "_from",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_lockedManagedReward",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_freeManagedReward",
          "type": "address"
        }
      ],
      "name": "CreateManaged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "delegator",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "fromDelegate",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "toDelegate",
          "type": "uint256"
        }
      ],
      "name": "DelegateChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "enum IVotingEscrow.DepositType",
          "name": "depositType",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "locktime",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "ts",
          "type": "uint256"
        }
      ],
      "name": "Deposit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "_tokenId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "_mTokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_weight",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_ts",
          "type": "uint256"
        }
      ],
      "name": "DepositManaged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_tokenId",
          "type": "uint256"
        }
      ],
      "name": "MetadataUpdate",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_allowedManager",
          "type": "address"
        }
      ],
      "name": "SetAllowedManager",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "prevSupply",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "supply",
          "type": "uint256"
        }
      ],
      "name": "Supply",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "_tokenId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "_mTokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_weight",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_ts",
          "type": "uint256"
        }
      ],
      "name": "WithdrawManaged",
      "type": "event"
    }
  ],
  "transactionHash": "0x22892ac12d24c96b55e63448824f6705950d64963df61f13409d82dfc9014a9e",
  "receipt": {
    "to": null,
    "from": "0x6e80164ea60673D64d5d6228beb684a1274Bb017",
    "contractAddress": "0x4E1d74B093a0d2835AAaCA6f93a3BFe69bFa66c4",
    "transactionIndex": 0,
    "gasUsed": "2598957",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x5a732eea744c074f7cae2a414b9f01ad1ae121adb737c8c91e935533eee81abd",
    "transactionHash": "0x22892ac12d24c96b55e63448824f6705950d64963df61f13409d82dfc9014a9e",
    "logs": [],
    "blockNumber": 3218649,
    "cumulativeGasUsed": "2598957",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "8d38669248b61b3eb695f578467cc289",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InvalidManagedNFTId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonExistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEmergencyCouncilOrGovernor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotGovernor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotGovernorOrManager\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotLockedNFT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotManagedNFT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotNormalNFT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPermanentLock\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotVoter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnershipChange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeCastOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeCastUnderflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SameAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SameState\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroBalance\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_mTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_lockedManagedReward\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_freeManagedReward\",\"type\":\"address\"}],\"name\":\"CreateManaged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromDelegate\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"toDelegate\",\"type\":\"uint256\"}],\"name\":\"DelegateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"enum IVotingEscrow.DepositType\",\"name\":\"depositType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"locktime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_mTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_ts\",\"type\":\"uint256\"}],\"name\":\"DepositManaged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"MetadataUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_allowedManager\",\"type\":\"address\"}],\"name\":\"SetAllowedManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"name\":\"Supply\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_mTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_ts\",\"type\":\"uint256\"}],\"name\":\"WithdrawManaged\",\"type\":\"event\"}],\"devdoc\":{\"events\":{\"DelegateChanged(address,uint256,uint256)\":{\"details\":\"Emitted when an account changes their delegate.\"},\"MetadataUpdate(uint256)\":{\"details\":\"This event emits when the metadata of a token is changed. So that the third-party platforms such as NFT market could timely update the images and related attributes of the NFT.\"},\"Transfer(address,address,uint256)\":{\"details\":\"Emitted when `tokenId` token is transferred from `from` to `to`.\"}},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ve/ManagedNFT.sol\":\"ManagedNFT\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\",\"keccak256\":\"0xd04b0f06e0666f29cf7cccc82894de541e19bb30a765b107b1e40bb7fe5f7d7a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC4906.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4906.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\n\\n/// @title EIP-721 Metadata Update Extension\\ninterface IERC4906 is IERC165, IERC721 {\\n    /// @dev This event emits when the metadata of a token is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFT.\\n    event MetadataUpdate(uint256 _tokenId);\\n\\n    /// @dev This event emits when the metadata of a range of tokens is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFTs.\\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\\n}\\n\",\"keccak256\":\"0x2a9dadb806be80dd451821f1f1190eb9aa6f6edae85b185db29d60767cc0c5f4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC6372.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC6372 {\\n    /**\\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\\n     */\\n    function clock() external view returns (uint48);\\n\\n    /**\\n     * @dev Description of the clock\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function CLOCK_MODE() external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xcaea9aeda3816ba872358c828f4f01455c22ae48ced49c4c7d72bd74176c09b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721.sol\\\";\\n\",\"keccak256\":\"0xaf297d12d8d4a57fe01a70f0ef38908f208e3faedc577056d0b728fa2f3ccf0c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xec63854014a5b4f2b3290ab9103a21bdf902a508d0f41a8573fea49e98bf571a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\n     * 0 before setting it to a non-zero value.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0x909d608c2db6eb165ca178c81289a07ed2e118e444d0025b2a85c97d0b44a4fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xa82b58eca1ee256be466e536706850163d2ec7821945abd6b4778cfb3bee37da\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/governance/IVotes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// Modified IVotes interface for tokenId based voting\\ninterface IVotes {\\n    /**\\n     * @dev Emitted when an account changes their delegate.\\n     */\\n    event DelegateChanged(\\n        address indexed delegator,\\n        uint256 indexed fromDelegate,\\n        uint256 indexed toDelegate\\n    );\\n\\n    /**\\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\\n     */\\n    event DelegateVotesChanged(\\n        address indexed delegate,\\n        uint256 previousBalance,\\n        uint256 newBalance\\n    );\\n\\n    /**\\n     * @dev Returns the amount of votes that `tokenId` had at a specific moment in the past.\\n     *      If the account passed in is not the owner, returns 0.\\n     */\\n    function getPastVotes(\\n        address account,\\n        uint256 tokenId,\\n        uint256 timepoint\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\\n     * configured to use block numbers, this will return the value the end of the corresponding block.\\n     *\\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\\n     * vote.\\n     */\\n    function getPastTotalSupply(\\n        uint256 timepoint\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the delegate that `tokenId` has chosen. Can never be equal to the delegator's `tokenId`.\\n     *      Returns 0 if not delegated.\\n     */\\n    function delegates(uint256 tokenId) external view returns (uint256);\\n\\n    /**\\n     * @dev Delegates votes from the sender to `delegatee`.\\n     */\\n    function delegate(uint256 delegator, uint256 delegatee) external;\\n\\n    /**\\n     * @dev Delegates votes from `delegator` to `delegatee`. Signer must own `delegator`.\\n     */\\n    function delegateBySig(\\n        uint256 delegator,\\n        uint256 delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\",\"keccak256\":\"0xb4886474bc559202c8004ffba54c1d11dd14c3bbbc3a107bd522cc0f99b2ba7e\",\"license\":\"MIT\"},\"contracts/interfaces/IReward.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\ninterface IReward {\\n    error InvalidReward();\\n    error NotAuthorized();\\n    error NotGauge();\\n    error NotEscrowToken();\\n    error NotSingleToken();\\n    error NotVotingEscrow();\\n    error NotWhitelisted();\\n    error ZeroAmount();\\n\\n    event Deposit(\\n        address indexed from,\\n        uint256 indexed tokenId,\\n        uint256 amount\\n    );\\n    event Withdraw(\\n        address indexed from,\\n        uint256 indexed tokenId,\\n        uint256 amount\\n    );\\n    event NotifyReward(\\n        address indexed from,\\n        address indexed reward,\\n        uint256 indexed epoch,\\n        uint256 amount\\n    );\\n    event ClaimRewards(\\n        address indexed from,\\n        address indexed reward,\\n        uint256 amount\\n    );\\n\\n    /// @notice A checkpoint for marking balance\\n    struct Checkpoint {\\n        uint256 timestamp;\\n        uint256 balanceOf;\\n    }\\n\\n    /// @notice A checkpoint for marking supply\\n    struct SupplyCheckpoint {\\n        uint256 timestamp;\\n        uint256 supply;\\n    }\\n\\n    /// @notice Epoch duration constant (7 days)\\n    function duration() external pure returns (uint256);\\n\\n    /// @notice Address of Voter.sol\\n    function voter() external view returns (address);\\n\\n    /// @notice Address of VotingEscrow.sol\\n    function ve() external view returns (address);\\n\\n    /// @dev Address which has permission to externally call _deposit() & _withdraw()\\n    function authorized() external view returns (address);\\n\\n    /// @notice Total amount currently deposited via _deposit()\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Current amount deposited by tokenId\\n    function balanceOf(uint256 tokenId) external view returns (uint256);\\n\\n    /// @notice Amount of tokens to reward depositors for a given epoch\\n    /// @param token Address of token to reward\\n    /// @param epochStart Startime of rewards epoch\\n    /// @return Amount of token\\n    function tokenRewardsPerEpoch(\\n        address token,\\n        uint256 epochStart\\n    ) external view returns (uint256);\\n\\n    /// @notice Most recent timestamp a veNFT has claimed their rewards\\n    /// @param  token Address of token rewarded\\n    /// @param tokenId veNFT unique identifier\\n    /// @return Timestamp\\n    function lastEarn(\\n        address token,\\n        uint256 tokenId\\n    ) external view returns (uint256);\\n\\n    /// @notice True if a token is or has been an active reward token, else false\\n    function isReward(address token) external view returns (bool);\\n\\n    /// @notice The number of checkpoints for each tokenId deposited\\n    function numCheckpoints(uint256 tokenId) external view returns (uint256);\\n\\n    /// @notice The total number of checkpoints\\n    function supplyNumCheckpoints() external view returns (uint256);\\n\\n    /// @notice Deposit an amount into the rewards contract to earn future rewards associated to a veNFT\\n    /// @dev Internal notation used as only callable internally by `authorized`.\\n    /// @param amount   Amount deposited for the veNFT\\n    /// @param tokenId  Unique identifier of the veNFT\\n    function _deposit(uint256 amount, uint256 tokenId) external;\\n\\n    /// @notice Withdraw an amount from the rewards contract associated to a veNFT\\n    /// @dev Internal notation used as only callable internally by `authorized`.\\n    /// @param amount   Amount deposited for the veNFT\\n    /// @param tokenId  Unique identifier of the veNFT\\n    function _withdraw(uint256 amount, uint256 tokenId) external;\\n\\n    /// @notice Claim the rewards earned by a veNFT staker\\n    /// @param tokenId  Unique identifier of the veNFT\\n    /// @param tokens   Array of tokens to claim rewards of\\n    function getReward(uint256 tokenId, address[] memory tokens) external;\\n\\n    /// @notice Add rewards for stakers to earn\\n    /// @param token    Address of token to reward\\n    /// @param amount   Amount of token to transfer to rewards\\n    function notifyRewardAmount(address token, uint256 amount) external;\\n\\n    /// @notice Determine the prior balance for an account as of a block number\\n    /// @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n    /// @param tokenId      The token of the NFT to check\\n    /// @param timestamp    The timestamp to get the balance at\\n    /// @return The balance the account had as of the given block\\n    function getPriorBalanceIndex(\\n        uint256 tokenId,\\n        uint256 timestamp\\n    ) external view returns (uint256);\\n\\n    /// @notice Determine the prior index of supply staked by of a timestamp\\n    /// @dev Timestamp must be <= current timestamp\\n    /// @param timestamp The timestamp to get the index at\\n    /// @return Index of supply checkpoint\\n    function getPriorSupplyIndex(\\n        uint256 timestamp\\n    ) external view returns (uint256);\\n\\n    /// @notice Get number of rewards tokens\\n    function rewardsListLength() external view returns (uint256);\\n\\n    /// @notice Calculate how much in rewards are earned for a specific token and veNFT\\n    /// @param token Address of token to fetch rewards of\\n    /// @param tokenId Unique identifier of the veNFT\\n    /// @return Amount of token earned in rewards\\n    function earned(\\n        address token,\\n        uint256 tokenId\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xb2daaf8189e7ab1050182908664ab0fb7607838ec59c02511febd73584db3bb8\",\"license\":\"MIT\"},\"contracts/interfaces/IVeArtProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IVeArtProxy {\\n    function tokenURI(\\n        uint256 _tokenId\\n    ) external view returns (string memory output);\\n}\\n\",\"keccak256\":\"0x6dfdb4b1d8f01ecf556c59cd43b8ba8715cdaaf3e9872ba8f840f8be323bfb3d\",\"license\":\"MIT\"},\"contracts/interfaces/IVoter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\ninterface IVoter {\\n    error AlreadyVotedOrDeposited();\\n    error DistributeWindow();\\n    error FactoryPathNotApproved();\\n    error GaugeAlreadyKilled();\\n    error GaugeAlreadyRevived();\\n    error GaugeExists();\\n    error GaugeDoesNotExist(address _pool);\\n    error GaugeNotAlive(address _gauge);\\n    error InactiveManagedNFT();\\n    error MaximumVotingNumberTooLow();\\n    error NonZeroVotes();\\n    error NotAPool();\\n    error NotApprovedOrOwner();\\n    error NotGovernor();\\n    error NotEmergencyCouncil();\\n    error NotSplitter();\\n    error NotWhitelistedNFT();\\n    error NotWhitelistedToken();\\n    error SameValue();\\n    error SpecialVotingWindow();\\n    error TooManyPools();\\n    error UnequalLengths();\\n    error ZeroBalance();\\n    error ZeroAddress();\\n\\n    event GaugeCreated(\\n        address indexed poolFactory,\\n        address indexed votingRewardsFactory,\\n        address indexed gaugeFactory,\\n        address pool,\\n        address bribeVotingReward,\\n        address feeVotingReward,\\n        address gauge,\\n        address creator\\n    );\\n    event GaugeKilled(address indexed gauge);\\n    event GaugeRevived(address indexed gauge);\\n    event Voted(\\n        address indexed voter,\\n        address indexed pool,\\n        uint256 indexed tokenId,\\n        uint256 weight,\\n        uint256 totalWeight,\\n        uint256 timestamp\\n    );\\n    event Abstained(\\n        address indexed voter,\\n        address indexed pool,\\n        uint256 indexed tokenId,\\n        uint256 weight,\\n        uint256 totalWeight,\\n        uint256 timestamp\\n    );\\n    event NotifyReward(\\n        address indexed sender,\\n        address indexed reward,\\n        uint256 amount\\n    );\\n    event DistributeReward(\\n        address indexed sender,\\n        address indexed gauge,\\n        uint256 amount\\n    );\\n    event WhitelistToken(\\n        address indexed whitelister,\\n        address indexed token,\\n        bool indexed _bool\\n    );\\n    event WhitelistNFT(\\n        address indexed whitelister,\\n        uint256 indexed tokenId,\\n        bool indexed _bool\\n    );\\n\\n    /// @notice Store trusted forwarder address to pass into factories\\n    function forwarder() external view returns (address);\\n\\n    /// @notice The ve token that governs these contracts\\n    function ve() external view returns (address);\\n\\n    /// @notice Factory registry for valid pool / gauge / rewards factories\\n    function factoryRegistry() external view returns (address);\\n\\n    /// @notice Address of a splitter contract\\n    function splitter() external view returns (address);\\n\\n    /// @notice Standard OZ IGovernor using ve for vote weights.\\n    function governor() external view returns (address);\\n\\n    /// @notice Custom Epoch Governor using ve for vote weights.\\n    function epochGovernor() external view returns (address);\\n\\n    /// @notice credibly neutral party similar to Curve's Emergency DAO\\n    function emergencyCouncil() external view returns (address);\\n\\n    /// @dev Total Voting Weights\\n    function totalWeight() external view returns (uint256);\\n\\n    /// @dev Most number of pools one voter can vote for at once\\n    function maxVotingNum() external view returns (uint256);\\n\\n    // mappings\\n    /// @dev Pool => Gauge\\n    function gauges(address pool) external view returns (address);\\n\\n    /// @dev Gauge => Pool\\n    function poolForGauge(address gauge) external view returns (address);\\n\\n    /// @dev Gauge => Fees Voting Reward\\n    function gaugeToFees(address gauge) external view returns (address);\\n\\n    /// @dev Gauge => Bribes Voting Reward\\n    function gaugeToBribe(address gauge) external view returns (address);\\n\\n    /// @dev Pool => Weights\\n    function weights(address pool) external view returns (uint256);\\n\\n    /// @dev NFT => Pool => Votes\\n    function votes(\\n        uint256 tokenId,\\n        address pool\\n    ) external view returns (uint256);\\n\\n    /// @dev NFT => Total voting weight of NFT\\n    function usedWeights(uint256 tokenId) external view returns (uint256);\\n\\n    /// @dev Nft => Timestamp of last vote (ensures single vote per epoch)\\n    function lastVoted(uint256 tokenId) external view returns (uint256);\\n\\n    /// @dev Address => Gauge\\n    function isGauge(address) external view returns (bool);\\n\\n    /// @dev Token => Whitelisted status\\n    function isWhitelistedToken(address token) external view returns (bool);\\n\\n    /// @dev TokenId => Whitelisted status\\n    function isWhitelistedNFT(uint256 tokenId) external view returns (bool);\\n\\n    /// @dev Gauge => Liveness status\\n    function isAlive(address gauge) external view returns (bool);\\n\\n    /// @dev Gauge => Amount claimable\\n    function claimable(address gauge) external view returns (uint256);\\n\\n    /// @notice Number of pools with a Gauge\\n    function length() external view returns (uint256);\\n\\n    /// @notice Called by Splitter to distribute weekly emissions rewards for disbursement amongst gauges.\\n    /// @dev Assumes totalWeight != 0 (Will never be zero as long as users are voting).\\n    ///      Throws if not called by splitter.\\n    /// @param _amount Amount of rewards to distribute.\\n    function notifyRewardAmount(uint256 _amount) external;\\n\\n    /// @dev Utility to distribute to gauges of pools in range _start to _finish.\\n    /// @param _start   Starting index of gauges to distribute to.\\n    /// @param _finish  Ending index of gauges to distribute to.\\n    function distribute(uint256 _start, uint256 _finish) external;\\n\\n    /// @dev Utility to distribute to gauges of pools in array.\\n    /// @param _gauges Array of gauges to distribute to.\\n    function distribute(address[] memory _gauges) external;\\n\\n    /// @notice Called by users to update voting balances in voting rewards contracts.\\n    /// @param _tokenId Id of veNFT whose balance you wish to update.\\n    function poke(uint256 _tokenId) external;\\n\\n    /// @notice Called by users to vote for pools. Votes distributed proportionally based on weights.\\n    ///         Can only vote or deposit into a managed NFT once per epoch.\\n    ///         Can only vote for gauges that have not been killed.\\n    /// @dev Weights are distributed proportional to the sum of the weights in the array.\\n    ///      Throws if length of _poolVote and _weights do not match.\\n    /// @param _tokenId     Id of veNFT you are voting with.\\n    /// @param _poolVote    Array of pools you are voting for.\\n    /// @param _weights     Weights of pools.\\n    function vote(\\n        uint256 _tokenId,\\n        address[] calldata _poolVote,\\n        uint256[] calldata _weights\\n    ) external;\\n\\n    /// @notice Called by users to reset voting state. Required if you wish to make changes to\\n    ///         veNFT state (e.g. merge, split, deposit into managed etc).\\n    ///         Cannot reset in the same epoch that you voted in.\\n    ///         Can vote or deposit into a managed NFT again after reset.\\n    /// @param _tokenId Id of veNFT you are reseting.\\n    function reset(uint256 _tokenId) external;\\n\\n    /// @notice Called by users to deposit into a managed NFT.\\n    ///         Can only vote or deposit into a managed NFT once per epoch.\\n    ///         Note that NFTs deposited into a managed NFT will be re-locked\\n    ///         to the maximum lock time on withdrawal.\\n    /// @dev Throws if not approved or owner.\\n    ///      Throws if managed NFT is inactive.\\n    ///      Throws if depositing within privileged window (one hour prior to epoch flip).\\n    function depositManaged(uint256 _tokenId, uint256 _mTokenId) external;\\n\\n    /// @notice Called by users to withdraw from a managed NFT.\\n    ///         Cannot do it in the same epoch that you deposited into a managed NFT.\\n    ///         Can vote or deposit into a managed NFT again after withdrawing.\\n    ///         Note that the NFT withdrawn is re-locked to the maximum lock time.\\n    function withdrawManaged(uint256 _tokenId) external;\\n\\n    /// @notice Claim emissions from gauges.\\n    /// @param _gauges Array of gauges to collect emissions from.\\n    function claimRewards(address[] memory _gauges) external;\\n\\n    /// @notice Claim bribes for a given NFT.\\n    /// @dev Utility to help batch bribe claims.\\n    /// @param _bribes  Array of BribeVotingReward contracts to collect from.\\n    /// @param _tokens  Array of tokens that are used as bribes.\\n    /// @param _tokenId Id of veNFT that you wish to claim bribes for.\\n    function claimBribes(\\n        address[] memory _bribes,\\n        address[][] memory _tokens,\\n        uint256 _tokenId\\n    ) external;\\n\\n    /// @notice Claim fees for a given NFT.\\n    /// @dev Utility to help batch fee claims.\\n    /// @param _fees    Array of FeesVotingReward contracts to collect from.\\n    /// @param _tokens  Array of tokens that are used as fees.\\n    /// @param _tokenId Id of veNFT that you wish to claim fees for.\\n    function claimFees(\\n        address[] memory _fees,\\n        address[][] memory _tokens,\\n        uint256 _tokenId\\n    ) external;\\n\\n    /// @notice Set new governor.\\n    /// @dev Throws if not called by governor.\\n    /// @param _governor .\\n    function setGovernor(address _governor) external;\\n\\n    /// @notice Set new epoch based governor.\\n    /// @dev Throws if not called by governor.\\n    /// @param _epochGovernor .\\n    function setEpochGovernor(address _epochGovernor) external;\\n\\n    /// @notice Set new emergency council.\\n    /// @dev Throws if not called by emergency council.\\n    /// @param _emergencyCouncil .\\n    function setEmergencyCouncil(address _emergencyCouncil) external;\\n\\n    /// @notice Set maximum number of gauges that can be voted for.\\n    /// @dev Throws if not called by governor.\\n    ///      Throws if _maxVotingNum is too low.\\n    ///      Throws if the values are the same.\\n    /// @param _maxVotingNum .\\n    function setMaxVotingNum(uint256 _maxVotingNum) external;\\n\\n    /// @notice Whitelist (or unwhitelist) token for use in bribes.\\n    /// @dev Throws if not called by governor.\\n    /// @param _token .\\n    /// @param _bool .\\n    function whitelistToken(address _token, bool _bool) external;\\n\\n    /// @notice Whitelist (or unwhitelist) token id for voting in last hour prior to epoch flip.\\n    /// @dev Throws if not called by governor.\\n    ///      Throws if already whitelisted.\\n    /// @param _tokenId .\\n    /// @param _bool .\\n    function whitelistNFT(uint256 _tokenId, bool _bool) external;\\n\\n    /// @notice Create a new gauge (unpermissioned).\\n    /// @dev Governor can create a new gauge for a pool with any address.\\n    /// @param _poolFactory .\\n    /// @param _pool .\\n    function createGauge(\\n        address _poolFactory,\\n        address _pool\\n    ) external returns (address);\\n\\n    /// @notice Kills a gauge. The gauge will not receive any new emissions and cannot be deposited into.\\n    ///         Can still withdraw from gauge.\\n    /// @dev Throws if not called by emergency council.\\n    ///      Throws if gauge already killed.\\n    /// @param _gauge .\\n    function killGauge(address _gauge) external;\\n\\n    /// @notice Revives a killed gauge. Gauge will can receive emissions and deposits again.\\n    /// @dev Throws if not called by emergency council.\\n    ///      Throws if gauge is not killed.\\n    /// @param _gauge .\\n    function reviveGauge(address _gauge) external;\\n\\n    /// @dev Update claims to emissions for an array of gauges.\\n    /// @param _gauges Array of gauges to update emissions for.\\n    function updateFor(address[] memory _gauges) external;\\n\\n    /// @dev Update claims to emissions for gauges based on their pool id as stored in Voter.\\n    /// @param _start   Starting index of pools.\\n    /// @param _end     Ending index of pools.\\n    function updateFor(uint256 _start, uint256 _end) external;\\n\\n    /// @dev Update claims to emissions for single gauge\\n    /// @param _gauge .\\n    function updateFor(address _gauge) external;\\n}\\n\",\"keccak256\":\"0x2e6fbbc743a0d76d0ecb2041eabf9a5f5b0375f34af34f3d03f4c0e61a18734d\",\"license\":\"MIT\"},\"contracts/interfaces/IVotingEscrow.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\nimport {IERC165, IERC721, IERC721Metadata} from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\nimport {IERC6372} from \\\"@openzeppelin/contracts/interfaces/IERC6372.sol\\\";\\nimport {IERC4906} from \\\"@openzeppelin/contracts/interfaces/IERC4906.sol\\\";\\nimport {IVotes} from \\\"../governance/IVotes.sol\\\";\\n\\ninterface IVotingEscrow is IVotes, IERC4906, IERC6372, IERC721Metadata {\\n    struct LockedBalance {\\n        int128 amount;\\n        uint256 end;\\n        bool isPermanent;\\n    }\\n\\n    struct UserPoint {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint256 ts;\\n        uint256 blk; // block\\n        uint256 permanent;\\n    }\\n\\n    struct GlobalPoint {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint256 ts;\\n        uint256 blk; // block\\n        uint256 permanentLockBalance;\\n    }\\n\\n    /// @notice A checkpoint for recorded delegated voting weights at a certain timestamp\\n    struct Checkpoint {\\n        uint256 fromTimestamp;\\n        address owner;\\n        uint256 delegatedBalance;\\n        uint256 delegatee;\\n    }\\n\\n    enum DepositType {\\n        DEPOSIT_FOR_TYPE,\\n        CREATE_LOCK_TYPE,\\n        INCREASE_LOCK_AMOUNT,\\n        INCREASE_UNLOCK_TIME\\n    }\\n\\n    /// @dev Different types of veNFTs:\\n    /// NORMAL  - typical veNFT\\n    /// LOCKED  - veNFT which is locked into a MANAGED veNFT\\n    /// MANAGED - veNFT which can accept the deposit of NORMAL veNFTs\\n    enum EscrowType {\\n        NORMAL,\\n        LOCKED,\\n        MANAGED\\n    }\\n\\n    error AlreadyVoted();\\n    error AmountTooBig();\\n    error ERC721ReceiverRejectedTokens();\\n    error ERC721TransferToNonERC721ReceiverImplementer();\\n    error InvalidNonce();\\n    error InvalidSignature();\\n    error InvalidSignatureS();\\n    error InvalidManagedNFTId();\\n    error LockDurationNotInFuture();\\n    error LockDurationTooLong();\\n    error LockExpired();\\n    error LockNotExpired();\\n    error NoLockFound();\\n    error NonExistentToken();\\n    error NotApprovedOrOwner();\\n    error NotDistributor();\\n    error NotEmergencyCouncilOrGovernor();\\n    error NotGovernor();\\n    error NotGovernorOrManager();\\n    error NotManagedNFT();\\n    error NotManagedOrNormalNFT();\\n    error NotLockedNFT();\\n    error NotNormalNFT();\\n    error NotPermanentLock();\\n    error NotOwner();\\n    error NotTeam();\\n    error NotVoter();\\n    error OwnershipChange();\\n    error PermanentLock();\\n    error SameAddress();\\n    error SameNFT();\\n    error SameState();\\n    error SplitNoOwner();\\n    error SplitNotAllowed();\\n    error SignatureExpired();\\n    error TooManyTokenIDs();\\n    error ZeroAddress();\\n    error ZeroAmount();\\n    error ZeroBalance();\\n\\n    event Deposit(\\n        address indexed provider,\\n        uint256 indexed tokenId,\\n        DepositType indexed depositType,\\n        uint256 value,\\n        uint256 locktime,\\n        uint256 ts\\n    );\\n    event Withdraw(\\n        address indexed provider,\\n        uint256 indexed tokenId,\\n        uint256 value,\\n        uint256 ts\\n    );\\n    event LockPermanent(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 amount,\\n        uint256 _ts\\n    );\\n    event UnlockPermanent(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 amount,\\n        uint256 _ts\\n    );\\n    event Supply(uint256 prevSupply, uint256 supply);\\n    event Merge(\\n        address indexed _sender,\\n        uint256 indexed _from,\\n        uint256 indexed _to,\\n        uint256 _amountFrom,\\n        uint256 _amountTo,\\n        uint256 _amountFinal,\\n        uint256 _locktime,\\n        uint256 _ts\\n    );\\n    event Split(\\n        uint256 indexed _from,\\n        uint256 indexed _tokenId1,\\n        uint256 indexed _tokenId2,\\n        address _sender,\\n        uint256 _splitAmount1,\\n        uint256 _splitAmount2,\\n        uint256 _locktime,\\n        uint256 _ts\\n    );\\n    event CreateManaged(\\n        address indexed _to,\\n        uint256 indexed _mTokenId,\\n        address indexed _from,\\n        address _lockedManagedReward,\\n        address _freeManagedReward\\n    );\\n    event DepositManaged(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 indexed _mTokenId,\\n        uint256 _weight,\\n        uint256 _ts\\n    );\\n    event WithdrawManaged(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 indexed _mTokenId,\\n        uint256 _weight,\\n        uint256 _ts\\n    );\\n    event SetAllowedManager(address indexed _allowedManager);\\n\\n    // State variables\\n    /// @notice Address of Meta-tx Forwarder\\n    function forwarder() external view returns (address);\\n\\n    /// @notice Address of FactoryRegistry.sol\\n    function factoryRegistry() external view returns (address);\\n\\n    /// @notice Address of token used to create a veNFT\\n    function token() external view returns (address);\\n\\n    /// @notice Address of RewardsDistributor.sol\\n    function distributor() external view returns (address);\\n\\n    /// @notice Address of Voter.sol\\n    function voter() external view returns (address);\\n\\n    /// @notice Address of Protocol Team multisig\\n    function team() external view returns (address);\\n\\n    /// @notice Address of art proxy used for on-chain art generation\\n    function artProxy() external view returns (address);\\n\\n    /// @dev address which can create managed NFTs\\n    function allowedManager() external view returns (address);\\n\\n    /// @dev Current count of token\\n    function tokenId() external view returns (uint256);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            MANAGED NFT STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Mapping of token id to escrow type\\n    ///      Takes advantage of the fact default value is EscrowType.NORMAL\\n    function escrowType(uint256 tokenId) external view returns (EscrowType);\\n\\n    /// @dev Mapping of token id to managed id\\n    function idToManaged(\\n        uint256 tokenId\\n    ) external view returns (uint256 managedTokenId);\\n\\n    /// @dev Mapping of user token id to managed token id to weight of token id\\n    function weights(\\n        uint256 tokenId,\\n        uint256 managedTokenId\\n    ) external view returns (uint256 weight);\\n\\n    /// @dev Mapping of managed id to deactivated state\\n    function deactivated(uint256 tokenId) external view returns (bool inactive);\\n\\n    /// @dev Mapping from managed nft id to locked managed rewards\\n    ///      `token` denominated rewards (rebases/rewards) stored in locked managed rewards contract\\n    ///      to prevent co-mingling of assets\\n    function managedToLocked(uint256 tokenId) external view returns (address);\\n\\n    /// @dev Mapping from managed nft id to free managed rewards contract\\n    ///      these rewards can be freely withdrawn by users\\n    function managedToFree(uint256 tokenId) external view returns (address);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            MANAGED NFT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Create managed NFT (a permanent lock) for use within ecosystem.\\n    /// @dev Throws if address already owns a managed NFT.\\n    /// @return _mTokenId managed token id.\\n    function createManagedLockFor(\\n        address _to\\n    ) external returns (uint256 _mTokenId);\\n\\n    /// @notice Delegates balance to managed nft\\n    ///         Note that NFTs deposited into a managed NFT will be re-locked\\n    ///         to the maximum lock time on withdrawal.\\n    ///         Permanent locks that are deposited will automatically unlock.\\n    /// @dev Managed nft will remain max-locked as long as there is at least one\\n    ///      deposit or withdrawal per week.\\n    ///      Throws if deposit nft is managed.\\n    ///      Throws if recipient nft is not managed.\\n    ///      Throws if deposit nft is already locked.\\n    ///      Throws if not called by voter.\\n    /// @param _tokenId tokenId of NFT being deposited\\n    /// @param _mTokenId tokenId of managed NFT that will receive the deposit\\n    function depositManaged(uint256 _tokenId, uint256 _mTokenId) external;\\n\\n    /// @notice Retrieves locked rewards and withdraws balance from managed nft.\\n    ///         Note that the NFT withdrawn is re-locked to the maximum lock time.\\n    /// @dev Throws if NFT not locked.\\n    ///      Throws if not called by voter.\\n    /// @param _tokenId tokenId of NFT being deposited.\\n    function withdrawManaged(uint256 _tokenId) external;\\n\\n    /// @notice Permit one address to call createManagedLockFor() that is not Voter.governor()\\n    function setAllowedManager(address _allowedManager) external;\\n\\n    /// @notice Set Managed NFT state. Inactive NFTs cannot be deposited into.\\n    /// @param _mTokenId managed nft state to set\\n    /// @param _state true => inactive, false => active\\n    function setManagedState(uint256 _mTokenId, bool _state) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function version() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function setTeam(address _team) external;\\n\\n    function setArtProxy(address _proxy) external;\\n\\n    /// @inheritdoc IERC721Metadata\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Mapping from owner address to mapping of index to tokenId\\n    function ownerToNFTokenIdList(\\n        address _owner,\\n        uint256 _index\\n    ) external view returns (uint256 _tokenId);\\n\\n    /// @inheritdoc IERC721\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /// @inheritdoc IERC721\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC721\\n    function getApproved(\\n        uint256 _tokenId\\n    ) external view returns (address operator);\\n\\n    /// @inheritdoc IERC721\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n\\n    /// @notice Check whether spender is owner or an approved user for a given veNFT\\n    /// @param _spender .\\n    /// @param _tokenId .\\n    function isApprovedOrOwner(\\n        address _spender,\\n        uint256 _tokenId\\n    ) external returns (bool);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC721\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /// @inheritdoc IERC721\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /// @inheritdoc IERC721\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /// @inheritdoc IERC721\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /// @inheritdoc IERC721\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(\\n        bytes4 _interfaceID\\n    ) external view returns (bool);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ESCROW STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Total count of epochs witnessed since contract creation\\n    function epoch() external view returns (uint256);\\n\\n    /// @notice Total amount of token() deposited\\n    function supply() external view returns (uint256);\\n\\n    /// @notice Aggregate permanent locked balances\\n    function permanentLockBalance() external view returns (uint256);\\n\\n    function userPointEpoch(\\n        uint256 _tokenId\\n    ) external view returns (uint256 _epoch);\\n\\n    /// @notice time -> signed slope change\\n    function slopeChanges(uint256 _timestamp) external view returns (int128);\\n\\n    /// @notice account -> can split\\n    function canSplit(address _account) external view returns (bool);\\n\\n    /// @notice Global point history at a given index\\n    function pointHistory(\\n        uint256 _loc\\n    ) external view returns (GlobalPoint memory);\\n\\n    /// @notice Get the LockedBalance (amount, end) of a _tokenId\\n    /// @param _tokenId .\\n    /// @return LockedBalance of _tokenId\\n    function locked(\\n        uint256 _tokenId\\n    ) external view returns (LockedBalance memory);\\n\\n    /// @notice User -> UserPoint[userEpoch]\\n    function userPointHistory(\\n        uint256 _tokenId,\\n        uint256 _loc\\n    ) external view returns (UserPoint memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ESCROW LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Record global data to checkpoint\\n    function checkpoint() external;\\n\\n    /// @notice Deposit `_value` tokens for `_tokenId` and add to the lock\\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\\n    ///      cannot extend their locktime and deposit for a brand new user\\n    /// @param _tokenId lock NFT\\n    /// @param _value Amount to add to user's lock\\n    function depositFor(uint256 _tokenId, uint256 _value) external;\\n\\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lockDuration`\\n    /// @param _value Amount to deposit\\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\\n    /// @return TokenId of created veNFT\\n    function createLock(\\n        uint256 _value,\\n        uint256 _lockDuration\\n    ) external returns (uint256);\\n\\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lockDuration`\\n    /// @param _value Amount to deposit\\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\\n    /// @param _to Address to deposit\\n    /// @return TokenId of created veNFT\\n    function createLockFor(\\n        uint256 _value,\\n        uint256 _lockDuration,\\n        address _to\\n    ) external returns (uint256);\\n\\n    /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\\n    /// @param _value Amount of tokens to deposit and add to the lock\\n    function increaseAmount(uint256 _tokenId, uint256 _value) external;\\n\\n    /// @notice Extend the unlock time for `_tokenId`\\n    ///         Cannot extend lock time of permanent locks\\n    /// @param _lockDuration New number of seconds until tokens unlock\\n    function increaseUnlockTime(\\n        uint256 _tokenId,\\n        uint256 _lockDuration\\n    ) external;\\n\\n    /// @notice Withdraw all tokens for `_tokenId`\\n    /// @dev Only possible if the lock is both expired and not permanent\\n    ///      This will burn the veNFT. Any rebases or rewards that are unclaimed\\n    ///      will no longer be claimable. Claim all rebases and rewards prior to calling this.\\n    function withdraw(uint256 _tokenId) external;\\n\\n    /// @notice Merges `_from` into `_to`.\\n    /// @dev Cannot merge `_from` locks that are permanent or have already voted this epoch.\\n    ///      Cannot merge `_to` locks that have already expired.\\n    ///      This will burn the veNFT. Any rebases or rewards that are unclaimed\\n    ///      will no longer be claimable. Claim all rebases and rewards prior to calling this.\\n    /// @param _from VeNFT to merge from.\\n    /// @param _to VeNFT to merge into.\\n    function merge(uint256 _from, uint256 _to) external;\\n\\n    /// @notice Splits veNFT into two new veNFTS - one with oldLocked.amount - `_amount`, and the second with `_amount`\\n    /// @dev    This burns the tokenId of the target veNFT\\n    ///         Callable by approved or owner\\n    ///         If this is called by approved, approved will not have permissions to manipulate the newly created veNFTs\\n    ///         Returns the two new split veNFTs to owner\\n    ///         If `from` is permanent, will automatically dedelegate.\\n    ///         This will burn the veNFT. Any rebases or rewards that are unclaimed\\n    ///         will no longer be claimable. Claim all rebases and rewards prior to calling this.\\n    /// @param _from VeNFT to split.\\n    /// @param _amount Amount to split from veNFT.\\n    /// @return _tokenId1 Return tokenId of veNFT with oldLocked.amount - `_amount`.\\n    /// @return _tokenId2 Return tokenId of veNFT with `_amount`.\\n    function split(\\n        uint256 _from,\\n        uint256 _amount\\n    ) external returns (uint256 _tokenId1, uint256 _tokenId2);\\n\\n    /// @notice Toggle split for a specific address.\\n    /// @dev Toggle split for address(0) to enable or disable for all.\\n    /// @param _account Address to toggle split permissions\\n    /// @param _bool True to allow, false to disallow\\n    function toggleSplit(address _account, bool _bool) external;\\n\\n    /// @notice Permanently lock a veNFT. Voting power will be equal to\\n    ///         `LockedBalance.amount` with no decay. Required to delegate.\\n    /// @dev Only callable by unlocked normal veNFTs.\\n    /// @param _tokenId tokenId to lock.\\n    function lockPermanent(uint256 _tokenId) external;\\n\\n    /// @notice Unlock a permanently locked veNFT. Voting power will decay.\\n    ///         Will automatically dedelegate if delegated.\\n    /// @dev Only callable by permanently locked veNFTs.\\n    ///      Cannot unlock if already voted this epoch.\\n    /// @param _tokenId tokenId to unlock.\\n    function unlockPermanent(uint256 _tokenId) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           GAUGE VOTING STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Get the voting power for _tokenId at the current timestamp\\n    /// @dev Returns 0 if called in the same block as a transfer.\\n    /// @param _tokenId .\\n    /// @return Voting power\\n    function balanceOfNFT(uint256 _tokenId) external view returns (uint256);\\n\\n    /// @notice Get the voting power for _tokenId at a given timestamp\\n    /// @param _tokenId .\\n    /// @param _t Timestamp to query voting power\\n    /// @return Voting power\\n    function balanceOfNFTAt(\\n        uint256 _tokenId,\\n        uint256 _t\\n    ) external view returns (uint256);\\n\\n    /// @notice Calculate total voting power at current timestamp\\n    /// @return Total voting power at current timestamp\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Calculate total voting power at a given timestamp\\n    /// @param _t Timestamp to query total voting power\\n    /// @return Total voting power at given timestamp\\n    function totalSupplyAt(uint256 _t) external view returns (uint256);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            GAUGE VOTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice See if a queried _tokenId has actively voted\\n    /// @param _tokenId .\\n    /// @return True if voted, else false\\n    function voted(uint256 _tokenId) external view returns (bool);\\n\\n    /// @notice Set the global state voter and distributor\\n    /// @dev This is only called once, at setup\\n    function setVoterAndDistributor(\\n        address _voter,\\n        address _distributor\\n    ) external;\\n\\n    /// @notice Set `voted` for _tokenId to true or false\\n    /// @dev Only callable by voter\\n    /// @param _tokenId .\\n    /// @param _voted .\\n    function voting(uint256 _tokenId, bool _voted) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            DAO VOTING STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The number of checkpoints for each tokenId\\n    function numCheckpoints(uint256 tokenId) external view returns (uint48);\\n\\n    /// @notice A record of states for signing / validating signatures\\n    function nonces(address account) external view returns (uint256);\\n\\n    /// @inheritdoc IVotes\\n    function delegates(uint256 delegator) external view returns (uint256);\\n\\n    /// @notice A record of delegated token checkpoints for each account, by index\\n    /// @param tokenId .\\n    /// @param index .\\n    /// @return Checkpoint\\n    function checkpoints(\\n        uint256 tokenId,\\n        uint48 index\\n    ) external view returns (Checkpoint memory);\\n\\n    /// @inheritdoc IVotes\\n    function getPastVotes(\\n        address account,\\n        uint256 tokenId,\\n        uint256 timestamp\\n    ) external view returns (uint256);\\n\\n    /// @inheritdoc IVotes\\n    function getPastTotalSupply(\\n        uint256 timestamp\\n    ) external view returns (uint256);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             DAO VOTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IVotes\\n    function delegate(uint256 delegator, uint256 delegatee) external;\\n\\n    /// @inheritdoc IVotes\\n    function delegateBySig(\\n        uint256 delegator,\\n        uint256 delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC6372 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC6372\\n    function clock() external view returns (uint48);\\n\\n    /// @inheritdoc IERC6372\\n    function CLOCK_MODE() external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x98987ce08f208b6eef4481d4f85bb64c7477164150c7dba176f8f77adbd9b8cf\",\"license\":\"MIT\"},\"contracts/interfaces/factories/IFactoryRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IFactoryRegistry {\\n    error FallbackFactory();\\n    error InvalidFactoriesToPoolFactory();\\n    error PathAlreadyApproved();\\n    error PathNotApproved();\\n    error SameAddress();\\n    error ZeroAddress();\\n\\n    event Approve(\\n        address indexed poolFactory,\\n        address indexed votingRewardsFactory,\\n        address indexed gaugeFactory\\n    );\\n    event Unapprove(\\n        address indexed poolFactory,\\n        address indexed votingRewardsFactory,\\n        address indexed gaugeFactory\\n    );\\n    event SetManagedRewardsFactory(address indexed _newRewardsFactory);\\n\\n    /// @notice Approve a set of factories used in the Protocol.\\n    ///         Router.sol is able to swap any poolFactories currently approved.\\n    ///         Cannot approve address(0) factories.\\n    ///         Cannot aprove path that is already approved.\\n    ///         Each poolFactory has one unique set and maintains state.  In the case a poolFactory is unapproved\\n    ///             and then re-approved, the same set of factories must be used.  In other words, you cannot overwrite\\n    ///             the factories tied to a poolFactory address.\\n    ///         VotingRewardsFactories and GaugeFactories may use the same address across multiple poolFactories.\\n    /// @dev Callable by onlyOwner\\n    /// @param poolFactory .\\n    /// @param votingRewardsFactory .\\n    /// @param gaugeFactory .\\n    function approve(\\n        address poolFactory,\\n        address votingRewardsFactory,\\n        address gaugeFactory\\n    ) external;\\n\\n    /// @notice Unapprove a set of factories used in the Protocol.\\n    ///         While a poolFactory is unapproved, Router.sol cannot swap with pools made from the corresponding factory\\n    ///         Can only unapprove an approved path.\\n    ///         Cannot unapprove the fallback path (core v2 factories).\\n    /// @dev Callable by onlyOwner\\n    /// @param poolFactory .\\n    function unapprove(address poolFactory) external;\\n\\n    /// @notice Factory to create free and locked rewards for a managed veNFT\\n    function managedRewardsFactory() external view returns (address);\\n\\n    /// @notice Set the rewards factory address\\n    /// @dev Callable by onlyOwner\\n    /// @param _newManagedRewardsFactory address of new managedRewardsFactory\\n    function setManagedRewardsFactory(\\n        address _newManagedRewardsFactory\\n    ) external;\\n\\n    /// @notice Get the factories correlated to a poolFactory.\\n    ///         Once set, this can never be modified.\\n    ///         Returns the correlated factories even after an approved poolFactory is unapproved.\\n    function factoriesToPoolFactory(\\n        address poolFactory\\n    )\\n        external\\n        view\\n        returns (address votingRewardsFactory, address gaugeFactory);\\n\\n    /// @notice Get all PoolFactories approved by the registry\\n    /// @dev The same PoolFactory address cannot be used twice\\n    /// @return Array of PoolFactory addresses\\n    function poolFactories() external view returns (address[] memory);\\n\\n    /// @notice Check if a PoolFactory is approved within the factory registry.  Router uses this method to\\n    ///         ensure a pool swapped from is approved.\\n    /// @param poolFactory .\\n    /// @return True if PoolFactory is approved, else false\\n    function isPoolFactoryApproved(\\n        address poolFactory\\n    ) external view returns (bool);\\n\\n    /// @notice Get the length of the poolFactories array\\n    function poolFactoriesLength() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xdfe6d1bb465bf1361920a3cb84d410d879d8fd13b73755048b249d52b9c7e9d0\",\"license\":\"MIT\"},\"contracts/interfaces/factories/IManagedRewardsFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IManagedRewardsFactory {\\n    event ManagedRewardCreated(\\n        address indexed voter,\\n        address indexed lockedManagedReward,\\n        address indexed freeManagedReward\\n    );\\n\\n    /// @notice creates a LockedManagedReward and a FreeManagedReward contract for a managed veNFT\\n    /// @param _forwarder Address of trusted forwarder\\n    /// @param _voter Address of Voter.sol\\n    /// @return lockedManagedReward Address of LockedManagedReward contract created\\n    /// @return freeManagedReward   Address of FreeManagedReward contract created\\n    function createRewards(\\n        address _forwarder,\\n        address _voter\\n    ) external returns (address lockedManagedReward, address freeManagedReward);\\n}\\n\",\"keccak256\":\"0x3f4ef0d7d8c7d30564245dcf352f5459f9f50ae196abe0a0baf431adc93f7bb7\",\"license\":\"MIT\"},\"contracts/libraries/SafeCastLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.24;\\n\\n/// @title SafeCast Library\\n/// @author velodrome.finance\\n/// @notice Safely convert unsigned and signed integers without overflow / underflow\\nlibrary SafeCastLibrary {\\n    error SafeCastOverflow();\\n    error SafeCastUnderflow();\\n\\n    /// @dev Safely convert uint256 to int128\\n    function toInt128(uint256 value) internal pure returns (int128) {\\n        if (value > uint128(type(int128).max)) revert SafeCastOverflow();\\n        return int128(uint128(value));\\n    }\\n\\n    /// @dev Safely convert int128 to uint256\\n    function toUint256(int128 value) internal pure returns (uint256) {\\n        if (value < 0) revert SafeCastUnderflow();\\n        return uint256(int256(value));\\n    }\\n}\\n\",\"keccak256\":\"0xfc419390f2423ffa802e9a3a11ee859b01fee9ffdb0fca855008d6b7d6b25bd6\",\"license\":\"BUSL-1.1\"},\"contracts/ve/Balance.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.24;\\n\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport {SafeCastLibrary} from \\\"../libraries/SafeCastLibrary.sol\\\";\\nimport {VotingEscrowState} from \\\"./VotingEscrowState.sol\\\";\\n\\nlibrary Balance {\\n    using SafeCastLibrary for uint256;\\n    using SafeCastLibrary for int128;\\n\\n    uint256 internal constant WEEK = 1 weeks;\\n\\n    /// @notice Binary search to get the user point index for a token id at or prior to a given timestamp\\n    /// @dev If a user point does not exist prior to the timestamp, this will return 0.\\n    /// @param _tokenId .\\n    /// @param _timestamp .\\n    /// @return User point index\\n    function getPastUserPointIndex(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        uint256 _timestamp\\n    ) internal view returns (uint256) {\\n        uint256 _userEpoch = self.userPointEpoch[_tokenId];\\n        if (_userEpoch == 0) return 0;\\n        // First check most recent balance\\n        if (self._userPointHistory[_tokenId][_userEpoch].ts <= _timestamp)\\n            return (_userEpoch);\\n        // Next check implicit zero balance\\n        if (self._userPointHistory[_tokenId][1].ts > _timestamp) return 0;\\n\\n        uint256 lower = 0;\\n        uint256 upper = _userEpoch;\\n        while (upper > lower) {\\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            IVotingEscrow.UserPoint storage userPoint = self._userPointHistory[\\n                _tokenId\\n            ][center];\\n            if (userPoint.ts == _timestamp) {\\n                return center;\\n            } else if (userPoint.ts < _timestamp) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return lower;\\n    }\\n\\n    /// @notice Binary search to get the global point index at or prior to a given timestamp\\n    /// @dev If a checkpoint does not exist prior to the timestamp, this will return 0.\\n    /// @param _timestamp .\\n    /// @return Global point index\\n    function getPastGlobalPointIndex(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _timestamp\\n    ) internal view returns (uint256) {\\n        if (self.epoch == 0) return 0;\\n        // First check most recent balance\\n        if (self._pointHistory[self.epoch].ts <= _timestamp)\\n            return (self.epoch);\\n        // Next check implicit zero balance\\n        if (self._pointHistory[1].ts > _timestamp) return 0;\\n\\n        uint256 lower = 0;\\n        uint256 upper = self.epoch;\\n        while (upper > lower) {\\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            IVotingEscrow.GlobalPoint storage globalPoint = self._pointHistory[\\n                center\\n            ];\\n            if (globalPoint.ts == _timestamp) {\\n                return center;\\n            } else if (globalPoint.ts < _timestamp) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return lower;\\n    }\\n\\n    /// @notice Get the current voting power for `_tokenId`\\n    /// @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\\n    ///      Fetches last user point prior to a certain timestamp, then walks forward to timestamp.\\n    /// @param _tokenId NFT for lock\\n    /// @param _t Epoch time to return voting power at\\n    /// @return User voting power\\n    function _balanceOfNFTAt(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        uint256 _t\\n    ) internal view returns (uint256) {\\n        uint256 _epoch = getPastUserPointIndex(self, _tokenId, _t);\\n        // epoch 0 is an empty point\\n        if (_epoch == 0) return 0;\\n        IVotingEscrow.UserPoint memory lastPoint = self._userPointHistory[\\n            _tokenId\\n        ][_epoch];\\n        if (lastPoint.permanent != 0) {\\n            return lastPoint.permanent;\\n        } else {\\n            lastPoint.bias -= lastPoint.slope * (_t - lastPoint.ts).toInt128();\\n            if (lastPoint.bias < 0) {\\n                lastPoint.bias = 0;\\n            }\\n            return lastPoint.bias.toUint256();\\n        }\\n    }\\n\\n    function _balanceOfNFT(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) external view returns (uint256) {\\n        if (self.ownershipChange[_tokenId] == block.number) return 0;\\n        return _balanceOfNFTAt(self, _tokenId, block.timestamp);\\n    }\\n\\n    /// @notice Calculate total voting power at some point in the past\\n    /// @param _t Time to calculate the total voting power at\\n    /// @return Total voting power at that time\\n    function supplyAt(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _t\\n    ) external view returns (uint256) {\\n        uint256 epoch_ = getPastGlobalPointIndex(self, _t);\\n        // epoch 0 is an empty point\\n        if (epoch_ == 0) return 0;\\n        IVotingEscrow.GlobalPoint memory _point = self._pointHistory[epoch_];\\n        int128 bias = _point.bias;\\n        int128 slope = _point.slope;\\n        uint256 ts = _point.ts;\\n        uint256 t_i = (ts / WEEK) * WEEK;\\n        for (uint256 i = 0; i < 255; ++i) {\\n            t_i += WEEK;\\n            int128 dSlope = 0;\\n            if (t_i > _t) {\\n                t_i = _t;\\n            } else {\\n                dSlope = self.slopeChanges[t_i];\\n            }\\n            bias -= slope * (t_i - ts).toInt128();\\n            if (t_i == _t) {\\n                break;\\n            }\\n            slope += dSlope;\\n            ts = t_i;\\n        }\\n\\n        if (bias < 0) {\\n            bias = 0;\\n        }\\n        return bias.toUint256() + _point.permanentLockBalance;\\n    }\\n}\\n\",\"keccak256\":\"0x72bb04eea9375ddae514cd8998c33bba2659d8ef20e5e1b48c14d2ef9d3f2fc4\",\"license\":\"BUSL-1.1\"},\"contracts/ve/Delegation.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.24;\\n\\nimport {VotingEscrowState} from \\\"./VotingEscrowState.sol\\\";\\nimport {NFT} from \\\"./NFT.sol\\\";\\nimport {VeERC2771Context} from \\\"./VeERC2771Context.sol\\\";\\nimport {SafeCastLibrary} from \\\"../libraries/SafeCastLibrary.sol\\\";\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport {IVotes} from \\\"../governance/IVotes.sol\\\";\\n\\nlibrary Delegation {\\n    using SafeCastLibrary for int128;\\n    using NFT for VotingEscrowState.Storage;\\n    using VeERC2771Context for VotingEscrowState.Storage;\\n\\n    struct SignatureData {\\n        uint256 delegator;\\n        uint256 delegatee;\\n        uint256 nonce;\\n        uint256 expiry;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH =\\n        keccak256(\\n            \\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\"\\n        );\\n\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\\n    bytes32 public constant DELEGATION_TYPEHASH =\\n        keccak256(\\n            \\\"Delegation(uint256 delegator,uint256 delegatee,uint256 nonce,uint256 expiry)\\\"\\n        );\\n\\n    function delegate(\\n        VotingEscrowState.Storage storage self,\\n        uint256 delegator,\\n        uint256 delegatee\\n    ) external {\\n        if (!self._isApprovedOrOwner(self._msgSender(), delegator))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        return _delegate(self, delegator, delegatee);\\n    }\\n\\n    function delegateBySig(\\n        VotingEscrowState.Storage storage self,\\n        SignatureData calldata signatureData,\\n        string calldata contractName,\\n        string calldata contractVersion\\n    ) external {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (\\n            uint256(signatureData.s) >\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\\n        ) revert IVotingEscrow.InvalidSignatureS();\\n        bytes32 domainSeparator = keccak256(\\n            abi.encode(\\n                DOMAIN_TYPEHASH,\\n                keccak256(bytes(contractName)),\\n                keccak256(bytes(contractVersion)),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                DELEGATION_TYPEHASH,\\n                signatureData.delegator,\\n                signatureData.delegatee,\\n                signatureData.nonce,\\n                signatureData.expiry\\n            )\\n        );\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash)\\n        );\\n        address signatory = ecrecover(\\n            digest,\\n            signatureData.v,\\n            signatureData.r,\\n            signatureData.s\\n        );\\n        if (!self._isApprovedOrOwner(signatory, signatureData.delegator))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        if (signatory == address(0)) revert IVotingEscrow.InvalidSignature();\\n        if (signatureData.nonce != self.nonces[signatory]++)\\n            revert IVotingEscrow.InvalidNonce();\\n        if (block.timestamp > signatureData.expiry)\\n            revert IVotingEscrow.SignatureExpired();\\n        return\\n            _delegate(self, signatureData.delegator, signatureData.delegatee);\\n    }\\n\\n    /// @notice Record user delegation checkpoints. Used by voting system.\\n    /// @dev Skips delegation if already delegated to `delegatee`.\\n    function _delegate(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _delegator,\\n        uint256 _delegatee\\n    ) internal {\\n        IVotingEscrow.LockedBalance memory delegateLocked = self._locked[\\n            _delegator\\n        ];\\n        if (!delegateLocked.isPermanent)\\n            revert IVotingEscrow.NotPermanentLock();\\n        if (_delegatee != 0 && self._ownerOf(_delegatee) == address(0))\\n            revert IVotingEscrow.NonExistentToken();\\n        if (self.ownershipChange[_delegator] == block.number)\\n            revert IVotingEscrow.OwnershipChange();\\n        if (_delegatee == _delegator) _delegatee = 0;\\n        uint256 currentDelegate = self._delegates[_delegator];\\n        if (currentDelegate == _delegatee) return;\\n\\n        uint256 delegatedBalance = delegateLocked.amount.toUint256();\\n        _checkpointDelegator(\\n            self,\\n            _delegator,\\n            _delegatee,\\n            self._ownerOf(_delegator)\\n        );\\n        _checkpointDelegatee(self, _delegatee, delegatedBalance, true);\\n\\n        emit IVotes.DelegateChanged(\\n            self._msgSender(),\\n            currentDelegate,\\n            _delegatee\\n        );\\n    }\\n\\n    /// @notice Used by `_mint`, `_transferFrom`, `_burn` and `delegate`\\n    ///         to update delegator voting checkpoints.\\n    ///         Automatically dedelegates, then updates checkpoint.\\n    /// @dev This function depends on `_locked` and must be called prior to token state changes.\\n    ///      If you wish to dedelegate only, use `_delegate(tokenId, 0)` instead.\\n    /// @param _delegator The delegator to update checkpoints for\\n    /// @param _delegatee The new delegatee for the delegator. Cannot be equal to `_delegator` (use 0 instead).\\n    /// @param _owner The new (or current) owner for the delegator\\n    function _checkpointDelegator(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _delegator,\\n        uint256 _delegatee,\\n        address _owner\\n    ) internal {\\n        uint256 delegatedBalance = self._locked[_delegator].amount.toUint256();\\n        uint48 numCheckpoint = self.numCheckpoints[_delegator];\\n        IVotingEscrow.Checkpoint storage cpOld = numCheckpoint > 0\\n            ? self._checkpoints[_delegator][numCheckpoint - 1]\\n            : self._checkpoints[_delegator][0];\\n        // Dedelegate from delegatee if delegated\\n        _checkpointDelegatee(self, cpOld.delegatee, delegatedBalance, false);\\n        IVotingEscrow.Checkpoint storage cp = self._checkpoints[_delegator][\\n            numCheckpoint\\n        ];\\n        cp.fromTimestamp = block.timestamp;\\n        cp.delegatedBalance = cpOld.delegatedBalance;\\n        cp.delegatee = _delegatee;\\n        cp.owner = _owner;\\n\\n        if (_isCheckpointInNewBlock(self, _delegator)) {\\n            self.numCheckpoints[_delegator]++;\\n        } else {\\n            self._checkpoints[_delegator][numCheckpoint - 1] = cp;\\n            delete self._checkpoints[_delegator][numCheckpoint];\\n        }\\n\\n        self._delegates[_delegator] = _delegatee;\\n    }\\n\\n    /// @notice Update delegatee's `delegatedBalance` by `balance`.\\n    ///         Only updates if delegating to a new delegatee.\\n    /// @dev If used with `balance` == `_locked[_tokenId].amount`, then this is the same as\\n    ///      delegating or dedelegating from `_tokenId`\\n    ///      If used with `balance` < `_locked[_tokenId].amount`, then this is used to adjust\\n    ///      `delegatedBalance` when a user's balance is modified (e.g. `increaseAmount`, `merge` etc).\\n    ///      If `delegatee` is 0 (i.e. user is not delegating), then do nothing.\\n    /// @param _delegatee The delegatee's tokenId\\n    /// @param balance_ The delta in balance change\\n    /// @param _increase True if balance is increasing, false if decreasing\\n    function _checkpointDelegatee(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _delegatee,\\n        uint256 balance_,\\n        bool _increase\\n    ) internal {\\n        if (_delegatee == 0) return;\\n        uint48 numCheckpoint = self.numCheckpoints[_delegatee];\\n        IVotingEscrow.Checkpoint storage cpOld = numCheckpoint > 0\\n            ? self._checkpoints[_delegatee][numCheckpoint - 1]\\n            : self._checkpoints[_delegatee][0];\\n        IVotingEscrow.Checkpoint storage cp = self._checkpoints[_delegatee][\\n            numCheckpoint\\n        ];\\n        cp.fromTimestamp = block.timestamp;\\n        cp.owner = cpOld.owner;\\n        // do not expect balance_ > cpOld.delegatedBalance when decrementing but just in case\\n        cp.delegatedBalance = _increase\\n            ? cpOld.delegatedBalance + balance_\\n            : (\\n                balance_ < cpOld.delegatedBalance\\n                    ? cpOld.delegatedBalance - balance_\\n                    : 0\\n            );\\n        cp.delegatee = cpOld.delegatee;\\n\\n        if (_isCheckpointInNewBlock(self, _delegatee)) {\\n            self.numCheckpoints[_delegatee]++;\\n        } else {\\n            self._checkpoints[_delegatee][numCheckpoint - 1] = cp;\\n            delete self._checkpoints[_delegatee][numCheckpoint];\\n        }\\n    }\\n\\n    function _isCheckpointInNewBlock(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) internal view returns (bool) {\\n        uint48 _nCheckPoints = self.numCheckpoints[_tokenId];\\n\\n        if (\\n            _nCheckPoints > 0 &&\\n            self._checkpoints[_tokenId][_nCheckPoints - 1].fromTimestamp ==\\n            block.timestamp\\n        ) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /// @notice Retrieves historical voting balance for a token id at a given timestamp.\\n    /// @dev If a checkpoint does not exist prior to the timestamp, this will return 0.\\n    ///      The user must also own the token at the time in order to receive a voting balance.\\n    /// @param _account .\\n    /// @param _tokenId .\\n    /// @param _timestamp .\\n    /// @return Total voting balance including delegations at a given timestamp.\\n    function getPastVotes(\\n        VotingEscrowState.Storage storage self,\\n        address _account,\\n        uint256 _tokenId,\\n        uint256 _timestamp\\n    ) external view returns (uint256) {\\n        uint48 _checkIndex = getPastVotesIndex(self, _tokenId, _timestamp);\\n        IVotingEscrow.Checkpoint memory lastCheckpoint = self._checkpoints[\\n            _tokenId\\n        ][_checkIndex];\\n        // If no point exists prior to the given timestamp, return 0\\n        if (lastCheckpoint.fromTimestamp > _timestamp) return 0;\\n        // Check ownership\\n        if (_account != lastCheckpoint.owner) return 0;\\n        uint256 votes = lastCheckpoint.delegatedBalance;\\n        return\\n            lastCheckpoint.delegatee == 0\\n                ? votes +\\n                    IVotingEscrow(address(this)).balanceOfNFTAt(\\n                        _tokenId,\\n                        _timestamp\\n                    )\\n                : votes;\\n    }\\n\\n    /// @notice Binary search to get the voting checkpoint for a token id at or prior to a given timestamp.\\n    /// @dev If a checkpoint does not exist prior to the timestamp, this will return 0.\\n    /// @param _tokenId .\\n    /// @param _timestamp .\\n    /// @return The index of the checkpoint.\\n    function getPastVotesIndex(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        uint256 _timestamp\\n    ) internal view returns (uint48) {\\n        uint48 nCheckpoints = self.numCheckpoints[_tokenId];\\n        if (nCheckpoints == 0) return 0;\\n        // First check most recent balance\\n        if (\\n            self._checkpoints[_tokenId][nCheckpoints - 1].fromTimestamp <=\\n            _timestamp\\n        ) return (nCheckpoints - 1);\\n        // Next check implicit zero balance\\n        if (self._checkpoints[_tokenId][0].fromTimestamp > _timestamp) return 0;\\n\\n        uint48 lower = 0;\\n        uint48 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint48 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            IVotingEscrow.Checkpoint storage cp = self._checkpoints[_tokenId][\\n                center\\n            ];\\n            if (cp.fromTimestamp == _timestamp) {\\n                return center;\\n            } else if (cp.fromTimestamp < _timestamp) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return lower;\\n    }\\n}\\n\",\"keccak256\":\"0x2e29a6cbff7b7301fa8d7607287445f6352662ddb317e6264152a12bf2952255\",\"license\":\"BUSL-1.1\"},\"contracts/ve/Escrow.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.24;\\n\\nimport {VotingEscrowState} from \\\"./VotingEscrowState.sol\\\";\\nimport {Delegation} from \\\"./Delegation.sol\\\";\\nimport {NFT} from \\\"./NFT.sol\\\";\\nimport {VeERC2771Context} from \\\"./VeERC2771Context.sol\\\";\\nimport {SafeCastLibrary} from \\\"../libraries/SafeCastLibrary.sol\\\";\\nimport {IReward} from \\\"../interfaces/IReward.sol\\\";\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC4906} from \\\"@openzeppelin/contracts/interfaces/IERC4906.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nlibrary Escrow {\\n    using SafeERC20 for IERC20;\\n    using SafeCastLibrary for uint256;\\n    using SafeCastLibrary for int128;\\n    using NFT for VotingEscrowState.Storage;\\n    using Delegation for VotingEscrowState.Storage;\\n    using VeERC2771Context for VotingEscrowState.Storage;\\n\\n    uint256 internal constant WEEK = 1 weeks;\\n    uint256 internal constant MAXTIME = 4 * 365 * 86400;\\n    int128 internal constant iMAXTIME = 4 * 365 * 86400;\\n    uint256 internal constant MULTIPLIER = 1 ether;\\n\\n    function depositFor(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        uint256 _value\\n    ) external {\\n        if (\\n            self.escrowType[_tokenId] == IVotingEscrow.EscrowType.MANAGED &&\\n            self._msgSender() != self.distributor\\n        ) revert IVotingEscrow.NotDistributor();\\n        _increaseAmountFor(\\n            self,\\n            _tokenId,\\n            _value,\\n            IVotingEscrow.DepositType.DEPOSIT_FOR_TYPE\\n        );\\n    }\\n\\n    /// @notice Deposit and lock tokens for a user\\n    /// @param _tokenId NFT that holds lock\\n    /// @param _value Amount to deposit\\n    /// @param _unlockTime New time when to unlock the tokens, or 0 if unchanged\\n    /// @param _oldLocked Previous locked amount / timestamp\\n    /// @param _depositType The type of deposit\\n    function _depositFor(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        uint256 _value,\\n        uint256 _unlockTime,\\n        IVotingEscrow.LockedBalance memory _oldLocked,\\n        IVotingEscrow.DepositType _depositType\\n    ) internal {\\n        uint256 supplyBefore = self.supply;\\n        self.supply = supplyBefore + _value;\\n\\n        // Set newLocked to _oldLocked without mangling memory\\n        IVotingEscrow.LockedBalance memory newLocked;\\n        (newLocked.amount, newLocked.end, newLocked.isPermanent) = (\\n            _oldLocked.amount,\\n            _oldLocked.end,\\n            _oldLocked.isPermanent\\n        );\\n\\n        // Adding to existing lock, or if a lock is expired - creating a new one\\n        newLocked.amount += _value.toInt128();\\n        if (_unlockTime != 0) {\\n            newLocked.end = _unlockTime;\\n        }\\n        self._locked[_tokenId] = newLocked;\\n\\n        // Possibilities:\\n        // Both _oldLocked.end could be current or expired (>/< block.timestamp)\\n        // or if the lock is a permanent lock, then _oldLocked.end == 0\\n        // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\\n        // newLocked.end > block.timestamp (always)\\n        _checkpoint(self, _tokenId, _oldLocked, newLocked);\\n\\n        address from = self._msgSender();\\n        if (_value != 0) {\\n            IERC20(self.token).safeTransferFrom(from, address(this), _value);\\n        }\\n\\n        emit IVotingEscrow.Deposit(\\n            from,\\n            _tokenId,\\n            _depositType,\\n            _value,\\n            newLocked.end,\\n            block.timestamp\\n        );\\n        emit IVotingEscrow.Supply(supplyBefore, supplyBefore + _value);\\n    }\\n\\n    /// @notice Record global and per-user data to checkpoints. Used by VotingEscrow system.\\n    /// @param _tokenId NFT token ID. No user checkpoint if 0\\n    /// @param _oldLocked Previous locked amount / end lock time for the user\\n    /// @param _newLocked New locked amount / end lock time for the user\\n    function _checkpoint(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        IVotingEscrow.LockedBalance memory _oldLocked,\\n        IVotingEscrow.LockedBalance memory _newLocked\\n    ) internal {\\n        IVotingEscrow.UserPoint memory uOld;\\n        IVotingEscrow.UserPoint memory uNew;\\n        int128 oldDslope = 0;\\n        int128 newDslope = 0;\\n        uint256 _epoch = self.epoch;\\n\\n        if (_tokenId != 0) {\\n            uNew.permanent = _newLocked.isPermanent\\n                ? _newLocked.amount.toUint256()\\n                : 0;\\n            // Calculate slopes and biases\\n            // Kept at zero when they have to\\n            if (_oldLocked.end > block.timestamp && _oldLocked.amount > 0) {\\n                uOld.slope = _oldLocked.amount / iMAXTIME;\\n                uOld.bias =\\n                    uOld.slope *\\n                    (_oldLocked.end - block.timestamp).toInt128();\\n            }\\n            if (_newLocked.end > block.timestamp && _newLocked.amount > 0) {\\n                uNew.slope = _newLocked.amount / iMAXTIME;\\n                uNew.bias =\\n                    uNew.slope *\\n                    (_newLocked.end - block.timestamp).toInt128();\\n            }\\n\\n            // Read values of scheduled changes in the slope\\n            // _oldLocked.end can be in the past and in the future\\n            // _newLocked.end can ONLY by in the FUTURE unless everything expired: than zeros\\n            oldDslope = self.slopeChanges[_oldLocked.end];\\n            if (_newLocked.end != 0) {\\n                if (_newLocked.end == _oldLocked.end) {\\n                    newDslope = oldDslope;\\n                } else {\\n                    newDslope = self.slopeChanges[_newLocked.end];\\n                }\\n            }\\n        }\\n\\n        IVotingEscrow.GlobalPoint memory lastPoint = IVotingEscrow.GlobalPoint({\\n            bias: 0,\\n            slope: 0,\\n            ts: block.timestamp,\\n            blk: block.number,\\n            permanentLockBalance: 0\\n        });\\n        if (_epoch > 0) {\\n            lastPoint = self._pointHistory[_epoch];\\n        }\\n        uint256 lastCheckpoint = lastPoint.ts;\\n        // initialLastPoint is used for extrapolation to calculate block number\\n        // (approximately, for *At methods) and save them\\n        // as we cannot figure that out exactly from inside the contract\\n        IVotingEscrow.GlobalPoint memory initialLastPoint = IVotingEscrow\\n            .GlobalPoint({\\n                bias: lastPoint.bias,\\n                slope: lastPoint.slope,\\n                ts: lastPoint.ts,\\n                blk: lastPoint.blk,\\n                permanentLockBalance: lastPoint.permanentLockBalance\\n            });\\n        uint256 blockSlope = 0; // dblock/dt\\n        if (block.timestamp > lastPoint.ts) {\\n            blockSlope =\\n                (MULTIPLIER * (block.number - lastPoint.blk)) /\\n                (block.timestamp - lastPoint.ts);\\n        }\\n        // If last point is already recorded in this block, slope=0\\n        // But that's ok b/c we know the block in such case\\n\\n        // Go over weeks to fill history and calculate what the current point is\\n        (_epoch, lastPoint) = _updateHistory(\\n            self,\\n            _epoch,\\n            lastPoint,\\n            lastCheckpoint,\\n            initialLastPoint,\\n            blockSlope\\n        );\\n\\n        if (_tokenId != 0) {\\n            // If last point was in this block, the slope change has been applied already\\n            // But in such case we have 0 slope(s)\\n            lastPoint.slope += (uNew.slope - uOld.slope);\\n            lastPoint.bias += (uNew.bias - uOld.bias);\\n            if (lastPoint.slope < 0) {\\n                lastPoint.slope = 0;\\n            }\\n            if (lastPoint.bias < 0) {\\n                lastPoint.bias = 0;\\n            }\\n            lastPoint.permanentLockBalance = self.permanentLockBalance;\\n        }\\n\\n        // If timestamp of last global point is the same, overwrite the last global point\\n        // Else record the new global point into history\\n        // Exclude epoch 0 (note: _epoch is always >= 1, see above)\\n        // Two possible outcomes:\\n        // Missing global checkpoints in prior weeks. In this case, _epoch = epoch + x, where x > 1\\n        // No missing global checkpoints, but timestamp != block.timestamp. Create new checkpoint.\\n        // No missing global checkpoints, but timestamp == block.timestamp. Overwrite last checkpoint.\\n        if (\\n            _epoch != 1 && self._pointHistory[_epoch - 1].ts == block.timestamp\\n        ) {\\n            // _epoch = epoch + 1, so we do not increment epoch\\n            self._pointHistory[_epoch - 1] = lastPoint;\\n        } else {\\n            // more than one global point may have been written, so we update epoch\\n            self.epoch = _epoch;\\n            self._pointHistory[_epoch] = lastPoint;\\n        }\\n\\n        if (_tokenId != 0) {\\n            // Schedule the slope changes (slope is going down)\\n            // We subtract new_user_slope from [_newLocked.end]\\n            // and add old_user_slope to [_oldLocked.end]\\n            if (_oldLocked.end > block.timestamp) {\\n                // oldDslope was <something> - uOld.slope, so we cancel that\\n                oldDslope += uOld.slope;\\n                if (_newLocked.end == _oldLocked.end) {\\n                    oldDslope -= uNew.slope; // It was a new deposit, not extension\\n                }\\n                self.slopeChanges[_oldLocked.end] = oldDslope;\\n            }\\n\\n            if (_newLocked.end > block.timestamp) {\\n                // update slope if new lock is greater than old lock and is not permanent or if old lock is permanent\\n                if ((_newLocked.end > _oldLocked.end)) {\\n                    newDslope -= uNew.slope; // old slope disappeared at this point\\n                    self.slopeChanges[_newLocked.end] = newDslope;\\n                }\\n                // else: we recorded it already in oldDslope\\n            }\\n            // If timestamp of last user point is the same, overwrite the last user point\\n            // Else record the new user point into history\\n            // Exclude epoch 0\\n            uNew.ts = block.timestamp;\\n            uNew.blk = block.number;\\n            uint256 userEpoch = self.userPointEpoch[_tokenId];\\n            if (\\n                userEpoch != 0 &&\\n                self._userPointHistory[_tokenId][userEpoch].ts ==\\n                block.timestamp\\n            ) {\\n                self._userPointHistory[_tokenId][userEpoch] = uNew;\\n            } else {\\n                self.userPointEpoch[_tokenId] = ++userEpoch;\\n                self._userPointHistory[_tokenId][userEpoch] = uNew;\\n            }\\n        }\\n    }\\n\\n    function _updateHistory(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _epoch,\\n        IVotingEscrow.GlobalPoint memory lastPoint,\\n        uint256 lastCheckpoint,\\n        IVotingEscrow.GlobalPoint memory initialLastPoint,\\n        uint256 blockSlope\\n    ) internal returns (uint256, IVotingEscrow.GlobalPoint memory) {\\n        uint256 t_i = (lastCheckpoint / WEEK) * WEEK;\\n        for (uint256 i = 0; i < 255; ++i) {\\n            // Hopefully it won't happen that this won't get used in 5 years!\\n            // If it does, users will be able to withdraw but vote weight will be broken\\n            t_i += WEEK; // Initial value of t_i is always larger than the ts of the last point\\n            int128 d_slope = 0;\\n            if (t_i > block.timestamp) {\\n                t_i = block.timestamp;\\n            } else {\\n                d_slope = self.slopeChanges[t_i];\\n            }\\n            lastPoint.bias -=\\n                lastPoint.slope *\\n                (t_i - lastCheckpoint).toInt128();\\n            lastPoint.slope += d_slope;\\n            if (lastPoint.bias < 0) {\\n                // This can happen\\n                lastPoint.bias = 0;\\n            }\\n            if (lastPoint.slope < 0) {\\n                // This cannot happen - just in case\\n                lastPoint.slope = 0;\\n            }\\n            lastCheckpoint = t_i;\\n            lastPoint.ts = t_i;\\n            lastPoint.blk =\\n                initialLastPoint.blk +\\n                (blockSlope * (t_i - initialLastPoint.ts)) /\\n                MULTIPLIER;\\n            _epoch += 1;\\n            if (t_i == block.timestamp) {\\n                lastPoint.blk = block.number;\\n                break;\\n            } else {\\n                self._pointHistory[_epoch] = lastPoint;\\n            }\\n        }\\n        return (_epoch, lastPoint);\\n    }\\n\\n    /// @dev Deposit `_value` tokens for `_to` and lock for `_lockDuration`\\n    /// @param _value Amount to deposit\\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\\n    /// @param _to Address to deposit\\n    function _createLock(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _value,\\n        uint256 _lockDuration,\\n        address _to\\n    ) external returns (uint256) {\\n        uint256 unlockTime = ((block.timestamp + _lockDuration) / WEEK) * WEEK; // Locktime is rounded down to weeks\\n\\n        if (_value == 0) revert IVotingEscrow.ZeroAmount();\\n        if (unlockTime <= block.timestamp)\\n            revert IVotingEscrow.LockDurationNotInFuture();\\n        if (unlockTime > block.timestamp + MAXTIME)\\n            revert IVotingEscrow.LockDurationTooLong();\\n\\n        uint256 _tokenId = ++self.tokenId;\\n        self._mint(_to, _tokenId);\\n\\n        _depositFor(\\n            self,\\n            _tokenId,\\n            _value,\\n            unlockTime,\\n            self._locked[_tokenId],\\n            IVotingEscrow.DepositType.CREATE_LOCK_TYPE\\n        );\\n        return _tokenId;\\n    }\\n\\n    function increaseAmount(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        uint256 _value\\n    ) external {\\n        if (!self._isApprovedOrOwner(self._msgSender(), _tokenId))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        _increaseAmountFor(\\n            self,\\n            _tokenId,\\n            _value,\\n            IVotingEscrow.DepositType.INCREASE_LOCK_AMOUNT\\n        );\\n    }\\n\\n    function _increaseAmountFor(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        uint256 _value,\\n        IVotingEscrow.DepositType _depositType\\n    ) internal {\\n        IVotingEscrow.EscrowType _escrowType = self.escrowType[_tokenId];\\n        if (_escrowType == IVotingEscrow.EscrowType.LOCKED)\\n            revert IVotingEscrow.NotManagedOrNormalNFT();\\n\\n        IVotingEscrow.LockedBalance memory oldLocked = self._locked[_tokenId];\\n\\n        if (_value == 0) revert IVotingEscrow.ZeroAmount();\\n        if (oldLocked.amount <= 0) revert IVotingEscrow.NoLockFound();\\n        if (oldLocked.end <= block.timestamp && !oldLocked.isPermanent)\\n            revert IVotingEscrow.LockExpired();\\n\\n        if (oldLocked.isPermanent) self.permanentLockBalance += _value;\\n        self._checkpointDelegatee(self._delegates[_tokenId], _value, true);\\n        _depositFor(self, _tokenId, _value, 0, oldLocked, _depositType);\\n\\n        if (_escrowType == IVotingEscrow.EscrowType.MANAGED) {\\n            // increaseAmount called on managed tokens are treated as locked rewards\\n            address _lockedManagedReward = self.managedToLocked[_tokenId];\\n            address _token = self.token;\\n            IERC20(_token).safeApprove(_lockedManagedReward, _value);\\n            IReward(_lockedManagedReward).notifyRewardAmount(_token, _value);\\n            IERC20(_token).safeApprove(_lockedManagedReward, 0);\\n        }\\n\\n        emit IERC4906.MetadataUpdate(_tokenId);\\n    }\\n\\n    function increaseUnlockTime(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        uint256 _lockDuration\\n    ) external {\\n        if (!self._isApprovedOrOwner(self._msgSender(), _tokenId))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.NORMAL)\\n            revert IVotingEscrow.NotNormalNFT();\\n\\n        IVotingEscrow.LockedBalance memory oldLocked = self._locked[_tokenId];\\n        if (oldLocked.isPermanent) revert IVotingEscrow.PermanentLock();\\n        uint256 unlockTime = ((block.timestamp + _lockDuration) / WEEK) * WEEK; // Locktime is rounded down to weeks\\n\\n        if (oldLocked.end <= block.timestamp)\\n            revert IVotingEscrow.LockExpired();\\n        if (oldLocked.amount <= 0) revert IVotingEscrow.NoLockFound();\\n        if (unlockTime <= oldLocked.end)\\n            revert IVotingEscrow.LockDurationNotInFuture();\\n        if (unlockTime > block.timestamp + MAXTIME)\\n            revert IVotingEscrow.LockDurationTooLong();\\n\\n        _depositFor(\\n            self,\\n            _tokenId,\\n            0,\\n            unlockTime,\\n            oldLocked,\\n            IVotingEscrow.DepositType.INCREASE_UNLOCK_TIME\\n        );\\n\\n        emit IERC4906.MetadataUpdate(_tokenId);\\n    }\\n\\n    function withdraw(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) external {\\n        address sender = self._msgSender();\\n        if (!self._isApprovedOrOwner(sender, _tokenId))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        if (self.voted[_tokenId]) revert IVotingEscrow.AlreadyVoted();\\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.NORMAL)\\n            revert IVotingEscrow.NotNormalNFT();\\n\\n        IVotingEscrow.LockedBalance memory oldLocked = self._locked[_tokenId];\\n        if (oldLocked.isPermanent) revert IVotingEscrow.PermanentLock();\\n        if (block.timestamp < oldLocked.end)\\n            revert IVotingEscrow.LockNotExpired();\\n        uint256 value = oldLocked.amount.toUint256();\\n\\n        // Burn the NFT\\n        self._burn(_tokenId);\\n        self._locked[_tokenId] = IVotingEscrow.LockedBalance(0, 0, false);\\n        uint256 supplyBefore = self.supply;\\n        self.supply = supplyBefore - value;\\n\\n        // oldLocked can have either expired <= timestamp or zero end\\n        // oldLocked has only 0 end\\n        // Both can have >= 0 amount\\n        _checkpoint(\\n            self,\\n            _tokenId,\\n            oldLocked,\\n            IVotingEscrow.LockedBalance(0, 0, false)\\n        );\\n\\n        IERC20(self.token).safeTransfer(sender, value);\\n\\n        emit IVotingEscrow.Withdraw(sender, _tokenId, value, block.timestamp);\\n        emit IVotingEscrow.Supply(supplyBefore, supplyBefore - value);\\n    }\\n\\n    function merge(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _from,\\n        uint256 _to\\n    ) external {\\n        address sender = self._msgSender();\\n        if (self.voted[_from]) revert IVotingEscrow.AlreadyVoted();\\n        if (self.escrowType[_from] != IVotingEscrow.EscrowType.NORMAL)\\n            revert IVotingEscrow.NotNormalNFT();\\n        if (self.escrowType[_to] != IVotingEscrow.EscrowType.NORMAL)\\n            revert IVotingEscrow.NotNormalNFT();\\n        if (_from == _to) revert IVotingEscrow.SameNFT();\\n        if (!self._isApprovedOrOwner(sender, _from))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        if (!self._isApprovedOrOwner(sender, _to))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        IVotingEscrow.LockedBalance memory oldLockedTo = self._locked[_to];\\n        if (oldLockedTo.end <= block.timestamp && !oldLockedTo.isPermanent)\\n            revert IVotingEscrow.LockExpired();\\n\\n        IVotingEscrow.LockedBalance memory oldLockedFrom = self._locked[_from];\\n        if (oldLockedFrom.isPermanent) revert IVotingEscrow.PermanentLock();\\n        uint256 end = oldLockedFrom.end >= oldLockedTo.end\\n            ? oldLockedFrom.end\\n            : oldLockedTo.end;\\n\\n        self._burn(_from);\\n        self._locked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\\n        _checkpoint(\\n            self,\\n            _from,\\n            oldLockedFrom,\\n            IVotingEscrow.LockedBalance(0, 0, false)\\n        );\\n\\n        IVotingEscrow.LockedBalance memory newLockedTo;\\n        newLockedTo.amount = oldLockedTo.amount + oldLockedFrom.amount;\\n        newLockedTo.isPermanent = oldLockedTo.isPermanent;\\n        if (newLockedTo.isPermanent) {\\n            self.permanentLockBalance += oldLockedFrom.amount.toUint256();\\n        } else {\\n            newLockedTo.end = end;\\n        }\\n        self._checkpointDelegatee(\\n            self._delegates[_to],\\n            oldLockedFrom.amount.toUint256(),\\n            true\\n        );\\n        _checkpoint(self, _to, oldLockedTo, newLockedTo);\\n        self._locked[_to] = newLockedTo;\\n\\n        emit IVotingEscrow.Merge(\\n            sender,\\n            _from,\\n            _to,\\n            oldLockedFrom.amount.toUint256(),\\n            oldLockedTo.amount.toUint256(),\\n            newLockedTo.amount.toUint256(),\\n            newLockedTo.end,\\n            block.timestamp\\n        );\\n        emit IERC4906.MetadataUpdate(_to);\\n    }\\n\\n    function split(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _from,\\n        uint256 _amount\\n    ) external returns (uint256 _tokenId1, uint256 _tokenId2) {\\n        address sender = self._msgSender();\\n        address owner = self._ownerOf(_from);\\n        if (owner == address(0)) revert IVotingEscrow.SplitNoOwner();\\n        if (!self.canSplit[owner] && !self.canSplit[address(0)])\\n            revert IVotingEscrow.SplitNotAllowed();\\n        if (self.escrowType[_from] != IVotingEscrow.EscrowType.NORMAL)\\n            revert IVotingEscrow.NotNormalNFT();\\n        if (self.voted[_from]) revert IVotingEscrow.AlreadyVoted();\\n        if (!self._isApprovedOrOwner(sender, _from))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        IVotingEscrow.LockedBalance memory newLocked = self._locked[_from];\\n        if (newLocked.end <= block.timestamp && !newLocked.isPermanent)\\n            revert IVotingEscrow.LockExpired();\\n        int128 _splitAmount = _amount.toInt128();\\n        if (_splitAmount == 0) revert IVotingEscrow.ZeroAmount();\\n        if (newLocked.amount <= _splitAmount)\\n            revert IVotingEscrow.AmountTooBig();\\n\\n        // Zero out and burn old veNFT\\n        self._burn(_from);\\n        self._locked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\\n        _checkpoint(\\n            self,\\n            _from,\\n            newLocked,\\n            IVotingEscrow.LockedBalance(0, 0, false)\\n        );\\n\\n        // Create new veNFT using old balance - amount\\n        newLocked.amount -= _splitAmount;\\n        _tokenId1 = _createSplitNFT(self, owner, newLocked);\\n\\n        // Create new veNFT using amount\\n        newLocked.amount = _splitAmount;\\n        _tokenId2 = _createSplitNFT(self, owner, newLocked);\\n\\n        emit IVotingEscrow.Split(\\n            _from,\\n            _tokenId1,\\n            _tokenId2,\\n            sender,\\n            self._locked[_tokenId1].amount.toUint256(),\\n            _splitAmount.toUint256(),\\n            newLocked.end,\\n            block.timestamp\\n        );\\n    }\\n\\n    function _createSplitNFT(\\n        VotingEscrowState.Storage storage self,\\n        address _to,\\n        IVotingEscrow.LockedBalance memory _newLocked\\n    ) internal returns (uint256 _tokenId) {\\n        _tokenId = ++self.tokenId;\\n        self._locked[_tokenId] = _newLocked;\\n        _checkpoint(\\n            self,\\n            _tokenId,\\n            IVotingEscrow.LockedBalance(0, 0, false),\\n            _newLocked\\n        );\\n        self._mint(_to, _tokenId);\\n    }\\n\\n    function toggleSplit(\\n        VotingEscrowState.Storage storage self,\\n        address _account,\\n        bool _bool\\n    ) external {\\n        if (self._msgSender() != self.team) revert IVotingEscrow.NotTeam();\\n        self.canSplit[_account] = _bool;\\n    }\\n\\n    function lockPermanent(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) external {\\n        address sender = self._msgSender();\\n        if (!self._isApprovedOrOwner(sender, _tokenId))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.NORMAL)\\n            revert IVotingEscrow.NotNormalNFT();\\n        IVotingEscrow.LockedBalance memory _newLocked = self._locked[_tokenId];\\n        if (_newLocked.isPermanent) revert IVotingEscrow.PermanentLock();\\n        if (_newLocked.end <= block.timestamp)\\n            revert IVotingEscrow.LockExpired();\\n        if (_newLocked.amount <= 0) revert IVotingEscrow.NoLockFound();\\n\\n        uint256 _amount = _newLocked.amount.toUint256();\\n        self.permanentLockBalance += _amount;\\n        _newLocked.end = 0;\\n        _newLocked.isPermanent = true;\\n        _checkpoint(self, _tokenId, self._locked[_tokenId], _newLocked);\\n        self._locked[_tokenId] = _newLocked;\\n\\n        emit IVotingEscrow.LockPermanent(\\n            sender,\\n            _tokenId,\\n            _amount,\\n            block.timestamp\\n        );\\n        emit IERC4906.MetadataUpdate(_tokenId);\\n    }\\n\\n    function unlockPermanent(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) external {\\n        address sender = self._msgSender();\\n        if (!self._isApprovedOrOwner(sender, _tokenId))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.NORMAL)\\n            revert IVotingEscrow.NotNormalNFT();\\n        if (self.voted[_tokenId]) revert IVotingEscrow.AlreadyVoted();\\n        IVotingEscrow.LockedBalance memory _newLocked = self._locked[_tokenId];\\n        if (!_newLocked.isPermanent) revert IVotingEscrow.NotPermanentLock();\\n\\n        uint256 _amount = _newLocked.amount.toUint256();\\n        self.permanentLockBalance -= _amount;\\n        _newLocked.end = ((block.timestamp + MAXTIME) / WEEK) * WEEK;\\n        _newLocked.isPermanent = false;\\n        self._delegate(_tokenId, 0);\\n        _checkpoint(self, _tokenId, self._locked[_tokenId], _newLocked);\\n        self._locked[_tokenId] = _newLocked;\\n\\n        emit IVotingEscrow.UnlockPermanent(\\n            sender,\\n            _tokenId,\\n            _amount,\\n            block.timestamp\\n        );\\n        emit IERC4906.MetadataUpdate(_tokenId);\\n    }\\n}\\n\",\"keccak256\":\"0xef9901ed8f13f7b22ee76198e0fb01b84f5861b05226bedcaac99787b984c612\",\"license\":\"BUSL-1.1\"},\"contracts/ve/ManagedNFT.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.24;\\n\\nimport {VotingEscrowState} from \\\"./VotingEscrowState.sol\\\";\\nimport {Escrow} from \\\"./Escrow.sol\\\";\\nimport {NFT} from \\\"./NFT.sol\\\";\\nimport {Delegation} from \\\"./Delegation.sol\\\";\\nimport {Balance} from \\\"./Balance.sol\\\";\\nimport {VeERC2771Context} from \\\"./VeERC2771Context.sol\\\";\\nimport {SafeCastLibrary} from \\\"../libraries/SafeCastLibrary.sol\\\";\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport {IReward} from \\\"../interfaces/IReward.sol\\\";\\nimport {IVoter} from \\\"../interfaces/IVoter.sol\\\";\\nimport {IManagedRewardsFactory} from \\\"../interfaces/factories/IManagedRewardsFactory.sol\\\";\\nimport {IFactoryRegistry} from \\\"../interfaces/factories/IFactoryRegistry.sol\\\";\\nimport {IERC4906} from \\\"@openzeppelin/contracts/interfaces/IERC4906.sol\\\";\\n\\nlibrary ManagedNFT {\\n    using SafeCastLibrary for uint256;\\n    using SafeCastLibrary for int128;\\n    using NFT for VotingEscrowState.Storage;\\n    using Escrow for VotingEscrowState.Storage;\\n    using Delegation for VotingEscrowState.Storage;\\n    using Balance for VotingEscrowState.Storage;\\n    using VeERC2771Context for VotingEscrowState.Storage;\\n\\n    function createManagedLockFor(\\n        VotingEscrowState.Storage storage self,\\n        address _to\\n    ) external returns (uint256 _mTokenId) {\\n        address sender = self._msgSender();\\n        if (\\n            sender != self.allowedManager &&\\n            sender != IVoter(self.voter).governor()\\n        ) revert IVotingEscrow.NotGovernorOrManager();\\n\\n        _mTokenId = ++self.tokenId;\\n        self._mint(_to, _mTokenId);\\n        self._depositFor(\\n            _mTokenId,\\n            0,\\n            0,\\n            IVotingEscrow.LockedBalance(0, 0, true),\\n            IVotingEscrow.DepositType.CREATE_LOCK_TYPE\\n        );\\n\\n        self.escrowType[_mTokenId] = IVotingEscrow.EscrowType.MANAGED;\\n\\n        (\\n            address _lockedManagedReward,\\n            address _freeManagedReward\\n        ) = IManagedRewardsFactory(\\n                IFactoryRegistry(self.factoryRegistry).managedRewardsFactory()\\n            ).createRewards(self.trustedForwarder, self.voter);\\n        self.managedToLocked[_mTokenId] = _lockedManagedReward;\\n        self.managedToFree[_mTokenId] = _freeManagedReward;\\n\\n        emit IVotingEscrow.CreateManaged(\\n            _to,\\n            _mTokenId,\\n            sender,\\n            _lockedManagedReward,\\n            _freeManagedReward\\n        );\\n    }\\n\\n    function depositManaged(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        uint256 _mTokenId\\n    ) external {\\n        if (self._msgSender() != self.voter) revert IVotingEscrow.NotVoter();\\n        if (self.escrowType[_mTokenId] != IVotingEscrow.EscrowType.MANAGED)\\n            revert IVotingEscrow.NotManagedNFT();\\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.NORMAL)\\n            revert IVotingEscrow.NotNormalNFT();\\n        if (self._balanceOfNFTAt(_tokenId, block.timestamp) == 0)\\n            revert IVotingEscrow.ZeroBalance();\\n\\n        // adjust user nft\\n        int128 _amount = self._locked[_tokenId].amount;\\n        if (self._locked[_tokenId].isPermanent) {\\n            self.permanentLockBalance -= _amount.toUint256();\\n            self._delegate(_tokenId, 0);\\n        }\\n        self._checkpoint(\\n            _tokenId,\\n            self._locked[_tokenId],\\n            IVotingEscrow.LockedBalance(0, 0, false)\\n        );\\n        self._locked[_tokenId] = IVotingEscrow.LockedBalance(0, 0, false);\\n\\n        // adjust managed nft\\n        uint256 _weight = _amount.toUint256();\\n        self.permanentLockBalance += _weight;\\n        IVotingEscrow.LockedBalance memory newLocked = self._locked[_mTokenId];\\n        newLocked.amount += _amount;\\n        self._checkpointDelegatee(self._delegates[_mTokenId], _weight, true);\\n        self._checkpoint(_mTokenId, self._locked[_mTokenId], newLocked);\\n        self._locked[_mTokenId] = newLocked;\\n\\n        self.weights[_tokenId][_mTokenId] = _weight;\\n        self.idToManaged[_tokenId] = _mTokenId;\\n        self.escrowType[_tokenId] = IVotingEscrow.EscrowType.LOCKED;\\n\\n        address _lockedManagedReward = self.managedToLocked[_mTokenId];\\n        IReward(_lockedManagedReward)._deposit(_weight, _tokenId);\\n        address _freeManagedReward = self.managedToFree[_mTokenId];\\n        IReward(_freeManagedReward)._deposit(_weight, _tokenId);\\n\\n        emit IVotingEscrow.DepositManaged(\\n            self._ownerOf(_tokenId),\\n            _tokenId,\\n            _mTokenId,\\n            _weight,\\n            block.timestamp\\n        );\\n        emit IERC4906.MetadataUpdate(_tokenId);\\n    }\\n\\n    function withdrawManaged(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) external {\\n        uint256 _mTokenId = self.idToManaged[_tokenId];\\n        if (self._msgSender() != self.voter) revert IVotingEscrow.NotVoter();\\n        if (_mTokenId == 0) revert IVotingEscrow.InvalidManagedNFTId();\\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.LOCKED)\\n            revert IVotingEscrow.NotLockedNFT();\\n\\n        // update accrued rewards\\n        address _lockedManagedReward = self.managedToLocked[_mTokenId];\\n        address _freeManagedReward = self.managedToFree[_mTokenId];\\n        uint256 _weight = self.weights[_tokenId][_mTokenId];\\n        uint256 _reward = IReward(_lockedManagedReward).earned(\\n            address(self.token),\\n            _tokenId\\n        );\\n        uint256 _total = _weight + _reward;\\n        uint256 _unlockTime = ((block.timestamp + Escrow.MAXTIME) /\\n            Escrow.WEEK) * Escrow.WEEK;\\n\\n        // claim locked rewards (rebases + compounded reward)\\n        address[] memory rewards = new address[](1);\\n        rewards[0] = address(self.token);\\n        IReward(_lockedManagedReward).getReward(_tokenId, rewards);\\n\\n        _adjustUserNFT(self, _tokenId, _total, _unlockTime);\\n        _adjustManagedNFT(self, _mTokenId, _total);\\n\\n        IReward(_lockedManagedReward)._withdraw(_weight, _tokenId);\\n        IReward(_freeManagedReward)._withdraw(_weight, _tokenId);\\n\\n        delete self.idToManaged[_tokenId];\\n        delete self.weights[_tokenId][_mTokenId];\\n        delete self.escrowType[_tokenId];\\n\\n        emit IVotingEscrow.WithdrawManaged(\\n            self._ownerOf(_tokenId),\\n            _tokenId,\\n            _mTokenId,\\n            _total,\\n            block.timestamp\\n        );\\n        emit IERC4906.MetadataUpdate(_tokenId);\\n    }\\n\\n    function _adjustUserNFT(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        uint256 _total,\\n        uint256 _unlockTime\\n    ) internal {\\n        IVotingEscrow.LockedBalance memory newLockedNormal = IVotingEscrow\\n            .LockedBalance(_total.toInt128(), _unlockTime, false);\\n        self._checkpoint(_tokenId, self._locked[_tokenId], newLockedNormal);\\n        self._locked[_tokenId] = newLockedNormal;\\n    }\\n\\n    function _adjustManagedNFT(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _mTokenId,\\n        uint256 _total\\n    ) internal {\\n        IVotingEscrow.LockedBalance memory newLockedManaged = self._locked[\\n            _mTokenId\\n        ];\\n        // do not expect _total > locked.amount / permanentLockBalance but just in case\\n        newLockedManaged.amount -= (\\n            _total.toInt128() < newLockedManaged.amount\\n                ? _total.toInt128()\\n                : newLockedManaged.amount\\n        );\\n        self.permanentLockBalance -= (\\n            _total < self.permanentLockBalance\\n                ? _total\\n                : self.permanentLockBalance\\n        );\\n        self._checkpointDelegatee(self._delegates[_mTokenId], _total, false);\\n        self._checkpoint(_mTokenId, self._locked[_mTokenId], newLockedManaged);\\n        self._locked[_mTokenId] = newLockedManaged;\\n    }\\n\\n    function setAllowedManager(\\n        VotingEscrowState.Storage storage self,\\n        address _allowedManager\\n    ) external {\\n        if (self._msgSender() != IVoter(self.voter).governor())\\n            revert IVotingEscrow.NotGovernor();\\n        if (_allowedManager == self.allowedManager)\\n            revert IVotingEscrow.SameAddress();\\n        if (_allowedManager == address(0)) revert IVotingEscrow.ZeroAddress();\\n        self.allowedManager = _allowedManager;\\n        emit IVotingEscrow.SetAllowedManager(_allowedManager);\\n    }\\n\\n    function setManagedState(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _mTokenId,\\n        bool _state\\n    ) external {\\n        if (\\n            self._msgSender() != IVoter(self.voter).emergencyCouncil() &&\\n            self._msgSender() != IVoter(self.voter).governor()\\n        ) revert IVotingEscrow.NotEmergencyCouncilOrGovernor();\\n        if (self.escrowType[_mTokenId] != IVotingEscrow.EscrowType.MANAGED)\\n            revert IVotingEscrow.NotManagedNFT();\\n        if (self.deactivated[_mTokenId] == _state)\\n            revert IVotingEscrow.SameState();\\n        self.deactivated[_mTokenId] = _state;\\n    }\\n}\\n\",\"keccak256\":\"0x6123ba0ff4676fd1cd77ae179975ef2fdbac9e66113452749df1fba2e15bea16\",\"license\":\"BUSL-1.1\"},\"contracts/ve/NFT.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.24;\\n\\nimport {VotingEscrowState} from \\\"./VotingEscrowState.sol\\\";\\nimport {Delegation} from \\\"./Delegation.sol\\\";\\nimport {VeERC2771Context} from \\\"./VeERC2771Context.sol\\\";\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport {IVeArtProxy} from \\\"../interfaces/IVeArtProxy.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\n\\nlibrary NFT {\\n    using Delegation for VotingEscrowState.Storage;\\n    using VeERC2771Context for VotingEscrowState.Storage;\\n\\n    function approve(\\n        VotingEscrowState.Storage storage self,\\n        address _approved,\\n        uint256 _tokenId\\n    ) external {\\n        address sender = self._msgSender();\\n        address owner = _ownerOf(self, _tokenId);\\n        // Throws if `_tokenId` is not a valid NFT\\n        if (owner == address(0)) revert IVotingEscrow.ZeroAddress();\\n        // Throws if `_approved` is the current owner\\n        if (owner == _approved) revert IVotingEscrow.SameAddress();\\n        // Check requirements\\n        bool senderIsOwner = (_ownerOf(self, _tokenId) == sender);\\n        bool senderIsApprovedForAll = (self.ownerToOperators[owner])[sender];\\n        if (!senderIsOwner && !senderIsApprovedForAll)\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        // Set the approval\\n        self.idToApprovals[_tokenId] = _approved;\\n        emit IERC721.Approval(owner, _approved, _tokenId);\\n    }\\n\\n    function setApprovalForAll(\\n        VotingEscrowState.Storage storage self,\\n        address _operator,\\n        bool _approved\\n    ) external {\\n        address sender = self._msgSender();\\n        // Throws if `_operator` is the `msg.sender`\\n        if (_operator == sender) revert IVotingEscrow.SameAddress();\\n        self.ownerToOperators[sender][_operator] = _approved;\\n        emit IERC721.ApprovalForAll(sender, _operator, _approved);\\n    }\\n\\n    function safeTransferFrom(\\n        VotingEscrowState.Storage storage self,\\n        address _from,\\n        address _to,\\n        uint256 _tokenId,\\n        bytes memory _data\\n    ) external {\\n        address sender = self._msgSender();\\n        _transferFrom(self, _from, _to, _tokenId, sender);\\n\\n        if (_isContract(_to)) {\\n            // Throws if transfer destination is a contract which does not implement 'onERC721Received'\\n            try\\n                IERC721Receiver(_to).onERC721Received(\\n                    sender,\\n                    _from,\\n                    _tokenId,\\n                    _data\\n                )\\n            returns (bytes4 response) {\\n                if (\\n                    response != IERC721Receiver(_to).onERC721Received.selector\\n                ) {\\n                    revert IVotingEscrow.ERC721ReceiverRejectedTokens();\\n                }\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert IVotingEscrow\\n                        .ERC721TransferToNonERC721ReceiverImplementer();\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function _transferFrom(\\n        VotingEscrowState.Storage storage self,\\n        address _from,\\n        address _to,\\n        uint256 _tokenId,\\n        address _sender\\n    ) internal {\\n        if (self.escrowType[_tokenId] == IVotingEscrow.EscrowType.LOCKED)\\n            revert IVotingEscrow.NotManagedOrNormalNFT();\\n        // Check requirements\\n        if (!_isApprovedOrOwner(self, _sender, _tokenId))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        // Clear approval. Throws if `_from` is not the current owner\\n        if (_ownerOf(self, _tokenId) != _from) revert IVotingEscrow.NotOwner();\\n        delete self.idToApprovals[_tokenId];\\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\\n        _removeTokenFrom(self, _from, _tokenId);\\n        // Update voting checkpoints\\n        self._checkpointDelegator(_tokenId, 0, _to);\\n        // Add NFT\\n        _addTokenTo(self, _to, _tokenId);\\n        // Set the block of ownership transfer (for Flash NFT protection)\\n        self.ownershipChange[_tokenId] = block.number;\\n        // Log the transfer\\n        emit IERC721.Transfer(_from, _to, _tokenId);\\n    }\\n\\n    function _isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /// @dev Add a NFT to a given address\\n    ///      Throws if `_tokenId` is owned by someone.\\n    function _addTokenTo(\\n        VotingEscrowState.Storage storage self,\\n        address _to,\\n        uint256 _tokenId\\n    ) internal {\\n        // Throws if `_tokenId` is owned by someone\\n        assert(_ownerOf(self, _tokenId) == address(0));\\n        // Change the owner\\n        self.idToOwner[_tokenId] = _to;\\n        // Update owner token index tracking\\n        _addTokenToOwnerList(self, _to, _tokenId);\\n        // Change count tracking\\n        self.ownerToNFTokenCount[_to] += 1;\\n    }\\n\\n    /// @dev Function to mint tokens\\n    ///      Throws if `_to` is zero address.\\n    ///      Throws if `_tokenId` is owned by someone.\\n    /// @param _to The address that will receive the minted tokens.\\n    /// @param _tokenId The token id to mint.\\n    /// @return A boolean that indicates if the operation was successful.\\n    function _mint(\\n        VotingEscrowState.Storage storage self,\\n        address _to,\\n        uint256 _tokenId\\n    ) internal returns (bool) {\\n        // Throws if `_to` is zero address\\n        assert(_to != address(0));\\n        // Add NFT. Throws if `_tokenId` is owned by someone\\n        _addTokenTo(self, _to, _tokenId);\\n        // Update voting checkpoints\\n        self._checkpointDelegator(_tokenId, 0, _to);\\n        emit IERC721.Transfer(address(0), _to, _tokenId);\\n        return true;\\n    }\\n\\n    /// @dev Add a NFT to an index mapping to a given address\\n    /// @param _to address of the receiver\\n    /// @param _tokenId uint ID Of the token to be added\\n    function _addTokenToOwnerList(\\n        VotingEscrowState.Storage storage self,\\n        address _to,\\n        uint256 _tokenId\\n    ) internal {\\n        uint256 currentCount = self.ownerToNFTokenCount[_to];\\n\\n        self.ownerToNFTokenIdList[_to][currentCount] = _tokenId;\\n        self.tokenToOwnerIndex[_tokenId] = currentCount;\\n    }\\n\\n    function _ownerOf(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) internal view returns (address) {\\n        return self.idToOwner[_tokenId];\\n    }\\n\\n    function _isApprovedOrOwner(\\n        VotingEscrowState.Storage storage self,\\n        address _spender,\\n        uint256 _tokenId\\n    ) internal view returns (bool) {\\n        address owner = _ownerOf(self, _tokenId);\\n        bool spenderIsOwner = owner == _spender;\\n        bool spenderIsApproved = _spender == self.idToApprovals[_tokenId];\\n        bool spenderIsApprovedForAll = (self.ownerToOperators[owner])[_spender];\\n        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\\n    }\\n\\n    /// @dev Must be called prior to updating `LockedBalance`\\n    function _burn(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) internal {\\n        address sender = self._msgSender();\\n        if (!_isApprovedOrOwner(self, sender, _tokenId))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        address owner = _ownerOf(self, _tokenId);\\n\\n        // Clear approval\\n        delete self.idToApprovals[_tokenId];\\n        // Update voting checkpoints\\n        self._checkpointDelegator(_tokenId, 0, address(0));\\n        // Remove token\\n        _removeTokenFrom(self, owner, _tokenId);\\n        emit IERC721.Transfer(owner, address(0), _tokenId);\\n    }\\n\\n    /// @dev Remove a NFT from a given address\\n    ///      Throws if `_from` is not the current owner.\\n    function _removeTokenFrom(\\n        VotingEscrowState.Storage storage self,\\n        address _from,\\n        uint256 _tokenId\\n    ) internal {\\n        // Throws if `_from` is not the current owner\\n        assert(_ownerOf(self, _tokenId) == _from);\\n        // Change the owner\\n        self.idToOwner[_tokenId] = address(0);\\n        // Update owner token index tracking\\n        _removeTokenFromOwnerList(self, _from, _tokenId);\\n        // Change count tracking\\n        self.ownerToNFTokenCount[_from] -= 1;\\n    }\\n\\n    /// @dev Remove a NFT from an index mapping to a given address\\n    /// @param _from address of the sender\\n    /// @param _tokenId uint ID Of the token to be removed\\n    function _removeTokenFromOwnerList(\\n        VotingEscrowState.Storage storage self,\\n        address _from,\\n        uint256 _tokenId\\n    ) internal {\\n        // Delete\\n        uint256 currentCount = self.ownerToNFTokenCount[_from] - 1;\\n        uint256 currentIndex = self.tokenToOwnerIndex[_tokenId];\\n\\n        if (currentCount == currentIndex) {\\n            // update ownerToNFTokenIdList\\n            self.ownerToNFTokenIdList[_from][currentCount] = 0;\\n            // update tokenToOwnerIndex\\n            self.tokenToOwnerIndex[_tokenId] = 0;\\n        } else {\\n            uint256 lastTokenId = self.ownerToNFTokenIdList[_from][\\n                currentCount\\n            ];\\n\\n            // Add\\n            // update ownerToNFTokenIdList\\n            self.ownerToNFTokenIdList[_from][currentIndex] = lastTokenId;\\n            // update tokenToOwnerIndex\\n            self.tokenToOwnerIndex[lastTokenId] = currentIndex;\\n\\n            // Delete\\n            // update ownerToNFTokenIdList\\n            self.ownerToNFTokenIdList[_from][currentCount] = 0;\\n            // update tokenToOwnerIndex\\n            self.tokenToOwnerIndex[_tokenId] = 0;\\n        }\\n    }\\n\\n    function tokenURI(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) external view returns (string memory) {\\n        if (_ownerOf(self, _tokenId) == address(0))\\n            revert IVotingEscrow.NonExistentToken();\\n        return IVeArtProxy(self.artProxy).tokenURI(_tokenId);\\n    }\\n}\\n\",\"keccak256\":\"0x7a4323cca513754436705ee05695f7bb951d959a1e339734f195c9999d2bcc56\",\"license\":\"BUSL-1.1\"},\"contracts/ve/VeERC2771Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Based on openzeppelin-contracts/contracts/metatx/ERC2771Context.sol\\n\\npragma solidity 0.8.24;\\n\\nimport {VotingEscrowState} from \\\"./VotingEscrowState.sol\\\";\\n\\n/**\\n * @dev Context variant with ERC2771 support. Extracted to library to allow\\n *      easy application inside libraries.\\n */\\nlibrary VeERC2771Context {\\n    function isTrustedForwarder(\\n        VotingEscrowState.Storage storage self,\\n        address forwarder\\n    ) internal view returns (bool) {\\n        return forwarder == self.trustedForwarder;\\n    }\\n\\n    function _msgSender(\\n        VotingEscrowState.Storage storage self\\n    ) internal view returns (address sender) {\\n        if (isTrustedForwarder(self, msg.sender)) {\\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n        } else {\\n            return msg.sender;\\n        }\\n    }\\n\\n    function _msgData(\\n        VotingEscrowState.Storage storage self\\n    ) internal view returns (bytes calldata) {\\n        if (isTrustedForwarder(self, msg.sender)) {\\n            return msg.data[:msg.data.length - 20];\\n        } else {\\n            return msg.data;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xad2e32f0921a55dc07d8ecac879666cdba7828ef54889a32c0f53bbc431170f0\",\"license\":\"MIT\"},\"contracts/ve/VotingEscrowState.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.24;\\n\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport {VeERC2771Context} from \\\"./VeERC2771Context.sol\\\";\\nimport {IERC4906} from \\\"@openzeppelin/contracts/interfaces/IERC4906.sol\\\";\\n\\nlibrary VotingEscrowState {\\n    using VeERC2771Context for Storage;\\n\\n    struct Storage {\\n        /// @dev Address of Meta-tx Forwarder\\n        address trustedForwarder;\\n        /// @dev Address of FactoryRegistry.sol\\n        address factoryRegistry;\\n        /// @dev Address of token used to create a veNFT\\n        address token;\\n        /// @dev Address of RewardsDistributor.sol\\n        address distributor;\\n        /// @dev Address of Voter.sol\\n        address voter;\\n        /// @dev Address of Protocol Team multisig\\n        address team;\\n        /// @dev Address of art proxy used for on-chain art generation\\n        address artProxy;\\n        /// @dev Address which can create managed NFTs\\n        address allowedManager;\\n        /// @dev Global point history at a given index (epoch -> unsigned global point)\\n        mapping(uint256 => IVotingEscrow.GlobalPoint) _pointHistory;\\n        /// @dev Mapping of interface id to bool about whether or not it's supported\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        /// @dev Current count of token\\n        uint256 tokenId;\\n        /*///////////////////////////////////////////////////////////////\\n                                MANAGED NFT\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Mapping of token id to escrow type\\n        ///      Takes advantage of the fact default value is EscrowType.NORMAL\\n        mapping(uint256 => IVotingEscrow.EscrowType) escrowType;\\n        /// @dev Mapping of token id to managed id\\n        mapping(uint256 => uint256) idToManaged;\\n        /// @dev Mapping of user token id to managed token id to weight of token id\\n        mapping(uint256 => mapping(uint256 => uint256)) weights;\\n        /// @dev Mapping of managed id to deactivated state\\n        mapping(uint256 => bool) deactivated;\\n        /// @dev Mapping from managed nft id to locked managed rewards\\n        ///      `token` denominated rewards (rebases/rewards) stored in locked\\n        ///      managed rewards contract to prevent co-mingling of assets\\n        mapping(uint256 => address) managedToLocked;\\n        /// @dev Mapping from managed nft id to free managed rewards contract\\n        ///      these rewards can be freely withdrawn by users\\n        mapping(uint256 => address) managedToFree;\\n        /*//////////////////////////////////////////////////////////////\\n                            ERC721 BALANCE/OWNER\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Mapping from NFT ID to the address that owns it.\\n        mapping(uint256 => address) idToOwner;\\n        /// @dev Mapping from owner address to count of his tokens.\\n        mapping(address => uint256) ownerToNFTokenCount;\\n        /*//////////////////////////////////////////////////////////////\\n                                ERC721 APPROVAL\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Mapping from NFT ID to approved address.\\n        mapping(uint256 => address) idToApprovals;\\n        /// @dev Mapping from owner address to mapping of operator addresses.\\n        mapping(address => mapping(address => bool)) ownerToOperators;\\n        mapping(uint256 => uint256) ownershipChange;\\n        /*//////////////////////////////////////////////////////////////\\n                            INTERNAL MINT/BURN\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Mapping from owner address to mapping of index to tokenId\\n        mapping(address => mapping(uint256 => uint256)) ownerToNFTokenIdList;\\n        /// @dev Mapping from NFT ID to index of owner\\n        mapping(uint256 => uint256) tokenToOwnerIndex;\\n        /*//////////////////////////////////////////////////////////////\\n                                    ESCROW\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Total count of epochs witnessed since contract creation\\n        uint256 epoch;\\n        /// @dev Total amount of token() deposited\\n        uint256 supply;\\n        mapping(uint256 => IVotingEscrow.LockedBalance) _locked;\\n        mapping(uint256 => IVotingEscrow.UserPoint[1000000000]) _userPointHistory;\\n        mapping(uint256 => uint256) userPointEpoch;\\n        /// @dev time -> signed slope change\\n        mapping(uint256 => int128) slopeChanges;\\n        /// @dev account -> can split\\n        mapping(address => bool) canSplit;\\n        /// @dev Aggregate permanent locked balances\\n        uint256 permanentLockBalance;\\n        /*///////////////////////////////////////////////////////////////\\n                                    DAO VOTING\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev A record of each accounts delegate\\n        mapping(uint256 => uint256) _delegates;\\n        /// @dev A record of delegated token checkpoints for each tokenId, by index\\n        mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint)) _checkpoints;\\n        /// @dev The number of checkpoints for each tokenId\\n        mapping(uint256 => uint48) numCheckpoints;\\n        /// @dev A record of states for signing / validating signatures\\n        mapping(address => uint256) nonces;\\n        /*///////////////////////////////////////////////////////////////\\n                                GAUGE VOTING\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Information on whether a tokenId has already voted\\n        mapping(uint256 => bool) voted;\\n        // Reserved storage space in case we need to add more variables.\\n        // The convention from OpenZeppelin suggests the storage space should\\n        // add up to 50 slots. Here we want to have more slots as there are\\n        // planned upgrades of the VotingEscrow contract. If more entires are\\n        // added to the struct in the upcoming versions we need to reduce\\n        // the array size.\\n        // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n        uint256[50] __gap;\\n    }\\n\\n    function setTeam(\\n        VotingEscrowState.Storage storage self,\\n        address _team\\n    ) internal {\\n        if (self._msgSender() != self.team) revert IVotingEscrow.NotTeam();\\n        if (_team == address(0)) revert IVotingEscrow.ZeroAddress();\\n        self.team = _team;\\n    }\\n\\n    function setArtProxy(\\n        VotingEscrowState.Storage storage self,\\n        address _proxy\\n    ) internal {\\n        if (self._msgSender() != self.team) revert IVotingEscrow.NotTeam();\\n        self.artProxy = _proxy;\\n        emit IERC4906.BatchMetadataUpdate(0, type(uint256).max);\\n    }\\n\\n    function setVoterAndDistributor(\\n        VotingEscrowState.Storage storage self,\\n        address _voter,\\n        address _distributor\\n    ) internal {\\n        if (self._msgSender() != self.voter) revert IVotingEscrow.NotVoter();\\n        self.voter = _voter;\\n        self.distributor = _distributor;\\n    }\\n\\n    function setVoting(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        bool _voted\\n    ) internal {\\n        if (self._msgSender() != self.voter) revert IVotingEscrow.NotVoter();\\n        self.voted[_tokenId] = _voted;\\n    }\\n}\\n\",\"keccak256\":\"0x2779dbcc92093ce9bd9b258c166f9af0d24383116150f66f80d25223a028a1d3\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x612e0a61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100615760003560e01c80630a5b3e1914610066578063316617af14610088578063b7d7b69c146100ba578063d3e52da7146100da578063d9fe0002146100fa575b600080fd5b81801561007257600080fd5b506100866100813660046129ed565b61011a565b005b81801561009457600080fd5b506100a86100a33660046129ed565b610265565b60405190815260200160405180910390f35b8180156100c657600080fd5b506100866100d5366004612a1d565b61051f565b8180156100e657600080fd5b506100866100f5366004612a3f565b610924565b81801561010657600080fd5b50610086610115366004612a79565b610e2c565b6004808301546040805163030d028960e21b815290516001600160a01b0390921692630c340a249282820192602092908290030181865afa158015610163573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101879190612ab2565b6001600160a01b031661019983611007565b6001600160a01b0316146101c057604051633b8d9d7560e21b815260040160405180910390fd5b60078201546001600160a01b03908116908216036101f15760405163367558c360e01b815260040160405180910390fd5b6001600160a01b0381166102185760405163d92e233d60e01b815260040160405180910390fd5b6007820180546001600160a01b0319166001600160a01b0383169081179091556040517f1a6ce72407c68def4b7d2e724c896070d89cf2b2a2dd56b6897b5febd88420f590600090a25050565b60008061027184611007565b60078501549091506001600160a01b0380831691161480159061031257506004808501546040805163030d028960e21b815290516001600160a01b0390921692630c340a249282820192602092908290030181865afa1580156102d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102fc9190612ab2565b6001600160a01b0316816001600160a01b031614155b1561033057604051633bc1d15f60e01b815260040160405180910390fd5b83600a016000815461034190612ae5565b91829055509150610353848484611030565b506040805160608101825260008082526020820181905260019282018390526103839287928692918291906110a3565b6000828152600b850160209081526040808320805460ff19166002179055600187015481516301a15ccf60e31b8152915184936001600160a01b0390921692630d0ae6789260048083019391928290030181865afa1580156103e9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061040d9190612ab2565b865460048089015460405163dabc8e8360e01b81526001600160a01b03938416928101929092528216602482015291169063dabc8e839060440160408051808303816000875af1158015610465573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104899190612b14565b6000868152600f89016020908152604080832080546001600160a01b038781166001600160a01b0319928316811790935560108e018552948390208054878716921682179055825191825292810192909252939550919350858116928792918916917fae65a147ec014982132ce8b32019735e3c5f41457848d2ce2e2c3e0cbc9df7bc910160405180910390a450505092915050565b6000818152600c8301602052604090205460048301546001600160a01b031661054784611007565b6001600160a01b03161461056e5760405163c18384c160e01b815260040160405180910390fd5b8060000361058f5760405163d7caa26160e01b815260040160405180910390fd5b60016000838152600b8501602052604090205460ff1660028111156105b6576105b6612afe565b146105d457604051630fd82f7760e11b815260040160405180910390fd5b6000818152600f8401602090815260408083205460108701835281842054868552600d880184528285208686529093528184205460028801549251633e491d4760e01b81526001600160a01b0393841660048201526024810188905291831694929093169291908490633e491d4790604401602060405180830381865afa158015610663573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106879190612b43565b905060006106958284612b5c565b9050600062093a80806106ac630784ce0042612b5c565b6106b69190612b85565b6106c09190612b99565b604080516001808252818301909252919250600091906020808301908036833750505060028b015481519192506001600160a01b031690829060009061070857610708612bb0565b6001600160a01b03928316602091820292909201015260405163f5f8d36560e01b81529088169063f5f8d36590610745908c908590600401612bc6565b600060405180830381600087803b15801561075f57600080fd5b505af1158015610773573d6000803e3d6000fd5b505050506107838a8a8585611256565b61078e8a8985611326565b60405163278afc8b60e21b815260048101869052602481018a90526001600160a01b03881690639e2bf22c90604401600060405180830381600087803b1580156107d757600080fd5b505af11580156107eb573d6000803e3d6000fd5b505060405163278afc8b60e21b815260048101889052602481018c90526001600160a01b0389169250639e2bf22c9150604401600060405180830381600087803b15801561083857600080fd5b505af115801561084c573d6000803e3d6000fd5b50505060008a8152600c8c0160209081526040808320839055600d8e0182528083208c845282528083208390558c8352600b8e019091529020805460ff1916905550878961089a8c82611490565b6001600160a01b03167f5319474ec1e9d118585a40e615ea37be254007e6bb5b039756c3813c2d13548986426040516108dd929190918252602082015260400190565b60405180910390a46040518981527ff8e1a15aba9398e019f0b49df1a4fde98ee17ae345cb5f6b5e2c27f5033e8ce79060200160405180910390a150505050505050505050565b60048301546001600160a01b031661093b84611007565b6001600160a01b0316146109625760405163c18384c160e01b815260040160405180910390fd5b60026000828152600b8501602052604090205460ff16600281111561098957610989612afe565b146109a75760405163054b1e0160e51b815260040160405180910390fd5b6000828152600b8401602052604081205460ff1660028111156109cc576109cc612afe565b146109ea576040516317a66f3760e01b815260040160405180910390fd5b6109f58383426114b1565b600003610a155760405163334ab3f560e11b815260040160405180910390fd5b6000828152601a8401602052604090208054600290910154600f9190910b9060ff1615610a6d57610a4881600f0b6115c3565b84601f016000828254610a5b9190612c1f565b90915550610a6d9050848460006115ef565b6000838152601a8501602090815260408083208151606080820184528254600f0b825260018301548286015260029092015460ff161515818401528251918201835284825292810184905290810192909252610acc9186918691611764565b6040805160608101825260008082526020808301828152838501838152888452601a8a01909252938220925183546001600160801b0319166001600160801b039091161783559251600183015591516002909101805460ff1916911515919091179055610b3c600f83900b6115c3565b90508085601f016000828254610b529190612b5c565b90915550506000838152601a8601602090815260409182902082516060810184528154600f0b80825260018301549382019390935260029091015460ff1615159281019290925283908290610ba8908390612c32565b600f0b9052506000848152602080880190526040902054610bcd908790846001611de1565b6000848152601a8701602090815260409182902082516060810184528154600f0b81526001820154928101929092526002015460ff16151591810191909152610c1a908790869084611764565b6000848152601a870160209081526040808320845181546001600160801b0319166001600160801b0390911617815584830151600180830191909155858301516002909201805460ff19908116931515939093179055898552600d8b0184528285208986528452828520879055898552600c8b018452828520899055600b8b0184528285208054909216179055868352600f89019091529081902054905163f320772360e01b815260048101849052602481018790526001600160a01b0390911690819063f320772390604401600060405180830381600087803b158015610d0157600080fd5b505af1158015610d15573d6000803e3d6000fd5b50505060008681526010890160205260409081902054905163f320772360e01b815260048101869052602481018990526001600160a01b039091169150819063f320772390604401600060405180830381600087803b158015610d7757600080fd5b505af1158015610d8b573d6000803e3d6000fd5b505050508587610da4898b61149090919063ffffffff16565b6001600160a01b03167ff7757ce35992f4ee014dee2e0c97ed6245758960a6ecc9e124897a5fb7b014238742604051610de7929190918252602082015260400190565b60405180910390a46040518781527ff8e1a15aba9398e019f0b49df1a4fde98ee17ae345cb5f6b5e2c27f5033e8ce79060200160405180910390a15050505050505050565b60048084015460408051633bbc4b0760e11b815290516001600160a01b0390921692637778960e9282820192602092908290030181865afa158015610e75573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e999190612ab2565b6001600160a01b0316610eab84611007565b6001600160a01b031614158015610f4857506004808401546040805163030d028960e21b815290516001600160a01b0390921692630c340a249282820192602092908290030181865afa158015610f06573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f2a9190612ab2565b6001600160a01b0316610f3c84611007565b6001600160a01b031614155b15610f665760405163459d6a3f60e01b815260040160405180910390fd5b60026000838152600b8501602052604090205460ff166002811115610f8d57610f8d612afe565b14610fab5760405163054b1e0160e51b815260040160405180910390fd5b6000828152600e8401602052604090205481151560ff909116151503610fe457604051631490ad1160e01b815260040160405180910390fd5b6000918252600e9290920160205260409020805460ff1916911515919091179055565b80546000906001600160a01b0316330361102957505036601319013560601c90565b5033919050565b60006001600160a01b03831661104857611048612c5f565b61105384848461200c565b61106084836000866120b1565b60405182906001600160a01b038516906000907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a45060015b9392505050565b60198601546110b28582612b5c565b60198801556040805160608101825260008082526020808301828152838501928352875191880151948801511515909252929052600f9190910b81526110f786612330565b81518290611106908390612c32565b600f0b905250841561111a57602081018590525b6000878152601a89016020908152604091829020835181546001600160801b0319166001600160801b03909116178155908301516001820155908201516002909101805460ff191691151591909117905561117788888684611764565b600061118289611007565b905086156111a45760028901546111a4906001600160a01b031682308a61235e565b8360038111156111b6576111b6612afe565b602083810151604080518b8152928301919091524282820152518a916001600160a01b038516917f8835c22a0c751188de86681e15904223c054bedd5c68ec8858945b78312902739181900360600190a47f5e2aa66efd74cce82b21852e317e5490d9ecc9e6bb953ae24d90851258cc2f5c836112338982612b5c565b6040805192835260208301919091520160405180910390a1505050505050505050565b6000604051806060016040528061126c85612330565b600f90810b8252602080830186905260006040938401819052888152601a8a0182528390208351606081018552815490930b83526001810154918301919091526002015460ff161515918101919091529091506112cd908690869084611764565b6000938452601a949094016020908152604093849020855181546001600160801b0319166001600160801b0390911617815590850151600182015592909301516002909201805460ff1916921515929092179091555050565b6000828152601a8401602090815260409182902082516060810184528154600f0b80825260018301549382019390935260029091015460ff1615159281019290925261137183612330565b600f0b12611380578051611389565b61138982612330565b81518290611398908390612c75565b600f0b905250601f84015482106113b35783601f01546113b5565b815b84601f0160008282546113c89190612c1f565b909155505060008381526020808601905260408120546113ec918691908590611de1565b6000838152601a8501602090815260409182902082516060810184528154600f0b81526001820154928101929092526002015460ff16151591810191909152611439908590859084611764565b6000928352601a939093016020908152604092839020845181546001600160801b0319166001600160801b0390911617815590840151600182015591909201516002909101805460ff191691151591909117905550565b60008181526011830160205260409020546001600160a01b03165b92915050565b6000806114bf8585856123b8565b9050806000036114d357600091505061109c565b6000848152601b86016020526040812082633b9aca0081106114f7576114f7612bb0565b6040805160a081018252600492909202929092018054600f81810b8452600160801b909104900b602083015260018101549282019290925260028201546060820152600390910154608082018190529091501561155b5760800151915061109c9050565b61157381604001518561156e9190612c1f565b612330565b81602001516115829190612ca2565b81518290611591908390612c75565b600f90810b90915282516000910b121590506115ac57600081525b80516115ba90600f0b6115c3565b9250505061109c565b60008082600f0b12156115e85760405162406f5d60e21b815260040160405180910390fd5b50600f0b90565b6000828152601a8401602090815260409182902082516060810184528154600f0b81526001820154928101929092526002015460ff1615159181018290529061164b57604051632188f8ab60e01b815260040160405180910390fd5b811580159061166c575060006116618584611490565b6001600160a01b0316145b1561168a57604051634a1850bf60e11b815260040160405180910390fd5b60008381526015850160205260409020544390036116bb576040516342d6fce760e01b815260040160405180910390fd5b8282036116c757600091505b60008381526020808601905260409020548281036116e6575050505050565b60006116f88360000151600f0b6115c3565b905061170f86868661170a8383611490565b6120b1565b61171c8685836001611de1565b838261172788611007565b6001600160a01b03167ff1aa2a9e40138176a3ee6099df056f5c175f8511a0d8b8275d94d1ea5de4677360405160405180910390a4505050505050565b61176c6129a0565b6117746129a0565b6018860154600090819087156118c85785604001516117945760006117a2565b85516117a290600f0b6115c3565b60808501526020870151421080156117c1575060008760000151600f0b135b1561180a5786516117d790630784ce0090612cc2565b600f0b6020808701919091528701516117f59061156e904290612c1f565b85602001516118049190612ca2565b600f0b85525b428660200151118015611824575060008660000151600f0b135b1561186d57855161183a90630784ce0090612cc2565b600f0b6020808601919091528601516118589061156e904290612c1f565b84602001516118679190612ca2565b600f0b84525b6020808801516000908152601d8b018252604090205490870151600f9190910b9350156118c85786602001518660200151036118ab578291506118c8565b6020808701516000908152601d8b019091526040902054600f0b91505b6040805160a0810182526000808252602082018190524292820192909252436060820152608081019190915281156119535750600081815260088a016020908152604091829020825160a0810184528154600f81810b8352600160801b909104900b928101929092526001810154928201929092526002820154606082015260039091015460808201525b60008160400151905060006040518060a001604052808460000151600f0b81526020018460200151600f0b8152602001846040015181526020018460600151815260200184608001518152509050600083604001514211156119ec5760408401516119be9042612c1f565b60608501516119cd9043612c1f565b6119df90670de0b6b3a7640000612b99565b6119e99190612b85565b90505b6119fa8d86868686866124df565b90955093508b15611a8e5788602001518860200151611a199190612c75565b84602001818151611a2a9190612c32565b600f0b90525088518851611a3e9190612c75565b84518590611a4d908390612c32565b600f90810b90915260208601516000910b12159050611a6e57600060208501525b60008460000151600f0b1215611a8357600084525b601f8d015460808501525b84600114158015611ac057504260088e016000611aac600189612c1f565b815260200190815260200160002060010154145b15611b2c578360088e016000611ad7600189612c1f565b815260208082019290925260409081016000208351928401516001600160801b03908116600160801b029316929092178255820151600182015560608201516002820155608090910151600390910155611b85565b60188d01859055600085815260088e0160209081526040918290208651918701516001600160801b03908116600160801b0292169190911781559085015160018201556060850151600282015560808501516003909101555b8b15611dd257428b602001511115611bf9576020890151611ba69088612c32565b96508a602001518a6020015103611bc9576020880151611bc69088612c75565b96505b60208b8101516000908152601d8f019091526040902080546001600160801b0319166001600160801b0389161790555b428a602001511115611c68578a602001518a602001511115611c68576020880151611c249087612c75565b9550858d601d0160008c60200151815260200190815260200160002060006101000a8154816001600160801b030219169083600f0b6001600160801b031602179055505b426040808a01919091524360608a015260008d8152601c8f0160205220548015801590611cc0575060008d8152601b8f0160205260409020429082633b9aca008110611cb657611cb6612bb0565b6004020160010154145b15611d385760008d8152601b8f0160205260409020899082633b9aca008110611ceb57611ceb612bb0565b825160208401516001600160801b03908116600160801b02911617600491909102919091019081556040820151600182015560608201516002820155608090910151600390910155611dd0565b611d4181612ae5565b9050808e601c0160008f815260200190815260200160002081905550888e601b0160008f815260200190815260200160002082633b9aca008110611d8757611d87612bb0565b825160208401516001600160801b03908116600160801b029116176004919091029190910190815560408201516001820155606082015160028201556080909101516003909101555b505b50505050505050505050505050565b821561200657600083815260228501602052604081205465ffffffffffff169081611e2657600085815260218701602090815260408083208380529091529020611e61565b6000858152602187016020526040812090611e42600185612d00565b65ffffffffffff1665ffffffffffff1681526020019081526020016000205b6000868152602188016020908152604080832065ffffffffffff87168452909152902042815560018083015490820180546001600160a01b0319166001600160a01b0390921691909117905590915083611edc5781600201548510611ec7576000611eec565b848260020154611ed79190612c1f565b611eec565b848260020154611eec9190612b5c565b600282015560038083015490820155611f0587876126b6565b15611f565760008681526022880160205260408120805465ffffffffffff1691611f2e83612d1f565b91906101000a81548165ffffffffffff021916908365ffffffffffff16021790555050612002565b600086815260218801602052604081208291611f73600187612d00565b65ffffffffffff9081168252602080830193909352604091820160009081208554815560018087015481830180546001600160a01b039092166001600160a01b031992831617905560028089015481850155600398890154938901939093558d845260218f018752858420948b1684529390955292812081815593840180549092169091559082018190559101555b5050505b50505050565b60006120188483611490565b6001600160a01b03161461202e5761202e612c5f565b6000818152601184016020908152604080832080546001600160a01b0319166001600160a01b03871690811790915580845260128701808452828520805460168a018652848720818852865284872088905587875260178a018652938620939093559084529091528054600192906120a7908490612b5c565b9091555050505050565b6000838152601a850160205260408120546120ce90600f0b6115c3565b600085815260228701602052604081205491925065ffffffffffff90911690816121125760008681526021880160209081526040808320838052909152902061214d565b600086815260218801602052604081209061212e600185612d00565b65ffffffffffff1665ffffffffffff1681526020019081526020016000205b9050612160878260030154856000611de1565b6000868152602188016020908152604080832065ffffffffffff86168452909152902042815560028281015490820155600381018690556001810180546001600160a01b0319166001600160a01b0387161790556121be88886126b6565b1561220f5760008781526022890160205260408120805465ffffffffffff16916121e783612d1f565b91906101000a81548165ffffffffffff021916908365ffffffffffff16021790555050612317565b60008781526021890160205260408120829161222c600187612d00565b65ffffffffffff1665ffffffffffff168152602001908152602001600020600082015481600001556001820160009054906101000a90046001600160a01b03168160010160006101000a8154816001600160a01b0302191690836001600160a01b03160217905550600282015481600201556003820154816003015590505087602101600088815260200190815260200160002060008465ffffffffffff1665ffffffffffff1681526020019081526020016000206000808201600090556001820160006101000a8154906001600160a01b0302191690556002820160009055600382016000905550505b5050506000938452505060209283019092526040902055565b600060016001607f1b0382111561235a576040516393dafdf160e01b815260040160405180910390fd5b5090565b604080516001600160a01b0385811660248301528416604482015260648082018490528251808303909101815260849091019091526020810180516001600160e01b03166323b872dd60e01b179052612006908590612731565b6000828152601c840160205260408120548082036123da57600091505061109c565b6000848152601b860160205260409020839082633b9aca00811061240057612400612bb0565b60040201600101541161241457905061109c565b6000848152601b8601602052604090206005015483101561243957600091505061109c565b6000815b818111156124d557600060026124538484612c1f565b61245d9190612b85565b6124679083612c1f565b6000888152601b8a01602052604081209192509082633b9aca00811061248f5761248f612bb0565b600402019050868160010154036124ac5750935061109c92505050565b86816001015410156124c0578193506124ce565b6124cb600183612c1f565b92505b505061243d565b5095945050505050565b6040805160a0810182526000808252602082018190529181018290526060810182905260808101829052600062093a806125198188612b85565b6125239190612b99565b905060005b60ff8110156126a65761253e62093a8083612b5c565b915060004283111561255257429250612568565b506000828152601d8b016020526040902054600f0b5b61257561156e8985612c1f565b89602001516125849190612ca2565b89518a90612593908390612c75565b600f0b9052506020890180518291906125ad908390612c32565b600f90810b9091528a516000910b121590506125c857600089525b60008960200151600f0b12156125e057600060208a01525b6040808a018490528701519297508792670de0b6b3a7640000906126049085612c1f565b61260e9088612b99565b6126189190612b85565b87606001516126279190612b5c565b60608a015261263760018b612b5c565b995042830361264c57504360608901526126a6565b60008a815260088c0160209081526040918290208b51918c01516001600160801b03908116600160801b029216919091178155908a0151600182015560608a0151600282015560808a015160039091015550600101612528565b5096989597509495505050505050565b600081815260228301602052604081205465ffffffffffff16801580159061271157506000838152602185016020526040812042916126f6600185612d00565b65ffffffffffff168152602081019190915260400160002054145b156127205760009150506114ab565b60019150506114ab565b5092915050565b6000612786826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166128109092919063ffffffff16565b90508051600014806127a75750808060200190518101906127a79190612d44565b61280b5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084015b60405180910390fd5b505050565b606061281f8484600085612827565b949350505050565b6060824710156128885760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401612802565b600080866001600160a01b031685876040516128a49190612d85565b60006040518083038185875af1925050503d80600081146128e1576040519150601f19603f3d011682016040523d82523d6000602084013e6128e6565b606091505b50915091506128f787838387612902565b979650505050505050565b6060831561297157825160000361296a576001600160a01b0385163b61296a5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401612802565b508161281f565b61281f83838151156129865781518083602001fd5b8060405162461bcd60e51b81526004016128029190612da1565b6040518060a001604052806000600f0b81526020016000600f0b81526020016000815260200160008152602001600081525090565b6001600160a01b03811681146129ea57600080fd5b50565b60008060408385031215612a0057600080fd5b823591506020830135612a12816129d5565b809150509250929050565b60008060408385031215612a3057600080fd5b50508035926020909101359150565b600080600060608486031215612a5457600080fd5b505081359360208301359350604090920135919050565b80151581146129ea57600080fd5b600080600060608486031215612a8e57600080fd5b83359250602084013591506040840135612aa781612a6b565b809150509250925092565b600060208284031215612ac457600080fd5b815161109c816129d5565b634e487b7160e01b600052601160045260246000fd5b600060018201612af757612af7612acf565b5060010190565b634e487b7160e01b600052602160045260246000fd5b60008060408385031215612b2757600080fd5b8251612b32816129d5565b6020840151909250612a12816129d5565b600060208284031215612b5557600080fd5b5051919050565b808201808211156114ab576114ab612acf565b634e487b7160e01b600052601260045260246000fd5b600082612b9457612b94612b6f565b500490565b80820281158282048414176114ab576114ab612acf565b634e487b7160e01b600052603260045260246000fd5b60006040820184835260206040602085015281855180845260608601915060208701935060005b81811015612c125784516001600160a01b031683529383019391830191600101612bed565b5090979650505050505050565b818103818111156114ab576114ab612acf565b600f81810b9083900b0160016001607f1b03811360016001607f1b0319821217156114ab576114ab612acf565b634e487b7160e01b600052600160045260246000fd5b600f82810b9082900b0360016001607f1b0319811260016001607f1b03821317156114ab576114ab612acf565b600082600f0b82600f0b0280600f0b915080821461272a5761272a612acf565b600081600f0b83600f0b80612cd957612cd9612b6f565b60016001607f1b0319821460001982141615612cf757612cf7612acf565b90059392505050565b65ffffffffffff82811682821603908082111561272a5761272a612acf565b600065ffffffffffff808316818103612d3a57612d3a612acf565b6001019392505050565b600060208284031215612d5657600080fd5b815161109c81612a6b565b60005b83811015612d7c578181015183820152602001612d64565b50506000910152565b60008251612d97818460208701612d61565b9190910192915050565b6020815260008251806020840152612dc0816040850160208701612d61565b601f01601f1916919091016040019291505056fea2646970667358221220db3c04c5a09cd167cafec570dc99c34fa99eb3d429d1b178ea01d07cb5a2f3ba64736f6c63430008180033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100615760003560e01c80630a5b3e1914610066578063316617af14610088578063b7d7b69c146100ba578063d3e52da7146100da578063d9fe0002146100fa575b600080fd5b81801561007257600080fd5b506100866100813660046129ed565b61011a565b005b81801561009457600080fd5b506100a86100a33660046129ed565b610265565b60405190815260200160405180910390f35b8180156100c657600080fd5b506100866100d5366004612a1d565b61051f565b8180156100e657600080fd5b506100866100f5366004612a3f565b610924565b81801561010657600080fd5b50610086610115366004612a79565b610e2c565b6004808301546040805163030d028960e21b815290516001600160a01b0390921692630c340a249282820192602092908290030181865afa158015610163573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101879190612ab2565b6001600160a01b031661019983611007565b6001600160a01b0316146101c057604051633b8d9d7560e21b815260040160405180910390fd5b60078201546001600160a01b03908116908216036101f15760405163367558c360e01b815260040160405180910390fd5b6001600160a01b0381166102185760405163d92e233d60e01b815260040160405180910390fd5b6007820180546001600160a01b0319166001600160a01b0383169081179091556040517f1a6ce72407c68def4b7d2e724c896070d89cf2b2a2dd56b6897b5febd88420f590600090a25050565b60008061027184611007565b60078501549091506001600160a01b0380831691161480159061031257506004808501546040805163030d028960e21b815290516001600160a01b0390921692630c340a249282820192602092908290030181865afa1580156102d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102fc9190612ab2565b6001600160a01b0316816001600160a01b031614155b1561033057604051633bc1d15f60e01b815260040160405180910390fd5b83600a016000815461034190612ae5565b91829055509150610353848484611030565b506040805160608101825260008082526020820181905260019282018390526103839287928692918291906110a3565b6000828152600b850160209081526040808320805460ff19166002179055600187015481516301a15ccf60e31b8152915184936001600160a01b0390921692630d0ae6789260048083019391928290030181865afa1580156103e9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061040d9190612ab2565b865460048089015460405163dabc8e8360e01b81526001600160a01b03938416928101929092528216602482015291169063dabc8e839060440160408051808303816000875af1158015610465573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104899190612b14565b6000868152600f89016020908152604080832080546001600160a01b038781166001600160a01b0319928316811790935560108e018552948390208054878716921682179055825191825292810192909252939550919350858116928792918916917fae65a147ec014982132ce8b32019735e3c5f41457848d2ce2e2c3e0cbc9df7bc910160405180910390a450505092915050565b6000818152600c8301602052604090205460048301546001600160a01b031661054784611007565b6001600160a01b03161461056e5760405163c18384c160e01b815260040160405180910390fd5b8060000361058f5760405163d7caa26160e01b815260040160405180910390fd5b60016000838152600b8501602052604090205460ff1660028111156105b6576105b6612afe565b146105d457604051630fd82f7760e11b815260040160405180910390fd5b6000818152600f8401602090815260408083205460108701835281842054868552600d880184528285208686529093528184205460028801549251633e491d4760e01b81526001600160a01b0393841660048201526024810188905291831694929093169291908490633e491d4790604401602060405180830381865afa158015610663573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106879190612b43565b905060006106958284612b5c565b9050600062093a80806106ac630784ce0042612b5c565b6106b69190612b85565b6106c09190612b99565b604080516001808252818301909252919250600091906020808301908036833750505060028b015481519192506001600160a01b031690829060009061070857610708612bb0565b6001600160a01b03928316602091820292909201015260405163f5f8d36560e01b81529088169063f5f8d36590610745908c908590600401612bc6565b600060405180830381600087803b15801561075f57600080fd5b505af1158015610773573d6000803e3d6000fd5b505050506107838a8a8585611256565b61078e8a8985611326565b60405163278afc8b60e21b815260048101869052602481018a90526001600160a01b03881690639e2bf22c90604401600060405180830381600087803b1580156107d757600080fd5b505af11580156107eb573d6000803e3d6000fd5b505060405163278afc8b60e21b815260048101889052602481018c90526001600160a01b0389169250639e2bf22c9150604401600060405180830381600087803b15801561083857600080fd5b505af115801561084c573d6000803e3d6000fd5b50505060008a8152600c8c0160209081526040808320839055600d8e0182528083208c845282528083208390558c8352600b8e019091529020805460ff1916905550878961089a8c82611490565b6001600160a01b03167f5319474ec1e9d118585a40e615ea37be254007e6bb5b039756c3813c2d13548986426040516108dd929190918252602082015260400190565b60405180910390a46040518981527ff8e1a15aba9398e019f0b49df1a4fde98ee17ae345cb5f6b5e2c27f5033e8ce79060200160405180910390a150505050505050505050565b60048301546001600160a01b031661093b84611007565b6001600160a01b0316146109625760405163c18384c160e01b815260040160405180910390fd5b60026000828152600b8501602052604090205460ff16600281111561098957610989612afe565b146109a75760405163054b1e0160e51b815260040160405180910390fd5b6000828152600b8401602052604081205460ff1660028111156109cc576109cc612afe565b146109ea576040516317a66f3760e01b815260040160405180910390fd5b6109f58383426114b1565b600003610a155760405163334ab3f560e11b815260040160405180910390fd5b6000828152601a8401602052604090208054600290910154600f9190910b9060ff1615610a6d57610a4881600f0b6115c3565b84601f016000828254610a5b9190612c1f565b90915550610a6d9050848460006115ef565b6000838152601a8501602090815260408083208151606080820184528254600f0b825260018301548286015260029092015460ff161515818401528251918201835284825292810184905290810192909252610acc9186918691611764565b6040805160608101825260008082526020808301828152838501838152888452601a8a01909252938220925183546001600160801b0319166001600160801b039091161783559251600183015591516002909101805460ff1916911515919091179055610b3c600f83900b6115c3565b90508085601f016000828254610b529190612b5c565b90915550506000838152601a8601602090815260409182902082516060810184528154600f0b80825260018301549382019390935260029091015460ff1615159281019290925283908290610ba8908390612c32565b600f0b9052506000848152602080880190526040902054610bcd908790846001611de1565b6000848152601a8701602090815260409182902082516060810184528154600f0b81526001820154928101929092526002015460ff16151591810191909152610c1a908790869084611764565b6000848152601a870160209081526040808320845181546001600160801b0319166001600160801b0390911617815584830151600180830191909155858301516002909201805460ff19908116931515939093179055898552600d8b0184528285208986528452828520879055898552600c8b018452828520899055600b8b0184528285208054909216179055868352600f89019091529081902054905163f320772360e01b815260048101849052602481018790526001600160a01b0390911690819063f320772390604401600060405180830381600087803b158015610d0157600080fd5b505af1158015610d15573d6000803e3d6000fd5b50505060008681526010890160205260409081902054905163f320772360e01b815260048101869052602481018990526001600160a01b039091169150819063f320772390604401600060405180830381600087803b158015610d7757600080fd5b505af1158015610d8b573d6000803e3d6000fd5b505050508587610da4898b61149090919063ffffffff16565b6001600160a01b03167ff7757ce35992f4ee014dee2e0c97ed6245758960a6ecc9e124897a5fb7b014238742604051610de7929190918252602082015260400190565b60405180910390a46040518781527ff8e1a15aba9398e019f0b49df1a4fde98ee17ae345cb5f6b5e2c27f5033e8ce79060200160405180910390a15050505050505050565b60048084015460408051633bbc4b0760e11b815290516001600160a01b0390921692637778960e9282820192602092908290030181865afa158015610e75573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e999190612ab2565b6001600160a01b0316610eab84611007565b6001600160a01b031614158015610f4857506004808401546040805163030d028960e21b815290516001600160a01b0390921692630c340a249282820192602092908290030181865afa158015610f06573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f2a9190612ab2565b6001600160a01b0316610f3c84611007565b6001600160a01b031614155b15610f665760405163459d6a3f60e01b815260040160405180910390fd5b60026000838152600b8501602052604090205460ff166002811115610f8d57610f8d612afe565b14610fab5760405163054b1e0160e51b815260040160405180910390fd5b6000828152600e8401602052604090205481151560ff909116151503610fe457604051631490ad1160e01b815260040160405180910390fd5b6000918252600e9290920160205260409020805460ff1916911515919091179055565b80546000906001600160a01b0316330361102957505036601319013560601c90565b5033919050565b60006001600160a01b03831661104857611048612c5f565b61105384848461200c565b61106084836000866120b1565b60405182906001600160a01b038516906000907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a45060015b9392505050565b60198601546110b28582612b5c565b60198801556040805160608101825260008082526020808301828152838501928352875191880151948801511515909252929052600f9190910b81526110f786612330565b81518290611106908390612c32565b600f0b905250841561111a57602081018590525b6000878152601a89016020908152604091829020835181546001600160801b0319166001600160801b03909116178155908301516001820155908201516002909101805460ff191691151591909117905561117788888684611764565b600061118289611007565b905086156111a45760028901546111a4906001600160a01b031682308a61235e565b8360038111156111b6576111b6612afe565b602083810151604080518b8152928301919091524282820152518a916001600160a01b038516917f8835c22a0c751188de86681e15904223c054bedd5c68ec8858945b78312902739181900360600190a47f5e2aa66efd74cce82b21852e317e5490d9ecc9e6bb953ae24d90851258cc2f5c836112338982612b5c565b6040805192835260208301919091520160405180910390a1505050505050505050565b6000604051806060016040528061126c85612330565b600f90810b8252602080830186905260006040938401819052888152601a8a0182528390208351606081018552815490930b83526001810154918301919091526002015460ff161515918101919091529091506112cd908690869084611764565b6000938452601a949094016020908152604093849020855181546001600160801b0319166001600160801b0390911617815590850151600182015592909301516002909201805460ff1916921515929092179091555050565b6000828152601a8401602090815260409182902082516060810184528154600f0b80825260018301549382019390935260029091015460ff1615159281019290925261137183612330565b600f0b12611380578051611389565b61138982612330565b81518290611398908390612c75565b600f0b905250601f84015482106113b35783601f01546113b5565b815b84601f0160008282546113c89190612c1f565b909155505060008381526020808601905260408120546113ec918691908590611de1565b6000838152601a8501602090815260409182902082516060810184528154600f0b81526001820154928101929092526002015460ff16151591810191909152611439908590859084611764565b6000928352601a939093016020908152604092839020845181546001600160801b0319166001600160801b0390911617815590840151600182015591909201516002909101805460ff191691151591909117905550565b60008181526011830160205260409020546001600160a01b03165b92915050565b6000806114bf8585856123b8565b9050806000036114d357600091505061109c565b6000848152601b86016020526040812082633b9aca0081106114f7576114f7612bb0565b6040805160a081018252600492909202929092018054600f81810b8452600160801b909104900b602083015260018101549282019290925260028201546060820152600390910154608082018190529091501561155b5760800151915061109c9050565b61157381604001518561156e9190612c1f565b612330565b81602001516115829190612ca2565b81518290611591908390612c75565b600f90810b90915282516000910b121590506115ac57600081525b80516115ba90600f0b6115c3565b9250505061109c565b60008082600f0b12156115e85760405162406f5d60e21b815260040160405180910390fd5b50600f0b90565b6000828152601a8401602090815260409182902082516060810184528154600f0b81526001820154928101929092526002015460ff1615159181018290529061164b57604051632188f8ab60e01b815260040160405180910390fd5b811580159061166c575060006116618584611490565b6001600160a01b0316145b1561168a57604051634a1850bf60e11b815260040160405180910390fd5b60008381526015850160205260409020544390036116bb576040516342d6fce760e01b815260040160405180910390fd5b8282036116c757600091505b60008381526020808601905260409020548281036116e6575050505050565b60006116f88360000151600f0b6115c3565b905061170f86868661170a8383611490565b6120b1565b61171c8685836001611de1565b838261172788611007565b6001600160a01b03167ff1aa2a9e40138176a3ee6099df056f5c175f8511a0d8b8275d94d1ea5de4677360405160405180910390a4505050505050565b61176c6129a0565b6117746129a0565b6018860154600090819087156118c85785604001516117945760006117a2565b85516117a290600f0b6115c3565b60808501526020870151421080156117c1575060008760000151600f0b135b1561180a5786516117d790630784ce0090612cc2565b600f0b6020808701919091528701516117f59061156e904290612c1f565b85602001516118049190612ca2565b600f0b85525b428660200151118015611824575060008660000151600f0b135b1561186d57855161183a90630784ce0090612cc2565b600f0b6020808601919091528601516118589061156e904290612c1f565b84602001516118679190612ca2565b600f0b84525b6020808801516000908152601d8b018252604090205490870151600f9190910b9350156118c85786602001518660200151036118ab578291506118c8565b6020808701516000908152601d8b019091526040902054600f0b91505b6040805160a0810182526000808252602082018190524292820192909252436060820152608081019190915281156119535750600081815260088a016020908152604091829020825160a0810184528154600f81810b8352600160801b909104900b928101929092526001810154928201929092526002820154606082015260039091015460808201525b60008160400151905060006040518060a001604052808460000151600f0b81526020018460200151600f0b8152602001846040015181526020018460600151815260200184608001518152509050600083604001514211156119ec5760408401516119be9042612c1f565b60608501516119cd9043612c1f565b6119df90670de0b6b3a7640000612b99565b6119e99190612b85565b90505b6119fa8d86868686866124df565b90955093508b15611a8e5788602001518860200151611a199190612c75565b84602001818151611a2a9190612c32565b600f0b90525088518851611a3e9190612c75565b84518590611a4d908390612c32565b600f90810b90915260208601516000910b12159050611a6e57600060208501525b60008460000151600f0b1215611a8357600084525b601f8d015460808501525b84600114158015611ac057504260088e016000611aac600189612c1f565b815260200190815260200160002060010154145b15611b2c578360088e016000611ad7600189612c1f565b815260208082019290925260409081016000208351928401516001600160801b03908116600160801b029316929092178255820151600182015560608201516002820155608090910151600390910155611b85565b60188d01859055600085815260088e0160209081526040918290208651918701516001600160801b03908116600160801b0292169190911781559085015160018201556060850151600282015560808501516003909101555b8b15611dd257428b602001511115611bf9576020890151611ba69088612c32565b96508a602001518a6020015103611bc9576020880151611bc69088612c75565b96505b60208b8101516000908152601d8f019091526040902080546001600160801b0319166001600160801b0389161790555b428a602001511115611c68578a602001518a602001511115611c68576020880151611c249087612c75565b9550858d601d0160008c60200151815260200190815260200160002060006101000a8154816001600160801b030219169083600f0b6001600160801b031602179055505b426040808a01919091524360608a015260008d8152601c8f0160205220548015801590611cc0575060008d8152601b8f0160205260409020429082633b9aca008110611cb657611cb6612bb0565b6004020160010154145b15611d385760008d8152601b8f0160205260409020899082633b9aca008110611ceb57611ceb612bb0565b825160208401516001600160801b03908116600160801b02911617600491909102919091019081556040820151600182015560608201516002820155608090910151600390910155611dd0565b611d4181612ae5565b9050808e601c0160008f815260200190815260200160002081905550888e601b0160008f815260200190815260200160002082633b9aca008110611d8757611d87612bb0565b825160208401516001600160801b03908116600160801b029116176004919091029190910190815560408201516001820155606082015160028201556080909101516003909101555b505b50505050505050505050505050565b821561200657600083815260228501602052604081205465ffffffffffff169081611e2657600085815260218701602090815260408083208380529091529020611e61565b6000858152602187016020526040812090611e42600185612d00565b65ffffffffffff1665ffffffffffff1681526020019081526020016000205b6000868152602188016020908152604080832065ffffffffffff87168452909152902042815560018083015490820180546001600160a01b0319166001600160a01b0390921691909117905590915083611edc5781600201548510611ec7576000611eec565b848260020154611ed79190612c1f565b611eec565b848260020154611eec9190612b5c565b600282015560038083015490820155611f0587876126b6565b15611f565760008681526022880160205260408120805465ffffffffffff1691611f2e83612d1f565b91906101000a81548165ffffffffffff021916908365ffffffffffff16021790555050612002565b600086815260218801602052604081208291611f73600187612d00565b65ffffffffffff9081168252602080830193909352604091820160009081208554815560018087015481830180546001600160a01b039092166001600160a01b031992831617905560028089015481850155600398890154938901939093558d845260218f018752858420948b1684529390955292812081815593840180549092169091559082018190559101555b5050505b50505050565b60006120188483611490565b6001600160a01b03161461202e5761202e612c5f565b6000818152601184016020908152604080832080546001600160a01b0319166001600160a01b03871690811790915580845260128701808452828520805460168a018652848720818852865284872088905587875260178a018652938620939093559084529091528054600192906120a7908490612b5c565b9091555050505050565b6000838152601a850160205260408120546120ce90600f0b6115c3565b600085815260228701602052604081205491925065ffffffffffff90911690816121125760008681526021880160209081526040808320838052909152902061214d565b600086815260218801602052604081209061212e600185612d00565b65ffffffffffff1665ffffffffffff1681526020019081526020016000205b9050612160878260030154856000611de1565b6000868152602188016020908152604080832065ffffffffffff86168452909152902042815560028281015490820155600381018690556001810180546001600160a01b0319166001600160a01b0387161790556121be88886126b6565b1561220f5760008781526022890160205260408120805465ffffffffffff16916121e783612d1f565b91906101000a81548165ffffffffffff021916908365ffffffffffff16021790555050612317565b60008781526021890160205260408120829161222c600187612d00565b65ffffffffffff1665ffffffffffff168152602001908152602001600020600082015481600001556001820160009054906101000a90046001600160a01b03168160010160006101000a8154816001600160a01b0302191690836001600160a01b03160217905550600282015481600201556003820154816003015590505087602101600088815260200190815260200160002060008465ffffffffffff1665ffffffffffff1681526020019081526020016000206000808201600090556001820160006101000a8154906001600160a01b0302191690556002820160009055600382016000905550505b5050506000938452505060209283019092526040902055565b600060016001607f1b0382111561235a576040516393dafdf160e01b815260040160405180910390fd5b5090565b604080516001600160a01b0385811660248301528416604482015260648082018490528251808303909101815260849091019091526020810180516001600160e01b03166323b872dd60e01b179052612006908590612731565b6000828152601c840160205260408120548082036123da57600091505061109c565b6000848152601b860160205260409020839082633b9aca00811061240057612400612bb0565b60040201600101541161241457905061109c565b6000848152601b8601602052604090206005015483101561243957600091505061109c565b6000815b818111156124d557600060026124538484612c1f565b61245d9190612b85565b6124679083612c1f565b6000888152601b8a01602052604081209192509082633b9aca00811061248f5761248f612bb0565b600402019050868160010154036124ac5750935061109c92505050565b86816001015410156124c0578193506124ce565b6124cb600183612c1f565b92505b505061243d565b5095945050505050565b6040805160a0810182526000808252602082018190529181018290526060810182905260808101829052600062093a806125198188612b85565b6125239190612b99565b905060005b60ff8110156126a65761253e62093a8083612b5c565b915060004283111561255257429250612568565b506000828152601d8b016020526040902054600f0b5b61257561156e8985612c1f565b89602001516125849190612ca2565b89518a90612593908390612c75565b600f0b9052506020890180518291906125ad908390612c32565b600f90810b9091528a516000910b121590506125c857600089525b60008960200151600f0b12156125e057600060208a01525b6040808a018490528701519297508792670de0b6b3a7640000906126049085612c1f565b61260e9088612b99565b6126189190612b85565b87606001516126279190612b5c565b60608a015261263760018b612b5c565b995042830361264c57504360608901526126a6565b60008a815260088c0160209081526040918290208b51918c01516001600160801b03908116600160801b029216919091178155908a0151600182015560608a0151600282015560808a015160039091015550600101612528565b5096989597509495505050505050565b600081815260228301602052604081205465ffffffffffff16801580159061271157506000838152602185016020526040812042916126f6600185612d00565b65ffffffffffff168152602081019190915260400160002054145b156127205760009150506114ab565b60019150506114ab565b5092915050565b6000612786826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166128109092919063ffffffff16565b90508051600014806127a75750808060200190518101906127a79190612d44565b61280b5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084015b60405180910390fd5b505050565b606061281f8484600085612827565b949350505050565b6060824710156128885760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401612802565b600080866001600160a01b031685876040516128a49190612d85565b60006040518083038185875af1925050503d80600081146128e1576040519150601f19603f3d011682016040523d82523d6000602084013e6128e6565b606091505b50915091506128f787838387612902565b979650505050505050565b6060831561297157825160000361296a576001600160a01b0385163b61296a5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401612802565b508161281f565b61281f83838151156129865781518083602001fd5b8060405162461bcd60e51b81526004016128029190612da1565b6040518060a001604052806000600f0b81526020016000600f0b81526020016000815260200160008152602001600081525090565b6001600160a01b03811681146129ea57600080fd5b50565b60008060408385031215612a0057600080fd5b823591506020830135612a12816129d5565b809150509250929050565b60008060408385031215612a3057600080fd5b50508035926020909101359150565b600080600060608486031215612a5457600080fd5b505081359360208301359350604090920135919050565b80151581146129ea57600080fd5b600080600060608486031215612a8e57600080fd5b83359250602084013591506040840135612aa781612a6b565b809150509250925092565b600060208284031215612ac457600080fd5b815161109c816129d5565b634e487b7160e01b600052601160045260246000fd5b600060018201612af757612af7612acf565b5060010190565b634e487b7160e01b600052602160045260246000fd5b60008060408385031215612b2757600080fd5b8251612b32816129d5565b6020840151909250612a12816129d5565b600060208284031215612b5557600080fd5b5051919050565b808201808211156114ab576114ab612acf565b634e487b7160e01b600052601260045260246000fd5b600082612b9457612b94612b6f565b500490565b80820281158282048414176114ab576114ab612acf565b634e487b7160e01b600052603260045260246000fd5b60006040820184835260206040602085015281855180845260608601915060208701935060005b81811015612c125784516001600160a01b031683529383019391830191600101612bed565b5090979650505050505050565b818103818111156114ab576114ab612acf565b600f81810b9083900b0160016001607f1b03811360016001607f1b0319821217156114ab576114ab612acf565b634e487b7160e01b600052600160045260246000fd5b600f82810b9082900b0360016001607f1b0319811260016001607f1b03821317156114ab576114ab612acf565b600082600f0b82600f0b0280600f0b915080821461272a5761272a612acf565b600081600f0b83600f0b80612cd957612cd9612b6f565b60016001607f1b0319821460001982141615612cf757612cf7612acf565b90059392505050565b65ffffffffffff82811682821603908082111561272a5761272a612acf565b600065ffffffffffff808316818103612d3a57612d3a612acf565b6001019392505050565b600060208284031215612d5657600080fd5b815161109c81612a6b565b60005b83811015612d7c578181015183820152602001612d64565b50506000910152565b60008251612d97818460208701612d61565b9190910192915050565b6020815260008251806020840152612dc0816040850160208701612d61565b601f01601f1916919091016040019291505056fea2646970667358221220db3c04c5a09cd167cafec570dc99c34fa99eb3d429d1b178ea01d07cb5a2f3ba64736f6c63430008180033",
  "devdoc": {
    "events": {
      "DelegateChanged(address,uint256,uint256)": {
        "details": "Emitted when an account changes their delegate."
      },
      "MetadataUpdate(uint256)": {
        "details": "This event emits when the metadata of a token is changed. So that the third-party platforms such as NFT market could timely update the images and related attributes of the NFT."
      },
      "Transfer(address,address,uint256)": {
        "details": "Emitted when `tokenId` token is transferred from `from` to `to`."
      }
    },
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}