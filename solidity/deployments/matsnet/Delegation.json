{
  "address": "0x6630E1209B65EC2deEddF98Ba46b6247B73a1468",
  "abi": [
    {
      "inputs": [],
      "name": "InvalidNonce",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSignature",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSignatureS",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NonExistentToken",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotApprovedOrOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotPermanentLock",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OwnershipChange",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SafeCastUnderflow",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SignatureExpired",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "delegator",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "fromDelegate",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "toDelegate",
          "type": "uint256"
        }
      ],
      "name": "DelegateChanged",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "DELEGATION_TYPEHASH",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "DOMAIN_TYPEHASH",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x0512b25e78b070331a6e31c53cb0104c72070bac3b49c7d16144d22ec73cc016",
  "receipt": {
    "to": null,
    "from": "0x6e80164ea60673D64d5d6228beb684a1274Bb017",
    "contractAddress": "0x6630E1209B65EC2deEddF98Ba46b6247B73a1468",
    "transactionIndex": 0,
    "gasUsed": "992623",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xd93822ec4038138c2dea8319f54db3a49dcbacf04fd3d8b1e66a62a9e0e98940",
    "transactionHash": "0x0512b25e78b070331a6e31c53cb0104c72070bac3b49c7d16144d22ec73cc016",
    "logs": [],
    "blockNumber": 3218646,
    "cumulativeGasUsed": "992623",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "e46a5fe1a7647fe20def7a26ea4bca9d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InvalidNonce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignatureS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonExistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotApprovedOrOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPermanentLock\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnershipChange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeCastUnderflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignatureExpired\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromDelegate\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"toDelegate\",\"type\":\"uint256\"}],\"name\":\"DelegateChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DELEGATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"DelegateChanged(address,uint256,uint256)\":{\"details\":\"Emitted when an account changes their delegate.\"}},\"kind\":\"dev\",\"methods\":{\"getPastVotes(VotingEscrowState.Storage storage,address,uint256,uint256)\":{\"details\":\"If a checkpoint does not exist prior to the timestamp, this will return 0.      The user must also own the token at the time in order to receive a voting balance.\",\"params\":{\"_account\":\".\",\"_timestamp\":\".\",\"_tokenId\":\".\"},\"returns\":{\"_0\":\"Total voting balance including delegations at a given timestamp.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"DELEGATION_TYPEHASH()\":{\"notice\":\"The EIP-712 typehash for the delegation struct used by the contract\"},\"DOMAIN_TYPEHASH()\":{\"notice\":\"The EIP-712 typehash for the contract's domain\"},\"getPastVotes(VotingEscrowState.Storage storage,address,uint256,uint256)\":{\"notice\":\"Retrieves historical voting balance for a token id at a given timestamp.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ve/Delegation.sol\":\"Delegation\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\",\"keccak256\":\"0xd04b0f06e0666f29cf7cccc82894de541e19bb30a765b107b1e40bb7fe5f7d7a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC4906.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4906.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\n\\n/// @title EIP-721 Metadata Update Extension\\ninterface IERC4906 is IERC165, IERC721 {\\n    /// @dev This event emits when the metadata of a token is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFT.\\n    event MetadataUpdate(uint256 _tokenId);\\n\\n    /// @dev This event emits when the metadata of a range of tokens is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFTs.\\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\\n}\\n\",\"keccak256\":\"0x2a9dadb806be80dd451821f1f1190eb9aa6f6edae85b185db29d60767cc0c5f4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC6372.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC6372 {\\n    /**\\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\\n     */\\n    function clock() external view returns (uint48);\\n\\n    /**\\n     * @dev Description of the clock\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function CLOCK_MODE() external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xcaea9aeda3816ba872358c828f4f01455c22ae48ced49c4c7d72bd74176c09b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721.sol\\\";\\n\",\"keccak256\":\"0xaf297d12d8d4a57fe01a70f0ef38908f208e3faedc577056d0b728fa2f3ccf0c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xa82b58eca1ee256be466e536706850163d2ec7821945abd6b4778cfb3bee37da\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/governance/IVotes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// Modified IVotes interface for tokenId based voting\\ninterface IVotes {\\n    /**\\n     * @dev Emitted when an account changes their delegate.\\n     */\\n    event DelegateChanged(\\n        address indexed delegator,\\n        uint256 indexed fromDelegate,\\n        uint256 indexed toDelegate\\n    );\\n\\n    /**\\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\\n     */\\n    event DelegateVotesChanged(\\n        address indexed delegate,\\n        uint256 previousBalance,\\n        uint256 newBalance\\n    );\\n\\n    /**\\n     * @dev Returns the amount of votes that `tokenId` had at a specific moment in the past.\\n     *      If the account passed in is not the owner, returns 0.\\n     */\\n    function getPastVotes(\\n        address account,\\n        uint256 tokenId,\\n        uint256 timepoint\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\\n     * configured to use block numbers, this will return the value the end of the corresponding block.\\n     *\\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\\n     * vote.\\n     */\\n    function getPastTotalSupply(\\n        uint256 timepoint\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the delegate that `tokenId` has chosen. Can never be equal to the delegator's `tokenId`.\\n     *      Returns 0 if not delegated.\\n     */\\n    function delegates(uint256 tokenId) external view returns (uint256);\\n\\n    /**\\n     * @dev Delegates votes from the sender to `delegatee`.\\n     */\\n    function delegate(uint256 delegator, uint256 delegatee) external;\\n\\n    /**\\n     * @dev Delegates votes from `delegator` to `delegatee`. Signer must own `delegator`.\\n     */\\n    function delegateBySig(\\n        uint256 delegator,\\n        uint256 delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\",\"keccak256\":\"0xb4886474bc559202c8004ffba54c1d11dd14c3bbbc3a107bd522cc0f99b2ba7e\",\"license\":\"MIT\"},\"contracts/interfaces/IVeArtProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IVeArtProxy {\\n    function tokenURI(\\n        uint256 _tokenId\\n    ) external view returns (string memory output);\\n}\\n\",\"keccak256\":\"0x6dfdb4b1d8f01ecf556c59cd43b8ba8715cdaaf3e9872ba8f840f8be323bfb3d\",\"license\":\"MIT\"},\"contracts/interfaces/IVotingEscrow.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\nimport {IERC165, IERC721, IERC721Metadata} from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\nimport {IERC6372} from \\\"@openzeppelin/contracts/interfaces/IERC6372.sol\\\";\\nimport {IERC4906} from \\\"@openzeppelin/contracts/interfaces/IERC4906.sol\\\";\\nimport {IVotes} from \\\"../governance/IVotes.sol\\\";\\n\\ninterface IVotingEscrow is IVotes, IERC4906, IERC6372, IERC721Metadata {\\n    struct LockedBalance {\\n        int128 amount;\\n        uint256 end;\\n        bool isPermanent;\\n    }\\n\\n    struct UserPoint {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint256 ts;\\n        uint256 blk; // block\\n        uint256 permanent;\\n    }\\n\\n    struct GlobalPoint {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint256 ts;\\n        uint256 blk; // block\\n        uint256 permanentLockBalance;\\n    }\\n\\n    /// @notice A checkpoint for recorded delegated voting weights at a certain timestamp\\n    struct Checkpoint {\\n        uint256 fromTimestamp;\\n        address owner;\\n        uint256 delegatedBalance;\\n        uint256 delegatee;\\n    }\\n\\n    enum DepositType {\\n        DEPOSIT_FOR_TYPE,\\n        CREATE_LOCK_TYPE,\\n        INCREASE_LOCK_AMOUNT,\\n        INCREASE_UNLOCK_TIME\\n    }\\n\\n    /// @dev Different types of veNFTs:\\n    /// NORMAL  - typical veNFT\\n    /// LOCKED  - veNFT which is locked into a MANAGED veNFT\\n    /// MANAGED - veNFT which can accept the deposit of NORMAL veNFTs\\n    enum EscrowType {\\n        NORMAL,\\n        LOCKED,\\n        MANAGED\\n    }\\n\\n    error AlreadyVoted();\\n    error AmountTooBig();\\n    error ERC721ReceiverRejectedTokens();\\n    error ERC721TransferToNonERC721ReceiverImplementer();\\n    error InvalidNonce();\\n    error InvalidSignature();\\n    error InvalidSignatureS();\\n    error InvalidManagedNFTId();\\n    error LockDurationNotInFuture();\\n    error LockDurationTooLong();\\n    error LockExpired();\\n    error LockNotExpired();\\n    error NoLockFound();\\n    error NonExistentToken();\\n    error NotApprovedOrOwner();\\n    error NotDistributor();\\n    error NotEmergencyCouncilOrGovernor();\\n    error NotGovernor();\\n    error NotGovernorOrManager();\\n    error NotManagedNFT();\\n    error NotManagedOrNormalNFT();\\n    error NotLockedNFT();\\n    error NotNormalNFT();\\n    error NotPermanentLock();\\n    error NotOwner();\\n    error NotTeam();\\n    error NotVoter();\\n    error OwnershipChange();\\n    error PermanentLock();\\n    error SameAddress();\\n    error SameNFT();\\n    error SameState();\\n    error SplitNoOwner();\\n    error SplitNotAllowed();\\n    error SignatureExpired();\\n    error TooManyTokenIDs();\\n    error ZeroAddress();\\n    error ZeroAmount();\\n    error ZeroBalance();\\n\\n    event Deposit(\\n        address indexed provider,\\n        uint256 indexed tokenId,\\n        DepositType indexed depositType,\\n        uint256 value,\\n        uint256 locktime,\\n        uint256 ts\\n    );\\n    event Withdraw(\\n        address indexed provider,\\n        uint256 indexed tokenId,\\n        uint256 value,\\n        uint256 ts\\n    );\\n    event LockPermanent(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 amount,\\n        uint256 _ts\\n    );\\n    event UnlockPermanent(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 amount,\\n        uint256 _ts\\n    );\\n    event Supply(uint256 prevSupply, uint256 supply);\\n    event Merge(\\n        address indexed _sender,\\n        uint256 indexed _from,\\n        uint256 indexed _to,\\n        uint256 _amountFrom,\\n        uint256 _amountTo,\\n        uint256 _amountFinal,\\n        uint256 _locktime,\\n        uint256 _ts\\n    );\\n    event Split(\\n        uint256 indexed _from,\\n        uint256 indexed _tokenId1,\\n        uint256 indexed _tokenId2,\\n        address _sender,\\n        uint256 _splitAmount1,\\n        uint256 _splitAmount2,\\n        uint256 _locktime,\\n        uint256 _ts\\n    );\\n    event CreateManaged(\\n        address indexed _to,\\n        uint256 indexed _mTokenId,\\n        address indexed _from,\\n        address _lockedManagedReward,\\n        address _freeManagedReward\\n    );\\n    event DepositManaged(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 indexed _mTokenId,\\n        uint256 _weight,\\n        uint256 _ts\\n    );\\n    event WithdrawManaged(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 indexed _mTokenId,\\n        uint256 _weight,\\n        uint256 _ts\\n    );\\n    event SetAllowedManager(address indexed _allowedManager);\\n\\n    // State variables\\n    /// @notice Address of Meta-tx Forwarder\\n    function forwarder() external view returns (address);\\n\\n    /// @notice Address of FactoryRegistry.sol\\n    function factoryRegistry() external view returns (address);\\n\\n    /// @notice Address of token used to create a veNFT\\n    function token() external view returns (address);\\n\\n    /// @notice Address of RewardsDistributor.sol\\n    function distributor() external view returns (address);\\n\\n    /// @notice Address of Voter.sol\\n    function voter() external view returns (address);\\n\\n    /// @notice Address of Protocol Team multisig\\n    function team() external view returns (address);\\n\\n    /// @notice Address of art proxy used for on-chain art generation\\n    function artProxy() external view returns (address);\\n\\n    /// @dev address which can create managed NFTs\\n    function allowedManager() external view returns (address);\\n\\n    /// @dev Current count of token\\n    function tokenId() external view returns (uint256);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            MANAGED NFT STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Mapping of token id to escrow type\\n    ///      Takes advantage of the fact default value is EscrowType.NORMAL\\n    function escrowType(uint256 tokenId) external view returns (EscrowType);\\n\\n    /// @dev Mapping of token id to managed id\\n    function idToManaged(\\n        uint256 tokenId\\n    ) external view returns (uint256 managedTokenId);\\n\\n    /// @dev Mapping of user token id to managed token id to weight of token id\\n    function weights(\\n        uint256 tokenId,\\n        uint256 managedTokenId\\n    ) external view returns (uint256 weight);\\n\\n    /// @dev Mapping of managed id to deactivated state\\n    function deactivated(uint256 tokenId) external view returns (bool inactive);\\n\\n    /// @dev Mapping from managed nft id to locked managed rewards\\n    ///      `token` denominated rewards (rebases/rewards) stored in locked managed rewards contract\\n    ///      to prevent co-mingling of assets\\n    function managedToLocked(uint256 tokenId) external view returns (address);\\n\\n    /// @dev Mapping from managed nft id to free managed rewards contract\\n    ///      these rewards can be freely withdrawn by users\\n    function managedToFree(uint256 tokenId) external view returns (address);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            MANAGED NFT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Create managed NFT (a permanent lock) for use within ecosystem.\\n    /// @dev Throws if address already owns a managed NFT.\\n    /// @return _mTokenId managed token id.\\n    function createManagedLockFor(\\n        address _to\\n    ) external returns (uint256 _mTokenId);\\n\\n    /// @notice Delegates balance to managed nft\\n    ///         Note that NFTs deposited into a managed NFT will be re-locked\\n    ///         to the maximum lock time on withdrawal.\\n    ///         Permanent locks that are deposited will automatically unlock.\\n    /// @dev Managed nft will remain max-locked as long as there is at least one\\n    ///      deposit or withdrawal per week.\\n    ///      Throws if deposit nft is managed.\\n    ///      Throws if recipient nft is not managed.\\n    ///      Throws if deposit nft is already locked.\\n    ///      Throws if not called by voter.\\n    /// @param _tokenId tokenId of NFT being deposited\\n    /// @param _mTokenId tokenId of managed NFT that will receive the deposit\\n    function depositManaged(uint256 _tokenId, uint256 _mTokenId) external;\\n\\n    /// @notice Retrieves locked rewards and withdraws balance from managed nft.\\n    ///         Note that the NFT withdrawn is re-locked to the maximum lock time.\\n    /// @dev Throws if NFT not locked.\\n    ///      Throws if not called by voter.\\n    /// @param _tokenId tokenId of NFT being deposited.\\n    function withdrawManaged(uint256 _tokenId) external;\\n\\n    /// @notice Permit one address to call createManagedLockFor() that is not Voter.governor()\\n    function setAllowedManager(address _allowedManager) external;\\n\\n    /// @notice Set Managed NFT state. Inactive NFTs cannot be deposited into.\\n    /// @param _mTokenId managed nft state to set\\n    /// @param _state true => inactive, false => active\\n    function setManagedState(uint256 _mTokenId, bool _state) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function version() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function setTeam(address _team) external;\\n\\n    function setArtProxy(address _proxy) external;\\n\\n    /// @inheritdoc IERC721Metadata\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Mapping from owner address to mapping of index to tokenId\\n    function ownerToNFTokenIdList(\\n        address _owner,\\n        uint256 _index\\n    ) external view returns (uint256 _tokenId);\\n\\n    /// @inheritdoc IERC721\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /// @inheritdoc IERC721\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC721\\n    function getApproved(\\n        uint256 _tokenId\\n    ) external view returns (address operator);\\n\\n    /// @inheritdoc IERC721\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n\\n    /// @notice Check whether spender is owner or an approved user for a given veNFT\\n    /// @param _spender .\\n    /// @param _tokenId .\\n    function isApprovedOrOwner(\\n        address _spender,\\n        uint256 _tokenId\\n    ) external returns (bool);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC721\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /// @inheritdoc IERC721\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /// @inheritdoc IERC721\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /// @inheritdoc IERC721\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /// @inheritdoc IERC721\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(\\n        bytes4 _interfaceID\\n    ) external view returns (bool);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ESCROW STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Total count of epochs witnessed since contract creation\\n    function epoch() external view returns (uint256);\\n\\n    /// @notice Total amount of token() deposited\\n    function supply() external view returns (uint256);\\n\\n    /// @notice Aggregate permanent locked balances\\n    function permanentLockBalance() external view returns (uint256);\\n\\n    function userPointEpoch(\\n        uint256 _tokenId\\n    ) external view returns (uint256 _epoch);\\n\\n    /// @notice time -> signed slope change\\n    function slopeChanges(uint256 _timestamp) external view returns (int128);\\n\\n    /// @notice account -> can split\\n    function canSplit(address _account) external view returns (bool);\\n\\n    /// @notice Global point history at a given index\\n    function pointHistory(\\n        uint256 _loc\\n    ) external view returns (GlobalPoint memory);\\n\\n    /// @notice Get the LockedBalance (amount, end) of a _tokenId\\n    /// @param _tokenId .\\n    /// @return LockedBalance of _tokenId\\n    function locked(\\n        uint256 _tokenId\\n    ) external view returns (LockedBalance memory);\\n\\n    /// @notice User -> UserPoint[userEpoch]\\n    function userPointHistory(\\n        uint256 _tokenId,\\n        uint256 _loc\\n    ) external view returns (UserPoint memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ESCROW LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Record global data to checkpoint\\n    function checkpoint() external;\\n\\n    /// @notice Deposit `_value` tokens for `_tokenId` and add to the lock\\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\\n    ///      cannot extend their locktime and deposit for a brand new user\\n    /// @param _tokenId lock NFT\\n    /// @param _value Amount to add to user's lock\\n    function depositFor(uint256 _tokenId, uint256 _value) external;\\n\\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lockDuration`\\n    /// @param _value Amount to deposit\\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\\n    /// @return TokenId of created veNFT\\n    function createLock(\\n        uint256 _value,\\n        uint256 _lockDuration\\n    ) external returns (uint256);\\n\\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lockDuration`\\n    /// @param _value Amount to deposit\\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\\n    /// @param _to Address to deposit\\n    /// @return TokenId of created veNFT\\n    function createLockFor(\\n        uint256 _value,\\n        uint256 _lockDuration,\\n        address _to\\n    ) external returns (uint256);\\n\\n    /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\\n    /// @param _value Amount of tokens to deposit and add to the lock\\n    function increaseAmount(uint256 _tokenId, uint256 _value) external;\\n\\n    /// @notice Extend the unlock time for `_tokenId`\\n    ///         Cannot extend lock time of permanent locks\\n    /// @param _lockDuration New number of seconds until tokens unlock\\n    function increaseUnlockTime(\\n        uint256 _tokenId,\\n        uint256 _lockDuration\\n    ) external;\\n\\n    /// @notice Withdraw all tokens for `_tokenId`\\n    /// @dev Only possible if the lock is both expired and not permanent\\n    ///      This will burn the veNFT. Any rebases or rewards that are unclaimed\\n    ///      will no longer be claimable. Claim all rebases and rewards prior to calling this.\\n    function withdraw(uint256 _tokenId) external;\\n\\n    /// @notice Merges `_from` into `_to`.\\n    /// @dev Cannot merge `_from` locks that are permanent or have already voted this epoch.\\n    ///      Cannot merge `_to` locks that have already expired.\\n    ///      This will burn the veNFT. Any rebases or rewards that are unclaimed\\n    ///      will no longer be claimable. Claim all rebases and rewards prior to calling this.\\n    /// @param _from VeNFT to merge from.\\n    /// @param _to VeNFT to merge into.\\n    function merge(uint256 _from, uint256 _to) external;\\n\\n    /// @notice Splits veNFT into two new veNFTS - one with oldLocked.amount - `_amount`, and the second with `_amount`\\n    /// @dev    This burns the tokenId of the target veNFT\\n    ///         Callable by approved or owner\\n    ///         If this is called by approved, approved will not have permissions to manipulate the newly created veNFTs\\n    ///         Returns the two new split veNFTs to owner\\n    ///         If `from` is permanent, will automatically dedelegate.\\n    ///         This will burn the veNFT. Any rebases or rewards that are unclaimed\\n    ///         will no longer be claimable. Claim all rebases and rewards prior to calling this.\\n    /// @param _from VeNFT to split.\\n    /// @param _amount Amount to split from veNFT.\\n    /// @return _tokenId1 Return tokenId of veNFT with oldLocked.amount - `_amount`.\\n    /// @return _tokenId2 Return tokenId of veNFT with `_amount`.\\n    function split(\\n        uint256 _from,\\n        uint256 _amount\\n    ) external returns (uint256 _tokenId1, uint256 _tokenId2);\\n\\n    /// @notice Toggle split for a specific address.\\n    /// @dev Toggle split for address(0) to enable or disable for all.\\n    /// @param _account Address to toggle split permissions\\n    /// @param _bool True to allow, false to disallow\\n    function toggleSplit(address _account, bool _bool) external;\\n\\n    /// @notice Permanently lock a veNFT. Voting power will be equal to\\n    ///         `LockedBalance.amount` with no decay. Required to delegate.\\n    /// @dev Only callable by unlocked normal veNFTs.\\n    /// @param _tokenId tokenId to lock.\\n    function lockPermanent(uint256 _tokenId) external;\\n\\n    /// @notice Unlock a permanently locked veNFT. Voting power will decay.\\n    ///         Will automatically dedelegate if delegated.\\n    /// @dev Only callable by permanently locked veNFTs.\\n    ///      Cannot unlock if already voted this epoch.\\n    /// @param _tokenId tokenId to unlock.\\n    function unlockPermanent(uint256 _tokenId) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           GAUGE VOTING STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Get the voting power for _tokenId at the current timestamp\\n    /// @dev Returns 0 if called in the same block as a transfer.\\n    /// @param _tokenId .\\n    /// @return Voting power\\n    function balanceOfNFT(uint256 _tokenId) external view returns (uint256);\\n\\n    /// @notice Get the voting power for _tokenId at a given timestamp\\n    /// @param _tokenId .\\n    /// @param _t Timestamp to query voting power\\n    /// @return Voting power\\n    function balanceOfNFTAt(\\n        uint256 _tokenId,\\n        uint256 _t\\n    ) external view returns (uint256);\\n\\n    /// @notice Calculate total voting power at current timestamp\\n    /// @return Total voting power at current timestamp\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Calculate total voting power at a given timestamp\\n    /// @param _t Timestamp to query total voting power\\n    /// @return Total voting power at given timestamp\\n    function totalSupplyAt(uint256 _t) external view returns (uint256);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            GAUGE VOTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice See if a queried _tokenId has actively voted\\n    /// @param _tokenId .\\n    /// @return True if voted, else false\\n    function voted(uint256 _tokenId) external view returns (bool);\\n\\n    /// @notice Set the global state voter and distributor\\n    /// @dev This is only called once, at setup\\n    function setVoterAndDistributor(\\n        address _voter,\\n        address _distributor\\n    ) external;\\n\\n    /// @notice Set `voted` for _tokenId to true or false\\n    /// @dev Only callable by voter\\n    /// @param _tokenId .\\n    /// @param _voted .\\n    function voting(uint256 _tokenId, bool _voted) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            DAO VOTING STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The number of checkpoints for each tokenId\\n    function numCheckpoints(uint256 tokenId) external view returns (uint48);\\n\\n    /// @notice A record of states for signing / validating signatures\\n    function nonces(address account) external view returns (uint256);\\n\\n    /// @inheritdoc IVotes\\n    function delegates(uint256 delegator) external view returns (uint256);\\n\\n    /// @notice A record of delegated token checkpoints for each account, by index\\n    /// @param tokenId .\\n    /// @param index .\\n    /// @return Checkpoint\\n    function checkpoints(\\n        uint256 tokenId,\\n        uint48 index\\n    ) external view returns (Checkpoint memory);\\n\\n    /// @inheritdoc IVotes\\n    function getPastVotes(\\n        address account,\\n        uint256 tokenId,\\n        uint256 timestamp\\n    ) external view returns (uint256);\\n\\n    /// @inheritdoc IVotes\\n    function getPastTotalSupply(\\n        uint256 timestamp\\n    ) external view returns (uint256);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             DAO VOTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IVotes\\n    function delegate(uint256 delegator, uint256 delegatee) external;\\n\\n    /// @inheritdoc IVotes\\n    function delegateBySig(\\n        uint256 delegator,\\n        uint256 delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC6372 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC6372\\n    function clock() external view returns (uint48);\\n\\n    /// @inheritdoc IERC6372\\n    function CLOCK_MODE() external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x98987ce08f208b6eef4481d4f85bb64c7477164150c7dba176f8f77adbd9b8cf\",\"license\":\"MIT\"},\"contracts/libraries/SafeCastLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.24;\\n\\n/// @title SafeCast Library\\n/// @author velodrome.finance\\n/// @notice Safely convert unsigned and signed integers without overflow / underflow\\nlibrary SafeCastLibrary {\\n    error SafeCastOverflow();\\n    error SafeCastUnderflow();\\n\\n    /// @dev Safely convert uint256 to int128\\n    function toInt128(uint256 value) internal pure returns (int128) {\\n        if (value > uint128(type(int128).max)) revert SafeCastOverflow();\\n        return int128(uint128(value));\\n    }\\n\\n    /// @dev Safely convert int128 to uint256\\n    function toUint256(int128 value) internal pure returns (uint256) {\\n        if (value < 0) revert SafeCastUnderflow();\\n        return uint256(int256(value));\\n    }\\n}\\n\",\"keccak256\":\"0xfc419390f2423ffa802e9a3a11ee859b01fee9ffdb0fca855008d6b7d6b25bd6\",\"license\":\"BUSL-1.1\"},\"contracts/ve/Delegation.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.24;\\n\\nimport {VotingEscrowState} from \\\"./VotingEscrowState.sol\\\";\\nimport {NFT} from \\\"./NFT.sol\\\";\\nimport {VeERC2771Context} from \\\"./VeERC2771Context.sol\\\";\\nimport {SafeCastLibrary} from \\\"../libraries/SafeCastLibrary.sol\\\";\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport {IVotes} from \\\"../governance/IVotes.sol\\\";\\n\\nlibrary Delegation {\\n    using SafeCastLibrary for int128;\\n    using NFT for VotingEscrowState.Storage;\\n    using VeERC2771Context for VotingEscrowState.Storage;\\n\\n    struct SignatureData {\\n        uint256 delegator;\\n        uint256 delegatee;\\n        uint256 nonce;\\n        uint256 expiry;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH =\\n        keccak256(\\n            \\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\"\\n        );\\n\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\\n    bytes32 public constant DELEGATION_TYPEHASH =\\n        keccak256(\\n            \\\"Delegation(uint256 delegator,uint256 delegatee,uint256 nonce,uint256 expiry)\\\"\\n        );\\n\\n    function delegate(\\n        VotingEscrowState.Storage storage self,\\n        uint256 delegator,\\n        uint256 delegatee\\n    ) external {\\n        if (!self._isApprovedOrOwner(self._msgSender(), delegator))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        return _delegate(self, delegator, delegatee);\\n    }\\n\\n    function delegateBySig(\\n        VotingEscrowState.Storage storage self,\\n        SignatureData calldata signatureData,\\n        string calldata contractName,\\n        string calldata contractVersion\\n    ) external {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (\\n            uint256(signatureData.s) >\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\\n        ) revert IVotingEscrow.InvalidSignatureS();\\n        bytes32 domainSeparator = keccak256(\\n            abi.encode(\\n                DOMAIN_TYPEHASH,\\n                keccak256(bytes(contractName)),\\n                keccak256(bytes(contractVersion)),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                DELEGATION_TYPEHASH,\\n                signatureData.delegator,\\n                signatureData.delegatee,\\n                signatureData.nonce,\\n                signatureData.expiry\\n            )\\n        );\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash)\\n        );\\n        address signatory = ecrecover(\\n            digest,\\n            signatureData.v,\\n            signatureData.r,\\n            signatureData.s\\n        );\\n        if (!self._isApprovedOrOwner(signatory, signatureData.delegator))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        if (signatory == address(0)) revert IVotingEscrow.InvalidSignature();\\n        if (signatureData.nonce != self.nonces[signatory]++)\\n            revert IVotingEscrow.InvalidNonce();\\n        if (block.timestamp > signatureData.expiry)\\n            revert IVotingEscrow.SignatureExpired();\\n        return\\n            _delegate(self, signatureData.delegator, signatureData.delegatee);\\n    }\\n\\n    /// @notice Record user delegation checkpoints. Used by voting system.\\n    /// @dev Skips delegation if already delegated to `delegatee`.\\n    function _delegate(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _delegator,\\n        uint256 _delegatee\\n    ) internal {\\n        IVotingEscrow.LockedBalance memory delegateLocked = self._locked[\\n            _delegator\\n        ];\\n        if (!delegateLocked.isPermanent)\\n            revert IVotingEscrow.NotPermanentLock();\\n        if (_delegatee != 0 && self._ownerOf(_delegatee) == address(0))\\n            revert IVotingEscrow.NonExistentToken();\\n        if (self.ownershipChange[_delegator] == block.number)\\n            revert IVotingEscrow.OwnershipChange();\\n        if (_delegatee == _delegator) _delegatee = 0;\\n        uint256 currentDelegate = self._delegates[_delegator];\\n        if (currentDelegate == _delegatee) return;\\n\\n        uint256 delegatedBalance = delegateLocked.amount.toUint256();\\n        _checkpointDelegator(\\n            self,\\n            _delegator,\\n            _delegatee,\\n            self._ownerOf(_delegator)\\n        );\\n        _checkpointDelegatee(self, _delegatee, delegatedBalance, true);\\n\\n        emit IVotes.DelegateChanged(\\n            self._msgSender(),\\n            currentDelegate,\\n            _delegatee\\n        );\\n    }\\n\\n    /// @notice Used by `_mint`, `_transferFrom`, `_burn` and `delegate`\\n    ///         to update delegator voting checkpoints.\\n    ///         Automatically dedelegates, then updates checkpoint.\\n    /// @dev This function depends on `_locked` and must be called prior to token state changes.\\n    ///      If you wish to dedelegate only, use `_delegate(tokenId, 0)` instead.\\n    /// @param _delegator The delegator to update checkpoints for\\n    /// @param _delegatee The new delegatee for the delegator. Cannot be equal to `_delegator` (use 0 instead).\\n    /// @param _owner The new (or current) owner for the delegator\\n    function _checkpointDelegator(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _delegator,\\n        uint256 _delegatee,\\n        address _owner\\n    ) internal {\\n        uint256 delegatedBalance = self._locked[_delegator].amount.toUint256();\\n        uint48 numCheckpoint = self.numCheckpoints[_delegator];\\n        IVotingEscrow.Checkpoint storage cpOld = numCheckpoint > 0\\n            ? self._checkpoints[_delegator][numCheckpoint - 1]\\n            : self._checkpoints[_delegator][0];\\n        // Dedelegate from delegatee if delegated\\n        _checkpointDelegatee(self, cpOld.delegatee, delegatedBalance, false);\\n        IVotingEscrow.Checkpoint storage cp = self._checkpoints[_delegator][\\n            numCheckpoint\\n        ];\\n        cp.fromTimestamp = block.timestamp;\\n        cp.delegatedBalance = cpOld.delegatedBalance;\\n        cp.delegatee = _delegatee;\\n        cp.owner = _owner;\\n\\n        if (_isCheckpointInNewBlock(self, _delegator)) {\\n            self.numCheckpoints[_delegator]++;\\n        } else {\\n            self._checkpoints[_delegator][numCheckpoint - 1] = cp;\\n            delete self._checkpoints[_delegator][numCheckpoint];\\n        }\\n\\n        self._delegates[_delegator] = _delegatee;\\n    }\\n\\n    /// @notice Update delegatee's `delegatedBalance` by `balance`.\\n    ///         Only updates if delegating to a new delegatee.\\n    /// @dev If used with `balance` == `_locked[_tokenId].amount`, then this is the same as\\n    ///      delegating or dedelegating from `_tokenId`\\n    ///      If used with `balance` < `_locked[_tokenId].amount`, then this is used to adjust\\n    ///      `delegatedBalance` when a user's balance is modified (e.g. `increaseAmount`, `merge` etc).\\n    ///      If `delegatee` is 0 (i.e. user is not delegating), then do nothing.\\n    /// @param _delegatee The delegatee's tokenId\\n    /// @param balance_ The delta in balance change\\n    /// @param _increase True if balance is increasing, false if decreasing\\n    function _checkpointDelegatee(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _delegatee,\\n        uint256 balance_,\\n        bool _increase\\n    ) internal {\\n        if (_delegatee == 0) return;\\n        uint48 numCheckpoint = self.numCheckpoints[_delegatee];\\n        IVotingEscrow.Checkpoint storage cpOld = numCheckpoint > 0\\n            ? self._checkpoints[_delegatee][numCheckpoint - 1]\\n            : self._checkpoints[_delegatee][0];\\n        IVotingEscrow.Checkpoint storage cp = self._checkpoints[_delegatee][\\n            numCheckpoint\\n        ];\\n        cp.fromTimestamp = block.timestamp;\\n        cp.owner = cpOld.owner;\\n        // do not expect balance_ > cpOld.delegatedBalance when decrementing but just in case\\n        cp.delegatedBalance = _increase\\n            ? cpOld.delegatedBalance + balance_\\n            : (\\n                balance_ < cpOld.delegatedBalance\\n                    ? cpOld.delegatedBalance - balance_\\n                    : 0\\n            );\\n        cp.delegatee = cpOld.delegatee;\\n\\n        if (_isCheckpointInNewBlock(self, _delegatee)) {\\n            self.numCheckpoints[_delegatee]++;\\n        } else {\\n            self._checkpoints[_delegatee][numCheckpoint - 1] = cp;\\n            delete self._checkpoints[_delegatee][numCheckpoint];\\n        }\\n    }\\n\\n    function _isCheckpointInNewBlock(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) internal view returns (bool) {\\n        uint48 _nCheckPoints = self.numCheckpoints[_tokenId];\\n\\n        if (\\n            _nCheckPoints > 0 &&\\n            self._checkpoints[_tokenId][_nCheckPoints - 1].fromTimestamp ==\\n            block.timestamp\\n        ) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /// @notice Retrieves historical voting balance for a token id at a given timestamp.\\n    /// @dev If a checkpoint does not exist prior to the timestamp, this will return 0.\\n    ///      The user must also own the token at the time in order to receive a voting balance.\\n    /// @param _account .\\n    /// @param _tokenId .\\n    /// @param _timestamp .\\n    /// @return Total voting balance including delegations at a given timestamp.\\n    function getPastVotes(\\n        VotingEscrowState.Storage storage self,\\n        address _account,\\n        uint256 _tokenId,\\n        uint256 _timestamp\\n    ) external view returns (uint256) {\\n        uint48 _checkIndex = getPastVotesIndex(self, _tokenId, _timestamp);\\n        IVotingEscrow.Checkpoint memory lastCheckpoint = self._checkpoints[\\n            _tokenId\\n        ][_checkIndex];\\n        // If no point exists prior to the given timestamp, return 0\\n        if (lastCheckpoint.fromTimestamp > _timestamp) return 0;\\n        // Check ownership\\n        if (_account != lastCheckpoint.owner) return 0;\\n        uint256 votes = lastCheckpoint.delegatedBalance;\\n        return\\n            lastCheckpoint.delegatee == 0\\n                ? votes +\\n                    IVotingEscrow(address(this)).balanceOfNFTAt(\\n                        _tokenId,\\n                        _timestamp\\n                    )\\n                : votes;\\n    }\\n\\n    /// @notice Binary search to get the voting checkpoint for a token id at or prior to a given timestamp.\\n    /// @dev If a checkpoint does not exist prior to the timestamp, this will return 0.\\n    /// @param _tokenId .\\n    /// @param _timestamp .\\n    /// @return The index of the checkpoint.\\n    function getPastVotesIndex(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        uint256 _timestamp\\n    ) internal view returns (uint48) {\\n        uint48 nCheckpoints = self.numCheckpoints[_tokenId];\\n        if (nCheckpoints == 0) return 0;\\n        // First check most recent balance\\n        if (\\n            self._checkpoints[_tokenId][nCheckpoints - 1].fromTimestamp <=\\n            _timestamp\\n        ) return (nCheckpoints - 1);\\n        // Next check implicit zero balance\\n        if (self._checkpoints[_tokenId][0].fromTimestamp > _timestamp) return 0;\\n\\n        uint48 lower = 0;\\n        uint48 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint48 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            IVotingEscrow.Checkpoint storage cp = self._checkpoints[_tokenId][\\n                center\\n            ];\\n            if (cp.fromTimestamp == _timestamp) {\\n                return center;\\n            } else if (cp.fromTimestamp < _timestamp) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return lower;\\n    }\\n}\\n\",\"keccak256\":\"0x2e29a6cbff7b7301fa8d7607287445f6352662ddb317e6264152a12bf2952255\",\"license\":\"BUSL-1.1\"},\"contracts/ve/NFT.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.24;\\n\\nimport {VotingEscrowState} from \\\"./VotingEscrowState.sol\\\";\\nimport {Delegation} from \\\"./Delegation.sol\\\";\\nimport {VeERC2771Context} from \\\"./VeERC2771Context.sol\\\";\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport {IVeArtProxy} from \\\"../interfaces/IVeArtProxy.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\n\\nlibrary NFT {\\n    using Delegation for VotingEscrowState.Storage;\\n    using VeERC2771Context for VotingEscrowState.Storage;\\n\\n    function approve(\\n        VotingEscrowState.Storage storage self,\\n        address _approved,\\n        uint256 _tokenId\\n    ) external {\\n        address sender = self._msgSender();\\n        address owner = _ownerOf(self, _tokenId);\\n        // Throws if `_tokenId` is not a valid NFT\\n        if (owner == address(0)) revert IVotingEscrow.ZeroAddress();\\n        // Throws if `_approved` is the current owner\\n        if (owner == _approved) revert IVotingEscrow.SameAddress();\\n        // Check requirements\\n        bool senderIsOwner = (_ownerOf(self, _tokenId) == sender);\\n        bool senderIsApprovedForAll = (self.ownerToOperators[owner])[sender];\\n        if (!senderIsOwner && !senderIsApprovedForAll)\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        // Set the approval\\n        self.idToApprovals[_tokenId] = _approved;\\n        emit IERC721.Approval(owner, _approved, _tokenId);\\n    }\\n\\n    function setApprovalForAll(\\n        VotingEscrowState.Storage storage self,\\n        address _operator,\\n        bool _approved\\n    ) external {\\n        address sender = self._msgSender();\\n        // Throws if `_operator` is the `msg.sender`\\n        if (_operator == sender) revert IVotingEscrow.SameAddress();\\n        self.ownerToOperators[sender][_operator] = _approved;\\n        emit IERC721.ApprovalForAll(sender, _operator, _approved);\\n    }\\n\\n    function safeTransferFrom(\\n        VotingEscrowState.Storage storage self,\\n        address _from,\\n        address _to,\\n        uint256 _tokenId,\\n        bytes memory _data\\n    ) external {\\n        address sender = self._msgSender();\\n        _transferFrom(self, _from, _to, _tokenId, sender);\\n\\n        if (_isContract(_to)) {\\n            // Throws if transfer destination is a contract which does not implement 'onERC721Received'\\n            try\\n                IERC721Receiver(_to).onERC721Received(\\n                    sender,\\n                    _from,\\n                    _tokenId,\\n                    _data\\n                )\\n            returns (bytes4 response) {\\n                if (\\n                    response != IERC721Receiver(_to).onERC721Received.selector\\n                ) {\\n                    revert IVotingEscrow.ERC721ReceiverRejectedTokens();\\n                }\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert IVotingEscrow\\n                        .ERC721TransferToNonERC721ReceiverImplementer();\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function _transferFrom(\\n        VotingEscrowState.Storage storage self,\\n        address _from,\\n        address _to,\\n        uint256 _tokenId,\\n        address _sender\\n    ) internal {\\n        if (self.escrowType[_tokenId] == IVotingEscrow.EscrowType.LOCKED)\\n            revert IVotingEscrow.NotManagedOrNormalNFT();\\n        // Check requirements\\n        if (!_isApprovedOrOwner(self, _sender, _tokenId))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        // Clear approval. Throws if `_from` is not the current owner\\n        if (_ownerOf(self, _tokenId) != _from) revert IVotingEscrow.NotOwner();\\n        delete self.idToApprovals[_tokenId];\\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\\n        _removeTokenFrom(self, _from, _tokenId);\\n        // Update voting checkpoints\\n        self._checkpointDelegator(_tokenId, 0, _to);\\n        // Add NFT\\n        _addTokenTo(self, _to, _tokenId);\\n        // Set the block of ownership transfer (for Flash NFT protection)\\n        self.ownershipChange[_tokenId] = block.number;\\n        // Log the transfer\\n        emit IERC721.Transfer(_from, _to, _tokenId);\\n    }\\n\\n    function _isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /// @dev Add a NFT to a given address\\n    ///      Throws if `_tokenId` is owned by someone.\\n    function _addTokenTo(\\n        VotingEscrowState.Storage storage self,\\n        address _to,\\n        uint256 _tokenId\\n    ) internal {\\n        // Throws if `_tokenId` is owned by someone\\n        assert(_ownerOf(self, _tokenId) == address(0));\\n        // Change the owner\\n        self.idToOwner[_tokenId] = _to;\\n        // Update owner token index tracking\\n        _addTokenToOwnerList(self, _to, _tokenId);\\n        // Change count tracking\\n        self.ownerToNFTokenCount[_to] += 1;\\n    }\\n\\n    /// @dev Function to mint tokens\\n    ///      Throws if `_to` is zero address.\\n    ///      Throws if `_tokenId` is owned by someone.\\n    /// @param _to The address that will receive the minted tokens.\\n    /// @param _tokenId The token id to mint.\\n    /// @return A boolean that indicates if the operation was successful.\\n    function _mint(\\n        VotingEscrowState.Storage storage self,\\n        address _to,\\n        uint256 _tokenId\\n    ) internal returns (bool) {\\n        // Throws if `_to` is zero address\\n        assert(_to != address(0));\\n        // Add NFT. Throws if `_tokenId` is owned by someone\\n        _addTokenTo(self, _to, _tokenId);\\n        // Update voting checkpoints\\n        self._checkpointDelegator(_tokenId, 0, _to);\\n        emit IERC721.Transfer(address(0), _to, _tokenId);\\n        return true;\\n    }\\n\\n    /// @dev Add a NFT to an index mapping to a given address\\n    /// @param _to address of the receiver\\n    /// @param _tokenId uint ID Of the token to be added\\n    function _addTokenToOwnerList(\\n        VotingEscrowState.Storage storage self,\\n        address _to,\\n        uint256 _tokenId\\n    ) internal {\\n        uint256 currentCount = self.ownerToNFTokenCount[_to];\\n\\n        self.ownerToNFTokenIdList[_to][currentCount] = _tokenId;\\n        self.tokenToOwnerIndex[_tokenId] = currentCount;\\n    }\\n\\n    function _ownerOf(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) internal view returns (address) {\\n        return self.idToOwner[_tokenId];\\n    }\\n\\n    function _isApprovedOrOwner(\\n        VotingEscrowState.Storage storage self,\\n        address _spender,\\n        uint256 _tokenId\\n    ) internal view returns (bool) {\\n        address owner = _ownerOf(self, _tokenId);\\n        bool spenderIsOwner = owner == _spender;\\n        bool spenderIsApproved = _spender == self.idToApprovals[_tokenId];\\n        bool spenderIsApprovedForAll = (self.ownerToOperators[owner])[_spender];\\n        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\\n    }\\n\\n    /// @dev Must be called prior to updating `LockedBalance`\\n    function _burn(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) internal {\\n        address sender = self._msgSender();\\n        if (!_isApprovedOrOwner(self, sender, _tokenId))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        address owner = _ownerOf(self, _tokenId);\\n\\n        // Clear approval\\n        delete self.idToApprovals[_tokenId];\\n        // Update voting checkpoints\\n        self._checkpointDelegator(_tokenId, 0, address(0));\\n        // Remove token\\n        _removeTokenFrom(self, owner, _tokenId);\\n        emit IERC721.Transfer(owner, address(0), _tokenId);\\n    }\\n\\n    /// @dev Remove a NFT from a given address\\n    ///      Throws if `_from` is not the current owner.\\n    function _removeTokenFrom(\\n        VotingEscrowState.Storage storage self,\\n        address _from,\\n        uint256 _tokenId\\n    ) internal {\\n        // Throws if `_from` is not the current owner\\n        assert(_ownerOf(self, _tokenId) == _from);\\n        // Change the owner\\n        self.idToOwner[_tokenId] = address(0);\\n        // Update owner token index tracking\\n        _removeTokenFromOwnerList(self, _from, _tokenId);\\n        // Change count tracking\\n        self.ownerToNFTokenCount[_from] -= 1;\\n    }\\n\\n    /// @dev Remove a NFT from an index mapping to a given address\\n    /// @param _from address of the sender\\n    /// @param _tokenId uint ID Of the token to be removed\\n    function _removeTokenFromOwnerList(\\n        VotingEscrowState.Storage storage self,\\n        address _from,\\n        uint256 _tokenId\\n    ) internal {\\n        // Delete\\n        uint256 currentCount = self.ownerToNFTokenCount[_from] - 1;\\n        uint256 currentIndex = self.tokenToOwnerIndex[_tokenId];\\n\\n        if (currentCount == currentIndex) {\\n            // update ownerToNFTokenIdList\\n            self.ownerToNFTokenIdList[_from][currentCount] = 0;\\n            // update tokenToOwnerIndex\\n            self.tokenToOwnerIndex[_tokenId] = 0;\\n        } else {\\n            uint256 lastTokenId = self.ownerToNFTokenIdList[_from][\\n                currentCount\\n            ];\\n\\n            // Add\\n            // update ownerToNFTokenIdList\\n            self.ownerToNFTokenIdList[_from][currentIndex] = lastTokenId;\\n            // update tokenToOwnerIndex\\n            self.tokenToOwnerIndex[lastTokenId] = currentIndex;\\n\\n            // Delete\\n            // update ownerToNFTokenIdList\\n            self.ownerToNFTokenIdList[_from][currentCount] = 0;\\n            // update tokenToOwnerIndex\\n            self.tokenToOwnerIndex[_tokenId] = 0;\\n        }\\n    }\\n\\n    function tokenURI(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) external view returns (string memory) {\\n        if (_ownerOf(self, _tokenId) == address(0))\\n            revert IVotingEscrow.NonExistentToken();\\n        return IVeArtProxy(self.artProxy).tokenURI(_tokenId);\\n    }\\n}\\n\",\"keccak256\":\"0x7a4323cca513754436705ee05695f7bb951d959a1e339734f195c9999d2bcc56\",\"license\":\"BUSL-1.1\"},\"contracts/ve/VeERC2771Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Based on openzeppelin-contracts/contracts/metatx/ERC2771Context.sol\\n\\npragma solidity 0.8.24;\\n\\nimport {VotingEscrowState} from \\\"./VotingEscrowState.sol\\\";\\n\\n/**\\n * @dev Context variant with ERC2771 support. Extracted to library to allow\\n *      easy application inside libraries.\\n */\\nlibrary VeERC2771Context {\\n    function isTrustedForwarder(\\n        VotingEscrowState.Storage storage self,\\n        address forwarder\\n    ) internal view returns (bool) {\\n        return forwarder == self.trustedForwarder;\\n    }\\n\\n    function _msgSender(\\n        VotingEscrowState.Storage storage self\\n    ) internal view returns (address sender) {\\n        if (isTrustedForwarder(self, msg.sender)) {\\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n        } else {\\n            return msg.sender;\\n        }\\n    }\\n\\n    function _msgData(\\n        VotingEscrowState.Storage storage self\\n    ) internal view returns (bytes calldata) {\\n        if (isTrustedForwarder(self, msg.sender)) {\\n            return msg.data[:msg.data.length - 20];\\n        } else {\\n            return msg.data;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xad2e32f0921a55dc07d8ecac879666cdba7828ef54889a32c0f53bbc431170f0\",\"license\":\"MIT\"},\"contracts/ve/VotingEscrowState.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.24;\\n\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport {VeERC2771Context} from \\\"./VeERC2771Context.sol\\\";\\nimport {IERC4906} from \\\"@openzeppelin/contracts/interfaces/IERC4906.sol\\\";\\n\\nlibrary VotingEscrowState {\\n    using VeERC2771Context for Storage;\\n\\n    struct Storage {\\n        /// @dev Address of Meta-tx Forwarder\\n        address trustedForwarder;\\n        /// @dev Address of FactoryRegistry.sol\\n        address factoryRegistry;\\n        /// @dev Address of token used to create a veNFT\\n        address token;\\n        /// @dev Address of RewardsDistributor.sol\\n        address distributor;\\n        /// @dev Address of Voter.sol\\n        address voter;\\n        /// @dev Address of Protocol Team multisig\\n        address team;\\n        /// @dev Address of art proxy used for on-chain art generation\\n        address artProxy;\\n        /// @dev Address which can create managed NFTs\\n        address allowedManager;\\n        /// @dev Global point history at a given index (epoch -> unsigned global point)\\n        mapping(uint256 => IVotingEscrow.GlobalPoint) _pointHistory;\\n        /// @dev Mapping of interface id to bool about whether or not it's supported\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        /// @dev Current count of token\\n        uint256 tokenId;\\n        /*///////////////////////////////////////////////////////////////\\n                                MANAGED NFT\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Mapping of token id to escrow type\\n        ///      Takes advantage of the fact default value is EscrowType.NORMAL\\n        mapping(uint256 => IVotingEscrow.EscrowType) escrowType;\\n        /// @dev Mapping of token id to managed id\\n        mapping(uint256 => uint256) idToManaged;\\n        /// @dev Mapping of user token id to managed token id to weight of token id\\n        mapping(uint256 => mapping(uint256 => uint256)) weights;\\n        /// @dev Mapping of managed id to deactivated state\\n        mapping(uint256 => bool) deactivated;\\n        /// @dev Mapping from managed nft id to locked managed rewards\\n        ///      `token` denominated rewards (rebases/rewards) stored in locked\\n        ///      managed rewards contract to prevent co-mingling of assets\\n        mapping(uint256 => address) managedToLocked;\\n        /// @dev Mapping from managed nft id to free managed rewards contract\\n        ///      these rewards can be freely withdrawn by users\\n        mapping(uint256 => address) managedToFree;\\n        /*//////////////////////////////////////////////////////////////\\n                            ERC721 BALANCE/OWNER\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Mapping from NFT ID to the address that owns it.\\n        mapping(uint256 => address) idToOwner;\\n        /// @dev Mapping from owner address to count of his tokens.\\n        mapping(address => uint256) ownerToNFTokenCount;\\n        /*//////////////////////////////////////////////////////////////\\n                                ERC721 APPROVAL\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Mapping from NFT ID to approved address.\\n        mapping(uint256 => address) idToApprovals;\\n        /// @dev Mapping from owner address to mapping of operator addresses.\\n        mapping(address => mapping(address => bool)) ownerToOperators;\\n        mapping(uint256 => uint256) ownershipChange;\\n        /*//////////////////////////////////////////////////////////////\\n                            INTERNAL MINT/BURN\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Mapping from owner address to mapping of index to tokenId\\n        mapping(address => mapping(uint256 => uint256)) ownerToNFTokenIdList;\\n        /// @dev Mapping from NFT ID to index of owner\\n        mapping(uint256 => uint256) tokenToOwnerIndex;\\n        /*//////////////////////////////////////////////////////////////\\n                                    ESCROW\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Total count of epochs witnessed since contract creation\\n        uint256 epoch;\\n        /// @dev Total amount of token() deposited\\n        uint256 supply;\\n        mapping(uint256 => IVotingEscrow.LockedBalance) _locked;\\n        mapping(uint256 => IVotingEscrow.UserPoint[1000000000]) _userPointHistory;\\n        mapping(uint256 => uint256) userPointEpoch;\\n        /// @dev time -> signed slope change\\n        mapping(uint256 => int128) slopeChanges;\\n        /// @dev account -> can split\\n        mapping(address => bool) canSplit;\\n        /// @dev Aggregate permanent locked balances\\n        uint256 permanentLockBalance;\\n        /*///////////////////////////////////////////////////////////////\\n                                    DAO VOTING\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev A record of each accounts delegate\\n        mapping(uint256 => uint256) _delegates;\\n        /// @dev A record of delegated token checkpoints for each tokenId, by index\\n        mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint)) _checkpoints;\\n        /// @dev The number of checkpoints for each tokenId\\n        mapping(uint256 => uint48) numCheckpoints;\\n        /// @dev A record of states for signing / validating signatures\\n        mapping(address => uint256) nonces;\\n        /*///////////////////////////////////////////////////////////////\\n                                GAUGE VOTING\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Information on whether a tokenId has already voted\\n        mapping(uint256 => bool) voted;\\n        // Reserved storage space in case we need to add more variables.\\n        // The convention from OpenZeppelin suggests the storage space should\\n        // add up to 50 slots. Here we want to have more slots as there are\\n        // planned upgrades of the VotingEscrow contract. If more entires are\\n        // added to the struct in the upcoming versions we need to reduce\\n        // the array size.\\n        // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n        uint256[50] __gap;\\n    }\\n\\n    function setTeam(\\n        VotingEscrowState.Storage storage self,\\n        address _team\\n    ) internal {\\n        if (self._msgSender() != self.team) revert IVotingEscrow.NotTeam();\\n        if (_team == address(0)) revert IVotingEscrow.ZeroAddress();\\n        self.team = _team;\\n    }\\n\\n    function setArtProxy(\\n        VotingEscrowState.Storage storage self,\\n        address _proxy\\n    ) internal {\\n        if (self._msgSender() != self.team) revert IVotingEscrow.NotTeam();\\n        self.artProxy = _proxy;\\n        emit IERC4906.BatchMetadataUpdate(0, type(uint256).max);\\n    }\\n\\n    function setVoterAndDistributor(\\n        VotingEscrowState.Storage storage self,\\n        address _voter,\\n        address _distributor\\n    ) internal {\\n        if (self._msgSender() != self.voter) revert IVotingEscrow.NotVoter();\\n        self.voter = _voter;\\n        self.distributor = _distributor;\\n    }\\n\\n    function setVoting(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        bool _voted\\n    ) internal {\\n        if (self._msgSender() != self.voter) revert IVotingEscrow.NotVoter();\\n        self.voted[_tokenId] = _voted;\\n    }\\n}\\n\",\"keccak256\":\"0x2779dbcc92093ce9bd9b258c166f9af0d24383116150f66f80d25223a028a1d3\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x6110fd61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100615760003560e01c806320606b70146100665780636cdf6b591461009f578063a82f1e55146100b2578063e7a324dc146100d4578063fe58a054146100fb575b600080fd5b61008d7f8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a86681565b60405190815260200160405180910390f35b61008d6100ad366004610e58565b61011b565b8180156100be57600080fd5b506100d26100cd366004610ea1565b610256565b005b61008d7f9947d5709c1682eaa3946b2d84115c9c0d1c946b149d76e69b457458b42ea29e81565b81801561010757600080fd5b506100d2610116366004610f16565b610297565b600080610129868585610568565b6000858152602188016020908152604080832065ffffffffffff851684528252918290208251608081018452815480825260018301546001600160a01b0316938201939093526002820154938101939093526003015460608301529192509084101561019a5760009250505061024e565b80602001516001600160a01b0316866001600160a01b0316146101c25760009250505061024e565b60408101516060820151156101d75780610248565b604051637028a55d60e11b81526004810187905260248101869052309063e0514aba90604401602060405180830381865afa15801561021a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061023e9190610faf565b6102489082610fde565b93505050505b949350505050565b61026a610262846106c6565b8490846106ec565b6102875760405163390cdd9b60e21b815260040160405180910390fd5b61029283838361075c565b505050565b6fa2a8918ca85bafe22016d0b997e4df60600160ff1b0360c086013511156102d2576040516317e97eb760e31b815260040160405180910390fd5b60007f8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a8668585604051610305929190610ff1565b6040518091039020848460405161031d929190610ff1565b60408051918290038220602083019490945281019190915260608101919091524660808201523060a082015260c00160408051808303601f1901815282825280516020918201207f9947d5709c1682eaa3946b2d84115c9c0d1c946b149d76e69b457458b42ea29e82850152893584840152908901356060808501919091529189013560808401529088013560a0830152915060009060c001604051602081830303815290604052805190602001209050600082826040516020016103f992919061190160f01b81526002810192909252602282015260420190565b60408051601f1981840301815291905280516020909101209050600060018261042860a08c0160808d01611001565b6040805160008152602081018083529390935260ff9091169082015260a0808c0135606083015260c08c01356080830152016020604051602081039080840390855afa15801561047c573d6000803e3d6000fd5b5050604051601f190151915061049690508a828b356106ec565b6104b35760405163390cdd9b60e21b815260040160405180910390fd5b6001600160a01b0381166104da57604051638baa579f60e01b815260040160405180910390fd5b6001600160a01b038116600090815260238b016020526040812080549161050083611024565b9190505589604001351461052757604051633ab3447f60e11b815260040160405180910390fd5b886060013542111561054c57604051630819bdcd60e01b815260040160405180910390fd5b61055c8a8a3560208c013561075c565b50505050505050505050565b600082815260228401602052604081205465ffffffffffff168082036105925760009150506106bf565b6000848152602186016020526040812084916105af60018561103d565b65ffffffffffff168152602081019190915260400160002054116105e0576105d860018261103d565b9150506106bf565b6000848152602186016020908152604080832083805290915290205483101561060d5760009150506106bf565b60008061061b60018461103d565b90505b8165ffffffffffff168165ffffffffffff1611156106ba5760006002610644848461103d565b61064e919061105c565b610658908361103d565b600088815260218a016020908152604080832065ffffffffffff851684529091529020805491925090879003610694575093506106bf92505050565b80548711156106a5578193506106b3565b6106b060018361103d565b92505b505061061e565b509150505b9392505050565b60006106d282336108d1565b156106e557505036601319013560601c90565b5033919050565b6000806106f985846108e8565b60008481526013870160209081526040808320546001600160a01b0380861680865260148c018552838620828c1680885295529290942054949550908214939216149060ff1682806107485750815b806107505750805b98975050505050505050565b6000828152601a8401602090815260409182902082516060810184528154600f0b81526001820154928101929092526002015460ff161515918101829052906107b857604051632188f8ab60e01b815260040160405180910390fd5b81158015906107d9575060006107ce85846108e8565b6001600160a01b0316145b156107f757604051634a1850bf60e11b815260040160405180910390fd5b6000838152601585016020526040902054439003610828576040516342d6fce760e01b815260040160405180910390fd5b82820361083457600091505b6000838152602080860190526040902054828103610853575050505050565b60006108658360000151600f0b610907565b905061087c86868661087783836108e8565b610933565b6108898685836001610bb2565b8382610894886106c6565b6001600160a01b03167ff1aa2a9e40138176a3ee6099df056f5c175f8511a0d8b8275d94d1ea5de4677360405160405180910390a4505050505050565b81546001600160a01b038281169116145b92915050565b600090815260119190910160205260409020546001600160a01b031690565b60008082600f0b121561092c5760405162406f5d60e21b815260040160405180910390fd5b50600f0b90565b6000838152601a8501602052604081205461095090600f0b610907565b600085815260228701602052604081205491925065ffffffffffff9091169081610994576000868152602188016020908152604080832083805290915290206109cf565b60008681526021880160205260408120906109b060018561103d565b65ffffffffffff1665ffffffffffff1681526020019081526020016000205b90506109e2878260030154856000610bb2565b6000868152602188016020908152604080832065ffffffffffff86168452909152902042815560028281015490820155600381018690556001810180546001600160a01b0319166001600160a01b038716179055610a408888610ddd565b15610a915760008781526022890160205260408120805465ffffffffffff1691610a698361108f565b91906101000a81548165ffffffffffff021916908365ffffffffffff16021790555050610b99565b600087815260218901602052604081208291610aae60018761103d565b65ffffffffffff1665ffffffffffff168152602001908152602001600020600082015481600001556001820160009054906101000a90046001600160a01b03168160010160006101000a8154816001600160a01b0302191690836001600160a01b03160217905550600282015481600201556003820154816003015590505087602101600088815260200190815260200160002060008465ffffffffffff1665ffffffffffff1681526020019081526020016000206000808201600090556001820160006101000a8154906001600160a01b0302191690556002820160009055600382016000905550505b5050506000938452505060209283019092526040902055565b8215610dd757600083815260228501602052604081205465ffffffffffff169081610bf757600085815260218701602090815260408083208380529091529020610c32565b6000858152602187016020526040812090610c1360018561103d565b65ffffffffffff1665ffffffffffff1681526020019081526020016000205b6000868152602188016020908152604080832065ffffffffffff87168452909152902042815560018083015490820180546001600160a01b0319166001600160a01b0390921691909117905590915083610cad5781600201548510610c98576000610cbd565b848260020154610ca891906110b4565b610cbd565b848260020154610cbd9190610fde565b600282015560038083015490820155610cd68787610ddd565b15610d275760008681526022880160205260408120805465ffffffffffff1691610cff8361108f565b91906101000a81548165ffffffffffff021916908365ffffffffffff16021790555050610dd3565b600086815260218801602052604081208291610d4460018761103d565b65ffffffffffff9081168252602080830193909352604091820160009081208554815560018087015481830180546001600160a01b039092166001600160a01b031992831617905560028089015481850155600398890154938901939093558d845260218f018752858420948b1684529390955292812081815593840180549092169091559082018190559101555b5050505b50505050565b600081815260228301602052604081205465ffffffffffff168015801590610e385750600083815260218501602052604081204291610e1d60018561103d565b65ffffffffffff168152602081019190915260400160002054145b15610e475760009150506108e2565b60019150506108e2565b5092915050565b60008060008060808587031215610e6e57600080fd5b8435935060208501356001600160a01b0381168114610e8c57600080fd5b93969395505050506040820135916060013590565b600080600060608486031215610eb657600080fd5b505081359360208301359350604090920135919050565b60008083601f840112610edf57600080fd5b50813567ffffffffffffffff811115610ef757600080fd5b602083019150836020828501011115610f0f57600080fd5b9250929050565b600080600080600080868803610140811215610f3157600080fd5b8735965060e0601f1982011215610f4757600080fd5b5060208701945061010087013567ffffffffffffffff80821115610f6a57600080fd5b610f768a838b01610ecd565b9096509450610120890135915080821115610f9057600080fd5b50610f9d89828a01610ecd565b979a9699509497509295939492505050565b600060208284031215610fc157600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b808201808211156108e2576108e2610fc8565b8183823760009101908152919050565b60006020828403121561101357600080fd5b813560ff811681146106bf57600080fd5b60006001820161103657611036610fc8565b5060010190565b65ffffffffffff828116828216039080821115610e5157610e51610fc8565b600065ffffffffffff8084168061108357634e487b7160e01b600052601260045260246000fd5b92169190910492915050565b600065ffffffffffff8083168181036110aa576110aa610fc8565b6001019392505050565b818103818111156108e2576108e2610fc856fea264697066735822122095f2a1802e23c36b5e1923fc9a46d8b8164aee85f6e8f66281fb7510bfcf3ffb64736f6c63430008180033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100615760003560e01c806320606b70146100665780636cdf6b591461009f578063a82f1e55146100b2578063e7a324dc146100d4578063fe58a054146100fb575b600080fd5b61008d7f8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a86681565b60405190815260200160405180910390f35b61008d6100ad366004610e58565b61011b565b8180156100be57600080fd5b506100d26100cd366004610ea1565b610256565b005b61008d7f9947d5709c1682eaa3946b2d84115c9c0d1c946b149d76e69b457458b42ea29e81565b81801561010757600080fd5b506100d2610116366004610f16565b610297565b600080610129868585610568565b6000858152602188016020908152604080832065ffffffffffff851684528252918290208251608081018452815480825260018301546001600160a01b0316938201939093526002820154938101939093526003015460608301529192509084101561019a5760009250505061024e565b80602001516001600160a01b0316866001600160a01b0316146101c25760009250505061024e565b60408101516060820151156101d75780610248565b604051637028a55d60e11b81526004810187905260248101869052309063e0514aba90604401602060405180830381865afa15801561021a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061023e9190610faf565b6102489082610fde565b93505050505b949350505050565b61026a610262846106c6565b8490846106ec565b6102875760405163390cdd9b60e21b815260040160405180910390fd5b61029283838361075c565b505050565b6fa2a8918ca85bafe22016d0b997e4df60600160ff1b0360c086013511156102d2576040516317e97eb760e31b815260040160405180910390fd5b60007f8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a8668585604051610305929190610ff1565b6040518091039020848460405161031d929190610ff1565b60408051918290038220602083019490945281019190915260608101919091524660808201523060a082015260c00160408051808303601f1901815282825280516020918201207f9947d5709c1682eaa3946b2d84115c9c0d1c946b149d76e69b457458b42ea29e82850152893584840152908901356060808501919091529189013560808401529088013560a0830152915060009060c001604051602081830303815290604052805190602001209050600082826040516020016103f992919061190160f01b81526002810192909252602282015260420190565b60408051601f1981840301815291905280516020909101209050600060018261042860a08c0160808d01611001565b6040805160008152602081018083529390935260ff9091169082015260a0808c0135606083015260c08c01356080830152016020604051602081039080840390855afa15801561047c573d6000803e3d6000fd5b5050604051601f190151915061049690508a828b356106ec565b6104b35760405163390cdd9b60e21b815260040160405180910390fd5b6001600160a01b0381166104da57604051638baa579f60e01b815260040160405180910390fd5b6001600160a01b038116600090815260238b016020526040812080549161050083611024565b9190505589604001351461052757604051633ab3447f60e11b815260040160405180910390fd5b886060013542111561054c57604051630819bdcd60e01b815260040160405180910390fd5b61055c8a8a3560208c013561075c565b50505050505050505050565b600082815260228401602052604081205465ffffffffffff168082036105925760009150506106bf565b6000848152602186016020526040812084916105af60018561103d565b65ffffffffffff168152602081019190915260400160002054116105e0576105d860018261103d565b9150506106bf565b6000848152602186016020908152604080832083805290915290205483101561060d5760009150506106bf565b60008061061b60018461103d565b90505b8165ffffffffffff168165ffffffffffff1611156106ba5760006002610644848461103d565b61064e919061105c565b610658908361103d565b600088815260218a016020908152604080832065ffffffffffff851684529091529020805491925090879003610694575093506106bf92505050565b80548711156106a5578193506106b3565b6106b060018361103d565b92505b505061061e565b509150505b9392505050565b60006106d282336108d1565b156106e557505036601319013560601c90565b5033919050565b6000806106f985846108e8565b60008481526013870160209081526040808320546001600160a01b0380861680865260148c018552838620828c1680885295529290942054949550908214939216149060ff1682806107485750815b806107505750805b98975050505050505050565b6000828152601a8401602090815260409182902082516060810184528154600f0b81526001820154928101929092526002015460ff161515918101829052906107b857604051632188f8ab60e01b815260040160405180910390fd5b81158015906107d9575060006107ce85846108e8565b6001600160a01b0316145b156107f757604051634a1850bf60e11b815260040160405180910390fd5b6000838152601585016020526040902054439003610828576040516342d6fce760e01b815260040160405180910390fd5b82820361083457600091505b6000838152602080860190526040902054828103610853575050505050565b60006108658360000151600f0b610907565b905061087c86868661087783836108e8565b610933565b6108898685836001610bb2565b8382610894886106c6565b6001600160a01b03167ff1aa2a9e40138176a3ee6099df056f5c175f8511a0d8b8275d94d1ea5de4677360405160405180910390a4505050505050565b81546001600160a01b038281169116145b92915050565b600090815260119190910160205260409020546001600160a01b031690565b60008082600f0b121561092c5760405162406f5d60e21b815260040160405180910390fd5b50600f0b90565b6000838152601a8501602052604081205461095090600f0b610907565b600085815260228701602052604081205491925065ffffffffffff9091169081610994576000868152602188016020908152604080832083805290915290206109cf565b60008681526021880160205260408120906109b060018561103d565b65ffffffffffff1665ffffffffffff1681526020019081526020016000205b90506109e2878260030154856000610bb2565b6000868152602188016020908152604080832065ffffffffffff86168452909152902042815560028281015490820155600381018690556001810180546001600160a01b0319166001600160a01b038716179055610a408888610ddd565b15610a915760008781526022890160205260408120805465ffffffffffff1691610a698361108f565b91906101000a81548165ffffffffffff021916908365ffffffffffff16021790555050610b99565b600087815260218901602052604081208291610aae60018761103d565b65ffffffffffff1665ffffffffffff168152602001908152602001600020600082015481600001556001820160009054906101000a90046001600160a01b03168160010160006101000a8154816001600160a01b0302191690836001600160a01b03160217905550600282015481600201556003820154816003015590505087602101600088815260200190815260200160002060008465ffffffffffff1665ffffffffffff1681526020019081526020016000206000808201600090556001820160006101000a8154906001600160a01b0302191690556002820160009055600382016000905550505b5050506000938452505060209283019092526040902055565b8215610dd757600083815260228501602052604081205465ffffffffffff169081610bf757600085815260218701602090815260408083208380529091529020610c32565b6000858152602187016020526040812090610c1360018561103d565b65ffffffffffff1665ffffffffffff1681526020019081526020016000205b6000868152602188016020908152604080832065ffffffffffff87168452909152902042815560018083015490820180546001600160a01b0319166001600160a01b0390921691909117905590915083610cad5781600201548510610c98576000610cbd565b848260020154610ca891906110b4565b610cbd565b848260020154610cbd9190610fde565b600282015560038083015490820155610cd68787610ddd565b15610d275760008681526022880160205260408120805465ffffffffffff1691610cff8361108f565b91906101000a81548165ffffffffffff021916908365ffffffffffff16021790555050610dd3565b600086815260218801602052604081208291610d4460018761103d565b65ffffffffffff9081168252602080830193909352604091820160009081208554815560018087015481830180546001600160a01b039092166001600160a01b031992831617905560028089015481850155600398890154938901939093558d845260218f018752858420948b1684529390955292812081815593840180549092169091559082018190559101555b5050505b50505050565b600081815260228301602052604081205465ffffffffffff168015801590610e385750600083815260218501602052604081204291610e1d60018561103d565b65ffffffffffff168152602081019190915260400160002054145b15610e475760009150506108e2565b60019150506108e2565b5092915050565b60008060008060808587031215610e6e57600080fd5b8435935060208501356001600160a01b0381168114610e8c57600080fd5b93969395505050506040820135916060013590565b600080600060608486031215610eb657600080fd5b505081359360208301359350604090920135919050565b60008083601f840112610edf57600080fd5b50813567ffffffffffffffff811115610ef757600080fd5b602083019150836020828501011115610f0f57600080fd5b9250929050565b600080600080600080868803610140811215610f3157600080fd5b8735965060e0601f1982011215610f4757600080fd5b5060208701945061010087013567ffffffffffffffff80821115610f6a57600080fd5b610f768a838b01610ecd565b9096509450610120890135915080821115610f9057600080fd5b50610f9d89828a01610ecd565b979a9699509497509295939492505050565b600060208284031215610fc157600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b808201808211156108e2576108e2610fc8565b8183823760009101908152919050565b60006020828403121561101357600080fd5b813560ff811681146106bf57600080fd5b60006001820161103657611036610fc8565b5060010190565b65ffffffffffff828116828216039080821115610e5157610e51610fc8565b600065ffffffffffff8084168061108357634e487b7160e01b600052601260045260246000fd5b92169190910492915050565b600065ffffffffffff8083168181036110aa576110aa610fc8565b6001019392505050565b818103818111156108e2576108e2610fc856fea264697066735822122095f2a1802e23c36b5e1923fc9a46d8b8164aee85f6e8f66281fb7510bfcf3ffb64736f6c63430008180033",
  "devdoc": {
    "events": {
      "DelegateChanged(address,uint256,uint256)": {
        "details": "Emitted when an account changes their delegate."
      }
    },
    "kind": "dev",
    "methods": {
      "getPastVotes(VotingEscrowState.Storage storage,address,uint256,uint256)": {
        "details": "If a checkpoint does not exist prior to the timestamp, this will return 0.      The user must also own the token at the time in order to receive a voting balance.",
        "params": {
          "_account": ".",
          "_timestamp": ".",
          "_tokenId": "."
        },
        "returns": {
          "_0": "Total voting balance including delegations at a given timestamp."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "DELEGATION_TYPEHASH()": {
        "notice": "The EIP-712 typehash for the delegation struct used by the contract"
      },
      "DOMAIN_TYPEHASH()": {
        "notice": "The EIP-712 typehash for the contract's domain"
      },
      "getPastVotes(VotingEscrowState.Storage storage,address,uint256,uint256)": {
        "notice": "Retrieves historical voting balance for a token id at a given timestamp."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}