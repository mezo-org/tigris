{
  "address": "0xB2F6c5B73239c39360EE0Ea95047565dab13E3c7",
  "abi": [
    {
      "inputs": [],
      "name": "SafeCastUnderflow",
      "type": "error"
    }
  ],
  "transactionHash": "0x183d24a5c2d89dcdb308d0445be292ae13c852ae6fcec620b8fee7f462918310",
  "receipt": {
    "to": null,
    "from": "0x68ad60CC5e8f3B7cC53beaB321cf0e6036962dBc",
    "contractAddress": "0xB2F6c5B73239c39360EE0Ea95047565dab13E3c7",
    "transactionIndex": 0,
    "gasUsed": "635706",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xe2dbafeee038cdf1c8e86b3a64fe7bbdad0d2ab85b31f3d715db1d208c2fe10b",
    "transactionHash": "0x183d24a5c2d89dcdb308d0445be292ae13c852ae6fcec620b8fee7f462918310",
    "logs": [],
    "blockNumber": 2582577,
    "cumulativeGasUsed": "635706",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "1323dd419c1f876af4efeebab361c06a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"SafeCastUnderflow\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"checkpointDelegatee(mapping(uint256 => uint48) storage,mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint)) storage,uint256,uint256,bool)\":{\"details\":\"If used with `balance` == `_locked[_tokenId].amount`, then this is the same as      delegating or dedelegating from `_tokenId`      If used with `balance` < `_locked[_tokenId].amount`, then this is used to adjust      `delegatedBalance` when a user's balance is modified (e.g. `increaseAmount`, `merge` etc).      If `delegatee` is 0 (i.e. user is not delegating), then do nothing.\",\"params\":{\"_checkpoints\":\"State of all user checkpoints\",\"_delegatee\":\"The delegatee's tokenId\",\"_increase\":\"True if balance is increasing, false if decreasing\",\"_numCheckpoints\":\"State of all user checkpoint counts\",\"balance_\":\"The delta in balance change\"}},\"checkpointDelegator(mapping(uint256 => IVotingEscrow.LockedBalance) storage,mapping(uint256 => uint48) storage,mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint)) storage,mapping(uint256 => uint256) storage,uint256,uint256,address)\":{\"details\":\"This function depends on `_locked` and must be called prior to token state changes.      If you wish to dedelegate only, use `_delegate(tokenId, 0)` instead.\",\"params\":{\"_checkpoints\":\"State of all user checkpoints\",\"_delegatee\":\"The new delegatee for the delegator. Cannot be equal to `_delegator` (use 0 instead).\",\"_delegates\":\"State of all user delegatees\",\"_delegator\":\"The delegator to update checkpoints for\",\"_locked\":\"State of all locked balances\",\"_numCheckpoints\":\"State of all user checkpoint counts\",\"_owner\":\"The new (or current) owner for the delegator\"}},\"getPastVotes(mapping(uint256 => uint48) storage,mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint)) storage,address,uint256,uint256)\":{\"details\":\"If a checkpoint does not exist prior to the timestamp, this will return 0.      The user must also own the token at the time in order to receive a voting balance.\",\"params\":{\"_account\":\".\",\"_checkpoints\":\"State of all user checkpoints\",\"_numCheckpoints\":\"State of all user checkpoint counts\",\"_timestamp\":\".\",\"_tokenId\":\".\"},\"returns\":{\"_0\":\"Total voting balance including delegations at a given timestamp.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"checkpointDelegatee(mapping(uint256 => uint48) storage,mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint)) storage,uint256,uint256,bool)\":{\"notice\":\"Update delegatee's `delegatedBalance` by `balance`.         Only updates if delegating to a new delegatee.\"},\"checkpointDelegator(mapping(uint256 => IVotingEscrow.LockedBalance) storage,mapping(uint256 => uint48) storage,mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint)) storage,mapping(uint256 => uint256) storage,uint256,uint256,address)\":{\"notice\":\"Used by `_mint`, `_transferFrom`, `_burn` and `delegate`         to update delegator voting checkpoints.         Automatically dedelegates, then updates checkpoint.\"},\"getPastVotes(mapping(uint256 => uint48) storage,mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint)) storage,address,uint256,uint256)\":{\"notice\":\"Retrieves historical voting balance for a token id at a given timestamp.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libraries/DelegationLogicLibrary.sol\":\"DelegationLogicLibrary\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\",\"keccak256\":\"0xd04b0f06e0666f29cf7cccc82894de541e19bb30a765b107b1e40bb7fe5f7d7a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC4906.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4906.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\n\\n/// @title EIP-721 Metadata Update Extension\\ninterface IERC4906 is IERC165, IERC721 {\\n    /// @dev This event emits when the metadata of a token is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFT.\\n    event MetadataUpdate(uint256 _tokenId);\\n\\n    /// @dev This event emits when the metadata of a range of tokens is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFTs.\\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\\n}\\n\",\"keccak256\":\"0x2a9dadb806be80dd451821f1f1190eb9aa6f6edae85b185db29d60767cc0c5f4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC6372.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC6372 {\\n    /**\\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\\n     */\\n    function clock() external view returns (uint48);\\n\\n    /**\\n     * @dev Description of the clock\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function CLOCK_MODE() external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xcaea9aeda3816ba872358c828f4f01455c22ae48ced49c4c7d72bd74176c09b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721.sol\\\";\\n\",\"keccak256\":\"0xaf297d12d8d4a57fe01a70f0ef38908f208e3faedc577056d0b728fa2f3ccf0c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/governance/IVotes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// Modified IVotes interface for tokenId based voting\\ninterface IVotes {\\n    /**\\n     * @dev Emitted when an account changes their delegate.\\n     */\\n    event DelegateChanged(\\n        address indexed delegator,\\n        uint256 indexed fromDelegate,\\n        uint256 indexed toDelegate\\n    );\\n\\n    /**\\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\\n     */\\n    event DelegateVotesChanged(\\n        address indexed delegate,\\n        uint256 previousBalance,\\n        uint256 newBalance\\n    );\\n\\n    /**\\n     * @dev Returns the amount of votes that `tokenId` had at a specific moment in the past.\\n     *      If the account passed in is not the owner, returns 0.\\n     */\\n    function getPastVotes(\\n        address account,\\n        uint256 tokenId,\\n        uint256 timepoint\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\\n     * configured to use block numbers, this will return the value the end of the corresponding block.\\n     *\\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\\n     * vote.\\n     */\\n    function getPastTotalSupply(\\n        uint256 timepoint\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the delegate that `tokenId` has chosen. Can never be equal to the delegator's `tokenId`.\\n     *      Returns 0 if not delegated.\\n     */\\n    function delegates(uint256 tokenId) external view returns (uint256);\\n\\n    /**\\n     * @dev Delegates votes from the sender to `delegatee`.\\n     */\\n    function delegate(uint256 delegator, uint256 delegatee) external;\\n\\n    /**\\n     * @dev Delegates votes from `delegator` to `delegatee`. Signer must own `delegator`.\\n     */\\n    function delegateBySig(\\n        uint256 delegator,\\n        uint256 delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\",\"keccak256\":\"0xb4886474bc559202c8004ffba54c1d11dd14c3bbbc3a107bd522cc0f99b2ba7e\",\"license\":\"MIT\"},\"contracts/interfaces/IVotingEscrow.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IERC165, IERC721, IERC721Metadata} from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\nimport {IERC6372} from \\\"@openzeppelin/contracts/interfaces/IERC6372.sol\\\";\\nimport {IERC4906} from \\\"@openzeppelin/contracts/interfaces/IERC4906.sol\\\";\\nimport {IVotes} from \\\"../governance/IVotes.sol\\\";\\n\\ninterface IVotingEscrow is IVotes, IERC4906, IERC6372, IERC721Metadata {\\n    struct LockedBalance {\\n        int128 amount;\\n        uint256 end;\\n        bool isPermanent;\\n    }\\n\\n    struct UserPoint {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint256 ts;\\n        uint256 blk; // block\\n        uint256 permanent;\\n    }\\n\\n    struct GlobalPoint {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint256 ts;\\n        uint256 blk; // block\\n        uint256 permanentLockBalance;\\n    }\\n\\n    /// @notice A checkpoint for recorded delegated voting weights at a certain timestamp\\n    struct Checkpoint {\\n        uint256 fromTimestamp;\\n        address owner;\\n        uint256 delegatedBalance;\\n        uint256 delegatee;\\n    }\\n\\n    enum DepositType {\\n        DEPOSIT_FOR_TYPE,\\n        CREATE_LOCK_TYPE,\\n        INCREASE_LOCK_AMOUNT,\\n        INCREASE_UNLOCK_TIME\\n    }\\n\\n    /// @dev Different types of veNFTs:\\n    /// NORMAL  - typical veNFT\\n    /// LOCKED  - veNFT which is locked into a MANAGED veNFT\\n    /// MANAGED - veNFT which can accept the deposit of NORMAL veNFTs\\n    enum EscrowType {\\n        NORMAL,\\n        LOCKED,\\n        MANAGED\\n    }\\n\\n    error AlreadyVoted();\\n    error AmountTooBig();\\n    error ERC721ReceiverRejectedTokens();\\n    error ERC721TransferToNonERC721ReceiverImplementer();\\n    error InvalidNonce();\\n    error InvalidSignature();\\n    error InvalidSignatureS();\\n    error InvalidManagedNFTId();\\n    error LockDurationNotInFuture();\\n    error LockDurationTooLong();\\n    error LockExpired();\\n    error LockNotExpired();\\n    error NoLockFound();\\n    error NonExistentToken();\\n    error NotApprovedOrOwner();\\n    error NotDistributor();\\n    error NotEmergencyCouncilOrGovernor();\\n    error NotGovernor();\\n    error NotGovernorOrManager();\\n    error NotManagedNFT();\\n    error NotManagedOrNormalNFT();\\n    error NotLockedNFT();\\n    error NotNormalNFT();\\n    error NotPermanentLock();\\n    error NotOwner();\\n    error NotTeam();\\n    error NotVoter();\\n    error OwnershipChange();\\n    error PermanentLock();\\n    error SameAddress();\\n    error SameNFT();\\n    error SameState();\\n    error SplitNoOwner();\\n    error SplitNotAllowed();\\n    error SignatureExpired();\\n    error TooManyTokenIDs();\\n    error ZeroAddress();\\n    error ZeroAmount();\\n    error ZeroBalance();\\n\\n    event Deposit(\\n        address indexed provider,\\n        uint256 indexed tokenId,\\n        DepositType indexed depositType,\\n        uint256 value,\\n        uint256 locktime,\\n        uint256 ts\\n    );\\n    event Withdraw(\\n        address indexed provider,\\n        uint256 indexed tokenId,\\n        uint256 value,\\n        uint256 ts\\n    );\\n    event LockPermanent(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 amount,\\n        uint256 _ts\\n    );\\n    event UnlockPermanent(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 amount,\\n        uint256 _ts\\n    );\\n    event Supply(uint256 prevSupply, uint256 supply);\\n    event Merge(\\n        address indexed _sender,\\n        uint256 indexed _from,\\n        uint256 indexed _to,\\n        uint256 _amountFrom,\\n        uint256 _amountTo,\\n        uint256 _amountFinal,\\n        uint256 _locktime,\\n        uint256 _ts\\n    );\\n    event Split(\\n        uint256 indexed _from,\\n        uint256 indexed _tokenId1,\\n        uint256 indexed _tokenId2,\\n        address _sender,\\n        uint256 _splitAmount1,\\n        uint256 _splitAmount2,\\n        uint256 _locktime,\\n        uint256 _ts\\n    );\\n    event CreateManaged(\\n        address indexed _to,\\n        uint256 indexed _mTokenId,\\n        address indexed _from,\\n        address _lockedManagedReward,\\n        address _freeManagedReward\\n    );\\n    event DepositManaged(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 indexed _mTokenId,\\n        uint256 _weight,\\n        uint256 _ts\\n    );\\n    event WithdrawManaged(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 indexed _mTokenId,\\n        uint256 _weight,\\n        uint256 _ts\\n    );\\n    event SetAllowedManager(address indexed _allowedManager);\\n\\n    // State variables\\n    /// @notice Address of Meta-tx Forwarder\\n    function forwarder() external view returns (address);\\n\\n    /// @notice Address of FactoryRegistry.sol\\n    function factoryRegistry() external view returns (address);\\n\\n    /// @notice Address of token used to create a veNFT\\n    function token() external view returns (address);\\n\\n    /// @notice Address of RewardsDistributor.sol\\n    function distributor() external view returns (address);\\n\\n    /// @notice Address of Voter.sol\\n    function voter() external view returns (address);\\n\\n    /// @notice Address of Protocol Team multisig\\n    function team() external view returns (address);\\n\\n    /// @notice Address of art proxy used for on-chain art generation\\n    function artProxy() external view returns (address);\\n\\n    /// @dev address which can create managed NFTs\\n    function allowedManager() external view returns (address);\\n\\n    /// @dev Current count of token\\n    function tokenId() external view returns (uint256);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            MANAGED NFT STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Mapping of token id to escrow type\\n    ///      Takes advantage of the fact default value is EscrowType.NORMAL\\n    function escrowType(uint256 tokenId) external view returns (EscrowType);\\n\\n    /// @dev Mapping of token id to managed id\\n    function idToManaged(\\n        uint256 tokenId\\n    ) external view returns (uint256 managedTokenId);\\n\\n    /// @dev Mapping of user token id to managed token id to weight of token id\\n    function weights(\\n        uint256 tokenId,\\n        uint256 managedTokenId\\n    ) external view returns (uint256 weight);\\n\\n    /// @dev Mapping of managed id to deactivated state\\n    function deactivated(uint256 tokenId) external view returns (bool inactive);\\n\\n    /// @dev Mapping from managed nft id to locked managed rewards\\n    ///      `token` denominated rewards (rebases/rewards) stored in locked managed rewards contract\\n    ///      to prevent co-mingling of assets\\n    function managedToLocked(uint256 tokenId) external view returns (address);\\n\\n    /// @dev Mapping from managed nft id to free managed rewards contract\\n    ///      these rewards can be freely withdrawn by users\\n    function managedToFree(uint256 tokenId) external view returns (address);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            MANAGED NFT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Create managed NFT (a permanent lock) for use within ecosystem.\\n    /// @dev Throws if address already owns a managed NFT.\\n    /// @return _mTokenId managed token id.\\n    function createManagedLockFor(\\n        address _to\\n    ) external returns (uint256 _mTokenId);\\n\\n    /// @notice Delegates balance to managed nft\\n    ///         Note that NFTs deposited into a managed NFT will be re-locked\\n    ///         to the maximum lock time on withdrawal.\\n    ///         Permanent locks that are deposited will automatically unlock.\\n    /// @dev Managed nft will remain max-locked as long as there is at least one\\n    ///      deposit or withdrawal per week.\\n    ///      Throws if deposit nft is managed.\\n    ///      Throws if recipient nft is not managed.\\n    ///      Throws if deposit nft is already locked.\\n    ///      Throws if not called by voter.\\n    /// @param _tokenId tokenId of NFT being deposited\\n    /// @param _mTokenId tokenId of managed NFT that will receive the deposit\\n    function depositManaged(uint256 _tokenId, uint256 _mTokenId) external;\\n\\n    /// @notice Retrieves locked rewards and withdraws balance from managed nft.\\n    ///         Note that the NFT withdrawn is re-locked to the maximum lock time.\\n    /// @dev Throws if NFT not locked.\\n    ///      Throws if not called by voter.\\n    /// @param _tokenId tokenId of NFT being deposited.\\n    function withdrawManaged(uint256 _tokenId) external;\\n\\n    /// @notice Permit one address to call createManagedLockFor() that is not Voter.governor()\\n    function setAllowedManager(address _allowedManager) external;\\n\\n    /// @notice Set Managed NFT state. Inactive NFTs cannot be deposited into.\\n    /// @param _mTokenId managed nft state to set\\n    /// @param _state true => inactive, false => active\\n    function setManagedState(uint256 _mTokenId, bool _state) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function version() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function setTeam(address _team) external;\\n\\n    function setArtProxy(address _proxy) external;\\n\\n    /// @inheritdoc IERC721Metadata\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Mapping from owner address to mapping of index to tokenId\\n    function ownerToNFTokenIdList(\\n        address _owner,\\n        uint256 _index\\n    ) external view returns (uint256 _tokenId);\\n\\n    /// @inheritdoc IERC721\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /// @inheritdoc IERC721\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC721\\n    function getApproved(\\n        uint256 _tokenId\\n    ) external view returns (address operator);\\n\\n    /// @inheritdoc IERC721\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n\\n    /// @notice Check whether spender is owner or an approved user for a given veNFT\\n    /// @param _spender .\\n    /// @param _tokenId .\\n    function isApprovedOrOwner(\\n        address _spender,\\n        uint256 _tokenId\\n    ) external returns (bool);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC721\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /// @inheritdoc IERC721\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /// @inheritdoc IERC721\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /// @inheritdoc IERC721\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /// @inheritdoc IERC721\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(\\n        bytes4 _interfaceID\\n    ) external view returns (bool);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ESCROW STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Total count of epochs witnessed since contract creation\\n    function epoch() external view returns (uint256);\\n\\n    /// @notice Total amount of token() deposited\\n    function supply() external view returns (uint256);\\n\\n    /// @notice Aggregate permanent locked balances\\n    function permanentLockBalance() external view returns (uint256);\\n\\n    function userPointEpoch(\\n        uint256 _tokenId\\n    ) external view returns (uint256 _epoch);\\n\\n    /// @notice time -> signed slope change\\n    function slopeChanges(uint256 _timestamp) external view returns (int128);\\n\\n    /// @notice account -> can split\\n    function canSplit(address _account) external view returns (bool);\\n\\n    /// @notice Global point history at a given index\\n    function pointHistory(\\n        uint256 _loc\\n    ) external view returns (GlobalPoint memory);\\n\\n    /// @notice Get the LockedBalance (amount, end) of a _tokenId\\n    /// @param _tokenId .\\n    /// @return LockedBalance of _tokenId\\n    function locked(\\n        uint256 _tokenId\\n    ) external view returns (LockedBalance memory);\\n\\n    /// @notice User -> UserPoint[userEpoch]\\n    function userPointHistory(\\n        uint256 _tokenId,\\n        uint256 _loc\\n    ) external view returns (UserPoint memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ESCROW LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Record global data to checkpoint\\n    function checkpoint() external;\\n\\n    /// @notice Deposit `_value` tokens for `_tokenId` and add to the lock\\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\\n    ///      cannot extend their locktime and deposit for a brand new user\\n    /// @param _tokenId lock NFT\\n    /// @param _value Amount to add to user's lock\\n    function depositFor(uint256 _tokenId, uint256 _value) external;\\n\\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lockDuration`\\n    /// @param _value Amount to deposit\\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\\n    /// @return TokenId of created veNFT\\n    function createLock(\\n        uint256 _value,\\n        uint256 _lockDuration\\n    ) external returns (uint256);\\n\\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lockDuration`\\n    /// @param _value Amount to deposit\\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\\n    /// @param _to Address to deposit\\n    /// @return TokenId of created veNFT\\n    function createLockFor(\\n        uint256 _value,\\n        uint256 _lockDuration,\\n        address _to\\n    ) external returns (uint256);\\n\\n    /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\\n    /// @param _value Amount of tokens to deposit and add to the lock\\n    function increaseAmount(uint256 _tokenId, uint256 _value) external;\\n\\n    /// @notice Extend the unlock time for `_tokenId`\\n    ///         Cannot extend lock time of permanent locks\\n    /// @param _lockDuration New number of seconds until tokens unlock\\n    function increaseUnlockTime(\\n        uint256 _tokenId,\\n        uint256 _lockDuration\\n    ) external;\\n\\n    /// @notice Withdraw all tokens for `_tokenId`\\n    /// @dev Only possible if the lock is both expired and not permanent\\n    ///      This will burn the veNFT. Any rebases or rewards that are unclaimed\\n    ///      will no longer be claimable. Claim all rebases and rewards prior to calling this.\\n    function withdraw(uint256 _tokenId) external;\\n\\n    /// @notice Merges `_from` into `_to`.\\n    /// @dev Cannot merge `_from` locks that are permanent or have already voted this epoch.\\n    ///      Cannot merge `_to` locks that have already expired.\\n    ///      This will burn the veNFT. Any rebases or rewards that are unclaimed\\n    ///      will no longer be claimable. Claim all rebases and rewards prior to calling this.\\n    /// @param _from VeNFT to merge from.\\n    /// @param _to VeNFT to merge into.\\n    function merge(uint256 _from, uint256 _to) external;\\n\\n    /// @notice Splits veNFT into two new veNFTS - one with oldLocked.amount - `_amount`, and the second with `_amount`\\n    /// @dev    This burns the tokenId of the target veNFT\\n    ///         Callable by approved or owner\\n    ///         If this is called by approved, approved will not have permissions to manipulate the newly created veNFTs\\n    ///         Returns the two new split veNFTs to owner\\n    ///         If `from` is permanent, will automatically dedelegate.\\n    ///         This will burn the veNFT. Any rebases or rewards that are unclaimed\\n    ///         will no longer be claimable. Claim all rebases and rewards prior to calling this.\\n    /// @param _from VeNFT to split.\\n    /// @param _amount Amount to split from veNFT.\\n    /// @return _tokenId1 Return tokenId of veNFT with oldLocked.amount - `_amount`.\\n    /// @return _tokenId2 Return tokenId of veNFT with `_amount`.\\n    function split(\\n        uint256 _from,\\n        uint256 _amount\\n    ) external returns (uint256 _tokenId1, uint256 _tokenId2);\\n\\n    /// @notice Toggle split for a specific address.\\n    /// @dev Toggle split for address(0) to enable or disable for all.\\n    /// @param _account Address to toggle split permissions\\n    /// @param _bool True to allow, false to disallow\\n    function toggleSplit(address _account, bool _bool) external;\\n\\n    /// @notice Permanently lock a veNFT. Voting power will be equal to\\n    ///         `LockedBalance.amount` with no decay. Required to delegate.\\n    /// @dev Only callable by unlocked normal veNFTs.\\n    /// @param _tokenId tokenId to lock.\\n    function lockPermanent(uint256 _tokenId) external;\\n\\n    /// @notice Unlock a permanently locked veNFT. Voting power will decay.\\n    ///         Will automatically dedelegate if delegated.\\n    /// @dev Only callable by permanently locked veNFTs.\\n    ///      Cannot unlock if already voted this epoch.\\n    /// @param _tokenId tokenId to unlock.\\n    function unlockPermanent(uint256 _tokenId) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           GAUGE VOTING STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Get the voting power for _tokenId at the current timestamp\\n    /// @dev Returns 0 if called in the same block as a transfer.\\n    /// @param _tokenId .\\n    /// @return Voting power\\n    function balanceOfNFT(uint256 _tokenId) external view returns (uint256);\\n\\n    /// @notice Get the voting power for _tokenId at a given timestamp\\n    /// @param _tokenId .\\n    /// @param _t Timestamp to query voting power\\n    /// @return Voting power\\n    function balanceOfNFTAt(\\n        uint256 _tokenId,\\n        uint256 _t\\n    ) external view returns (uint256);\\n\\n    /// @notice Calculate total voting power at current timestamp\\n    /// @return Total voting power at current timestamp\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Calculate total voting power at a given timestamp\\n    /// @param _t Timestamp to query total voting power\\n    /// @return Total voting power at given timestamp\\n    function totalSupplyAt(uint256 _t) external view returns (uint256);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            GAUGE VOTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice See if a queried _tokenId has actively voted\\n    /// @param _tokenId .\\n    /// @return True if voted, else false\\n    function voted(uint256 _tokenId) external view returns (bool);\\n\\n    /// @notice Set the global state voter and distributor\\n    /// @dev This is only called once, at setup\\n    function setVoterAndDistributor(\\n        address _voter,\\n        address _distributor\\n    ) external;\\n\\n    /// @notice Set `voted` for _tokenId to true or false\\n    /// @dev Only callable by voter\\n    /// @param _tokenId .\\n    /// @param _voted .\\n    function voting(uint256 _tokenId, bool _voted) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            DAO VOTING STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The number of checkpoints for each tokenId\\n    function numCheckpoints(uint256 tokenId) external view returns (uint48);\\n\\n    /// @notice A record of states for signing / validating signatures\\n    function nonces(address account) external view returns (uint256);\\n\\n    /// @inheritdoc IVotes\\n    function delegates(uint256 delegator) external view returns (uint256);\\n\\n    /// @notice A record of delegated token checkpoints for each account, by index\\n    /// @param tokenId .\\n    /// @param index .\\n    /// @return Checkpoint\\n    function checkpoints(\\n        uint256 tokenId,\\n        uint48 index\\n    ) external view returns (Checkpoint memory);\\n\\n    /// @inheritdoc IVotes\\n    function getPastVotes(\\n        address account,\\n        uint256 tokenId,\\n        uint256 timestamp\\n    ) external view returns (uint256);\\n\\n    /// @inheritdoc IVotes\\n    function getPastTotalSupply(\\n        uint256 timestamp\\n    ) external view returns (uint256);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             DAO VOTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IVotes\\n    function delegate(uint256 delegator, uint256 delegatee) external;\\n\\n    /// @inheritdoc IVotes\\n    function delegateBySig(\\n        uint256 delegator,\\n        uint256 delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC6372 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC6372\\n    function clock() external view returns (uint48);\\n\\n    /// @inheritdoc IERC6372\\n    function CLOCK_MODE() external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xdacaff8d1d62d08cad34c9a67cacf016b2915ae1a1c5b74fd1b068a78ac51a48\",\"license\":\"MIT\"},\"contracts/libraries/DelegationLogicLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.24;\\n\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport {SafeCastLibrary} from \\\"./SafeCastLibrary.sol\\\";\\n\\nlibrary DelegationLogicLibrary {\\n    using SafeCastLibrary for int128;\\n\\n    /// @notice Used by `_mint`, `_transferFrom`, `_burn` and `delegate`\\n    ///         to update delegator voting checkpoints.\\n    ///         Automatically dedelegates, then updates checkpoint.\\n    /// @dev This function depends on `_locked` and must be called prior to token state changes.\\n    ///      If you wish to dedelegate only, use `_delegate(tokenId, 0)` instead.\\n    /// @param _locked State of all locked balances\\n    /// @param _numCheckpoints State of all user checkpoint counts\\n    /// @param _checkpoints State of all user checkpoints\\n    /// @param _delegates State of all user delegatees\\n    /// @param _delegator The delegator to update checkpoints for\\n    /// @param _delegatee The new delegatee for the delegator. Cannot be equal to `_delegator` (use 0 instead).\\n    /// @param _owner The new (or current) owner for the delegator\\n    function checkpointDelegator(\\n        mapping(uint256 => IVotingEscrow.LockedBalance) storage _locked,\\n        mapping(uint256 => uint48) storage _numCheckpoints,\\n        mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint))\\n            storage _checkpoints,\\n        mapping(uint256 => uint256) storage _delegates,\\n        uint256 _delegator,\\n        uint256 _delegatee,\\n        address _owner\\n    ) external {\\n        uint256 delegatedBalance = _locked[_delegator].amount.toUint256();\\n        uint48 numCheckpoint = _numCheckpoints[_delegator];\\n        IVotingEscrow.Checkpoint storage cpOld = numCheckpoint > 0\\n            ? _checkpoints[_delegator][numCheckpoint - 1]\\n            : _checkpoints[_delegator][0];\\n        // Dedelegate from delegatee if delegated\\n        checkpointDelegatee(\\n            _numCheckpoints,\\n            _checkpoints,\\n            cpOld.delegatee,\\n            delegatedBalance,\\n            false\\n        );\\n        IVotingEscrow.Checkpoint storage cp = _checkpoints[_delegator][\\n            numCheckpoint\\n        ];\\n        cp.fromTimestamp = block.timestamp;\\n        cp.delegatedBalance = cpOld.delegatedBalance;\\n        cp.delegatee = _delegatee;\\n        cp.owner = _owner;\\n\\n        if (\\n            _isCheckpointInNewBlock(_numCheckpoints, _checkpoints, _delegator)\\n        ) {\\n            _numCheckpoints[_delegator]++;\\n        } else {\\n            _checkpoints[_delegator][numCheckpoint - 1] = cp;\\n            delete _checkpoints[_delegator][numCheckpoint];\\n        }\\n\\n        _delegates[_delegator] = _delegatee;\\n    }\\n\\n    /// @notice Update delegatee's `delegatedBalance` by `balance`.\\n    ///         Only updates if delegating to a new delegatee.\\n    /// @dev If used with `balance` == `_locked[_tokenId].amount`, then this is the same as\\n    ///      delegating or dedelegating from `_tokenId`\\n    ///      If used with `balance` < `_locked[_tokenId].amount`, then this is used to adjust\\n    ///      `delegatedBalance` when a user's balance is modified (e.g. `increaseAmount`, `merge` etc).\\n    ///      If `delegatee` is 0 (i.e. user is not delegating), then do nothing.\\n    /// @param _numCheckpoints State of all user checkpoint counts\\n    /// @param _checkpoints State of all user checkpoints\\n    /// @param _delegatee The delegatee's tokenId\\n    /// @param balance_ The delta in balance change\\n    /// @param _increase True if balance is increasing, false if decreasing\\n    function checkpointDelegatee(\\n        mapping(uint256 => uint48) storage _numCheckpoints,\\n        mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint))\\n            storage _checkpoints,\\n        uint256 _delegatee,\\n        uint256 balance_,\\n        bool _increase\\n    ) public {\\n        if (_delegatee == 0) return;\\n        uint48 numCheckpoint = _numCheckpoints[_delegatee];\\n        IVotingEscrow.Checkpoint storage cpOld = numCheckpoint > 0\\n            ? _checkpoints[_delegatee][numCheckpoint - 1]\\n            : _checkpoints[_delegatee][0];\\n        IVotingEscrow.Checkpoint storage cp = _checkpoints[_delegatee][\\n            numCheckpoint\\n        ];\\n        cp.fromTimestamp = block.timestamp;\\n        cp.owner = cpOld.owner;\\n        // do not expect balance_ > cpOld.delegatedBalance when decrementing but just in case\\n        cp.delegatedBalance = _increase\\n            ? cpOld.delegatedBalance + balance_\\n            : (\\n                balance_ < cpOld.delegatedBalance\\n                    ? cpOld.delegatedBalance - balance_\\n                    : 0\\n            );\\n        cp.delegatee = cpOld.delegatee;\\n\\n        if (\\n            _isCheckpointInNewBlock(_numCheckpoints, _checkpoints, _delegatee)\\n        ) {\\n            _numCheckpoints[_delegatee]++;\\n        } else {\\n            _checkpoints[_delegatee][numCheckpoint - 1] = cp;\\n            delete _checkpoints[_delegatee][numCheckpoint];\\n        }\\n    }\\n\\n    function _isCheckpointInNewBlock(\\n        mapping(uint256 => uint48) storage _numCheckpoints,\\n        mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint))\\n            storage _checkpoints,\\n        uint256 _tokenId\\n    ) internal view returns (bool) {\\n        uint48 _nCheckPoints = _numCheckpoints[_tokenId];\\n\\n        if (\\n            _nCheckPoints > 0 &&\\n            _checkpoints[_tokenId][_nCheckPoints - 1].fromTimestamp ==\\n            block.timestamp\\n        ) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /// @notice Binary search to get the voting checkpoint for a token id at or prior to a given timestamp.\\n    /// @dev If a checkpoint does not exist prior to the timestamp, this will return 0.\\n    /// @param _numCheckpoints State of all user checkpoint counts\\n    /// @param _checkpoints State of all user checkpoints\\n    /// @param _tokenId .\\n    /// @param _timestamp .\\n    /// @return The index of the checkpoint.\\n    function getPastVotesIndex(\\n        mapping(uint256 => uint48) storage _numCheckpoints,\\n        mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint))\\n            storage _checkpoints,\\n        uint256 _tokenId,\\n        uint256 _timestamp\\n    ) internal view returns (uint48) {\\n        uint48 nCheckpoints = _numCheckpoints[_tokenId];\\n        if (nCheckpoints == 0) return 0;\\n        // First check most recent balance\\n        if (\\n            _checkpoints[_tokenId][nCheckpoints - 1].fromTimestamp <= _timestamp\\n        ) return (nCheckpoints - 1);\\n        // Next check implicit zero balance\\n        if (_checkpoints[_tokenId][0].fromTimestamp > _timestamp) return 0;\\n\\n        uint48 lower = 0;\\n        uint48 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint48 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            IVotingEscrow.Checkpoint storage cp = _checkpoints[_tokenId][\\n                center\\n            ];\\n            if (cp.fromTimestamp == _timestamp) {\\n                return center;\\n            } else if (cp.fromTimestamp < _timestamp) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return lower;\\n    }\\n\\n    /// @notice Retrieves historical voting balance for a token id at a given timestamp.\\n    /// @dev If a checkpoint does not exist prior to the timestamp, this will return 0.\\n    ///      The user must also own the token at the time in order to receive a voting balance.\\n    /// @param _numCheckpoints State of all user checkpoint counts\\n    /// @param _checkpoints State of all user checkpoints\\n    /// @param _account .\\n    /// @param _tokenId .\\n    /// @param _timestamp .\\n    /// @return Total voting balance including delegations at a given timestamp.\\n    function getPastVotes(\\n        mapping(uint256 => uint48) storage _numCheckpoints,\\n        mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint))\\n            storage _checkpoints,\\n        address _account,\\n        uint256 _tokenId,\\n        uint256 _timestamp\\n    ) external view returns (uint256) {\\n        uint48 _checkIndex = getPastVotesIndex(\\n            _numCheckpoints,\\n            _checkpoints,\\n            _tokenId,\\n            _timestamp\\n        );\\n        IVotingEscrow.Checkpoint memory lastCheckpoint = _checkpoints[_tokenId][\\n            _checkIndex\\n        ];\\n        // If no point exists prior to the given timestamp, return 0\\n        if (lastCheckpoint.fromTimestamp > _timestamp) return 0;\\n        // Check ownership\\n        if (_account != lastCheckpoint.owner) return 0;\\n        uint256 votes = lastCheckpoint.delegatedBalance;\\n        return\\n            lastCheckpoint.delegatee == 0\\n                ? votes +\\n                    IVotingEscrow(address(this)).balanceOfNFTAt(\\n                        _tokenId,\\n                        _timestamp\\n                    )\\n                : votes;\\n    }\\n}\\n\",\"keccak256\":\"0xf93196d208e09989ddb99d8637f5b2f420a49f58426c8065f5b776d46a0eca1e\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/SafeCastLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.24;\\n\\n/// @title SafeCast Library\\n/// @author velodrome.finance\\n/// @notice Safely convert unsigned and signed integers without overflow / underflow\\nlibrary SafeCastLibrary {\\n    error SafeCastOverflow();\\n    error SafeCastUnderflow();\\n\\n    /// @dev Safely convert uint256 to int128\\n    function toInt128(uint256 value) internal pure returns (int128) {\\n        if (value > uint128(type(int128).max)) revert SafeCastOverflow();\\n        return int128(uint128(value));\\n    }\\n\\n    /// @dev Safely convert int128 to uint256\\n    function toUint256(int128 value) internal pure returns (uint256) {\\n        if (value < 0) revert SafeCastUnderflow();\\n        return uint256(int256(value));\\n    }\\n}\\n\",\"keccak256\":\"0xfc419390f2423ffa802e9a3a11ee859b01fee9ffdb0fca855008d6b7d6b25bd6\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x610a8961003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061004b5760003560e01c8063656a7ea614610050578063690f66bf14610075578063ebe3337214610097575b600080fd5b61006361005e366004610885565b6100b7565b60405190815260200160405180910390f35b81801561008157600080fd5b506100956100903660046108cc565b6101f0565b005b8180156100a357600080fd5b506100956100b2366004610928565b61045d565b6000806100c687878686610677565b60008581526020888152604080832065ffffffffffff851684528252918290208251608081018452815480825260018301546001600160a01b03169382019390935260028201549381019390935260030154606083015291925090841015610133576000925050506101e7565b80602001516001600160a01b0316866001600160a01b03161461015b576000925050506101e7565b604081015160608201511561017057806101e1565b604051637028a55d60e11b81526004810187905260248101869052309063e0514aba90604401602060405180830381865afa1580156101b3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d7919061097a565b6101e190826109a9565b93505050505b95945050505050565b60008381526020889052604081205461020b90600f0b6107ca565b60008581526020899052604081205491925065ffffffffffff9091169081610249576000868152602089815260408083208380529091529020610282565b6000868152602089905260408120906102636001856109c2565b65ffffffffffff1665ffffffffffff1681526020019081526020016000205b90506102968989836003015486600061045d565b60008681526020898152604080832065ffffffffffff86168452909152902042815560028281015490820155600381018690556001810180546001600160a01b0319166001600160a01b0387161790556102f18a8a896107f6565b1561034057600087815260208b905260408120805465ffffffffffff1691610318836109e8565b91906101000a81548165ffffffffffff021916908365ffffffffffff16021790555050610443565b600087815260208a905260408120829161035b6001876109c2565b65ffffffffffff1665ffffffffffff168152602001908152602001600020600082015481600001556001820160009054906101000a90046001600160a01b03168160010160006101000a8154816001600160a01b0302191690836001600160a01b03160217905550600282015481600201556003820154816003015590505088600088815260200190815260200160002060008465ffffffffffff1665ffffffffffff1681526020019081526020016000206000808201600090556001820160006101000a8154906001600160a01b0302191690556002820160009055600382016000905550505b505050600093845250506020929092526040902055505050565b82156106705760008381526020869052604081205465ffffffffffff16908161049c5760008581526020878152604080832083805290915290206104d5565b6000858152602087905260408120906104b66001856109c2565b65ffffffffffff1665ffffffffffff1681526020019081526020016000205b60008681526020888152604080832065ffffffffffff87168452909152902042815560018083015490820180546001600160a01b0319166001600160a01b039092169190911790559091508361054c578160020154851061053757600061055c565b8482600201546105479190610a0d565b61055c565b84826002015461055c91906109a9565b6002820155600380830154908201556105768888886107f6565b156105c5576000868152602089905260408120805465ffffffffffff169161059d836109e8565b91906101000a81548165ffffffffffff021916908365ffffffffffff1602179055505061066c565b600086815260208890526040812082916105e06001876109c2565b65ffffffffffff9081168252602080830193909352604091820160009081208554815560018087015481830180546001600160a01b039092166001600160a01b031992831617905560028089015481850155600398890154938901939093558d84528e8752858420948b1684529390955292812081815593840180549092169091559082018190559101555b5050505b5050505050565b60008281526020859052604081205465ffffffffffff1680820361069f5760009150506107c2565b600084815260208690526040812084916106ba6001856109c2565b65ffffffffffff168152602081019190915260400160002054116106eb576106e36001826109c2565b9150506107c2565b6000848152602086815260408083208380529091529020548310156107145760009150506107c2565b6000806107226001846109c2565b90505b8165ffffffffffff168165ffffffffffff1611156107bd576000600261074b84846109c2565b6107559190610a20565b61075f90836109c2565b600088815260208a8152604080832065ffffffffffff851684529091529020805491925090879003610797575093506107c292505050565b80548711156107a8578193506107b6565b6107b36001836109c2565b92505b5050610725565b509150505b949350505050565b60008082600f0b12156107ef5760405162406f5d60e21b815260040160405180910390fd5b50600f0b90565b60008181526020849052604081205465ffffffffffff16801580159061084d5750600083815260208590526040812042916108326001856109c2565b65ffffffffffff168152602081019190915260400160002054145b1561085c576000915050610862565b60019150505b9392505050565b80356001600160a01b038116811461088057600080fd5b919050565b600080600080600060a0868803121561089d57600080fd5b85359450602086013593506108b460408701610869565b94979396509394606081013594506080013592915050565b600080600080600080600060e0888a0312156108e757600080fd5b873596506020880135955060408801359450606088013593506080880135925060a0880135915061091a60c08901610869565b905092959891949750929550565b600080600080600060a0868803121561094057600080fd5b853594506020860135935060408601359250606086013591506080860135801515811461096c57600080fd5b809150509295509295909350565b60006020828403121561098c57600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b808201808211156109bc576109bc610993565b92915050565b65ffffffffffff8281168282160390808211156109e1576109e1610993565b5092915050565b600065ffffffffffff808316818103610a0357610a03610993565b6001019392505050565b818103818111156109bc576109bc610993565b600065ffffffffffff80841680610a4757634e487b7160e01b600052601260045260246000fd5b9216919091049291505056fea26469706673582212202d34b7ef511ad5e469dbd4085c79ed35af1652296335540c314c7f0f14d7232b64736f6c63430008180033",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361061004b5760003560e01c8063656a7ea614610050578063690f66bf14610075578063ebe3337214610097575b600080fd5b61006361005e366004610885565b6100b7565b60405190815260200160405180910390f35b81801561008157600080fd5b506100956100903660046108cc565b6101f0565b005b8180156100a357600080fd5b506100956100b2366004610928565b61045d565b6000806100c687878686610677565b60008581526020888152604080832065ffffffffffff851684528252918290208251608081018452815480825260018301546001600160a01b03169382019390935260028201549381019390935260030154606083015291925090841015610133576000925050506101e7565b80602001516001600160a01b0316866001600160a01b03161461015b576000925050506101e7565b604081015160608201511561017057806101e1565b604051637028a55d60e11b81526004810187905260248101869052309063e0514aba90604401602060405180830381865afa1580156101b3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d7919061097a565b6101e190826109a9565b93505050505b95945050505050565b60008381526020889052604081205461020b90600f0b6107ca565b60008581526020899052604081205491925065ffffffffffff9091169081610249576000868152602089815260408083208380529091529020610282565b6000868152602089905260408120906102636001856109c2565b65ffffffffffff1665ffffffffffff1681526020019081526020016000205b90506102968989836003015486600061045d565b60008681526020898152604080832065ffffffffffff86168452909152902042815560028281015490820155600381018690556001810180546001600160a01b0319166001600160a01b0387161790556102f18a8a896107f6565b1561034057600087815260208b905260408120805465ffffffffffff1691610318836109e8565b91906101000a81548165ffffffffffff021916908365ffffffffffff16021790555050610443565b600087815260208a905260408120829161035b6001876109c2565b65ffffffffffff1665ffffffffffff168152602001908152602001600020600082015481600001556001820160009054906101000a90046001600160a01b03168160010160006101000a8154816001600160a01b0302191690836001600160a01b03160217905550600282015481600201556003820154816003015590505088600088815260200190815260200160002060008465ffffffffffff1665ffffffffffff1681526020019081526020016000206000808201600090556001820160006101000a8154906001600160a01b0302191690556002820160009055600382016000905550505b505050600093845250506020929092526040902055505050565b82156106705760008381526020869052604081205465ffffffffffff16908161049c5760008581526020878152604080832083805290915290206104d5565b6000858152602087905260408120906104b66001856109c2565b65ffffffffffff1665ffffffffffff1681526020019081526020016000205b60008681526020888152604080832065ffffffffffff87168452909152902042815560018083015490820180546001600160a01b0319166001600160a01b039092169190911790559091508361054c578160020154851061053757600061055c565b8482600201546105479190610a0d565b61055c565b84826002015461055c91906109a9565b6002820155600380830154908201556105768888886107f6565b156105c5576000868152602089905260408120805465ffffffffffff169161059d836109e8565b91906101000a81548165ffffffffffff021916908365ffffffffffff1602179055505061066c565b600086815260208890526040812082916105e06001876109c2565b65ffffffffffff9081168252602080830193909352604091820160009081208554815560018087015481830180546001600160a01b039092166001600160a01b031992831617905560028089015481850155600398890154938901939093558d84528e8752858420948b1684529390955292812081815593840180549092169091559082018190559101555b5050505b5050505050565b60008281526020859052604081205465ffffffffffff1680820361069f5760009150506107c2565b600084815260208690526040812084916106ba6001856109c2565b65ffffffffffff168152602081019190915260400160002054116106eb576106e36001826109c2565b9150506107c2565b6000848152602086815260408083208380529091529020548310156107145760009150506107c2565b6000806107226001846109c2565b90505b8165ffffffffffff168165ffffffffffff1611156107bd576000600261074b84846109c2565b6107559190610a20565b61075f90836109c2565b600088815260208a8152604080832065ffffffffffff851684529091529020805491925090879003610797575093506107c292505050565b80548711156107a8578193506107b6565b6107b36001836109c2565b92505b5050610725565b509150505b949350505050565b60008082600f0b12156107ef5760405162406f5d60e21b815260040160405180910390fd5b50600f0b90565b60008181526020849052604081205465ffffffffffff16801580159061084d5750600083815260208590526040812042916108326001856109c2565b65ffffffffffff168152602081019190915260400160002054145b1561085c576000915050610862565b60019150505b9392505050565b80356001600160a01b038116811461088057600080fd5b919050565b600080600080600060a0868803121561089d57600080fd5b85359450602086013593506108b460408701610869565b94979396509394606081013594506080013592915050565b600080600080600080600060e0888a0312156108e757600080fd5b873596506020880135955060408801359450606088013593506080880135925060a0880135915061091a60c08901610869565b905092959891949750929550565b600080600080600060a0868803121561094057600080fd5b853594506020860135935060408601359250606086013591506080860135801515811461096c57600080fd5b809150509295509295909350565b60006020828403121561098c57600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b808201808211156109bc576109bc610993565b92915050565b65ffffffffffff8281168282160390808211156109e1576109e1610993565b5092915050565b600065ffffffffffff808316818103610a0357610a03610993565b6001019392505050565b818103818111156109bc576109bc610993565b600065ffffffffffff80841680610a4757634e487b7160e01b600052601260045260246000fd5b9216919091049291505056fea26469706673582212202d34b7ef511ad5e469dbd4085c79ed35af1652296335540c314c7f0f14d7232b64736f6c63430008180033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "checkpointDelegatee(mapping(uint256 => uint48) storage,mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint)) storage,uint256,uint256,bool)": {
        "details": "If used with `balance` == `_locked[_tokenId].amount`, then this is the same as      delegating or dedelegating from `_tokenId`      If used with `balance` < `_locked[_tokenId].amount`, then this is used to adjust      `delegatedBalance` when a user's balance is modified (e.g. `increaseAmount`, `merge` etc).      If `delegatee` is 0 (i.e. user is not delegating), then do nothing.",
        "params": {
          "_checkpoints": "State of all user checkpoints",
          "_delegatee": "The delegatee's tokenId",
          "_increase": "True if balance is increasing, false if decreasing",
          "_numCheckpoints": "State of all user checkpoint counts",
          "balance_": "The delta in balance change"
        }
      },
      "checkpointDelegator(mapping(uint256 => IVotingEscrow.LockedBalance) storage,mapping(uint256 => uint48) storage,mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint)) storage,mapping(uint256 => uint256) storage,uint256,uint256,address)": {
        "details": "This function depends on `_locked` and must be called prior to token state changes.      If you wish to dedelegate only, use `_delegate(tokenId, 0)` instead.",
        "params": {
          "_checkpoints": "State of all user checkpoints",
          "_delegatee": "The new delegatee for the delegator. Cannot be equal to `_delegator` (use 0 instead).",
          "_delegates": "State of all user delegatees",
          "_delegator": "The delegator to update checkpoints for",
          "_locked": "State of all locked balances",
          "_numCheckpoints": "State of all user checkpoint counts",
          "_owner": "The new (or current) owner for the delegator"
        }
      },
      "getPastVotes(mapping(uint256 => uint48) storage,mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint)) storage,address,uint256,uint256)": {
        "details": "If a checkpoint does not exist prior to the timestamp, this will return 0.      The user must also own the token at the time in order to receive a voting balance.",
        "params": {
          "_account": ".",
          "_checkpoints": "State of all user checkpoints",
          "_numCheckpoints": "State of all user checkpoint counts",
          "_timestamp": ".",
          "_tokenId": "."
        },
        "returns": {
          "_0": "Total voting balance including delegations at a given timestamp."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "checkpointDelegatee(mapping(uint256 => uint48) storage,mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint)) storage,uint256,uint256,bool)": {
        "notice": "Update delegatee's `delegatedBalance` by `balance`.         Only updates if delegating to a new delegatee."
      },
      "checkpointDelegator(mapping(uint256 => IVotingEscrow.LockedBalance) storage,mapping(uint256 => uint48) storage,mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint)) storage,mapping(uint256 => uint256) storage,uint256,uint256,address)": {
        "notice": "Used by `_mint`, `_transferFrom`, `_burn` and `delegate`         to update delegator voting checkpoints.         Automatically dedelegates, then updates checkpoint."
      },
      "getPastVotes(mapping(uint256 => uint48) storage,mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint)) storage,address,uint256,uint256)": {
        "notice": "Retrieves historical voting balance for a token id at a given timestamp."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
