{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC4906.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4906.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\nimport \"./IERC721.sol\";\n\n/// @title EIP-721 Metadata Update Extension\ninterface IERC4906 is IERC165, IERC721 {\n    /// @dev This event emits when the metadata of a token is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFT.\n    event MetadataUpdate(uint256 _tokenId);\n\n    /// @dev This event emits when the metadata of a range of tokens is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFTs.\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC6372.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC6372 {\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() external view returns (uint48);\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\n     * 0 before setting it to a non-zero value.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/ChainFeeSplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IVoter} from \"./interfaces/IVoter.sol\";\nimport {IEpochGovernor} from \"./interfaces/IEpochGovernor.sol\";\nimport {Splitter} from \"./Splitter.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IRewardsDistributor} from \"./interfaces/IRewardsDistributor.sol\";\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\nimport {IVoter} from \"./interfaces/IVoter.sol\";\n\n/// @title ChainFeeSplitter\n/// @notice A ChainFeeSplitter contract that changes the fee distribution between\n///         veBTC holders and Stake Gauges based on the gauge needle position.\ncontract ChainFeeSplitter is Splitter {\n    using SafeERC20 for IERC20;\n\n    /// @notice Rewards distribution among stake gauges.\n    IRewardsDistributor public immutable rewardsDistributor;\n\n    /// @notice The address of the Voter contract.\n    IVoter public immutable voter;\n\n    constructor(\n        address _voter, // the voting & distribution system\n        address _ve, // the ve(3,3) system that will be locked into\n        address _rewardsDistributor // rewards distributor\n    ) Splitter(_ve) {\n        /// The needle moves between 1 and 100. The default value is 33 to\n        /// simulate ~1/3 of fees going to the veBTC holders and ~2/3 to the\n        /// Stake Gauges.\n        needle = 33;\n        rewardsDistributor = IRewardsDistributor(_rewardsDistributor);\n        voter = IVoter(_voter);\n    }\n\n    /// @notice Returns the address of the epoch governor.\n    function epochGovernor() internal view override returns (address) {\n        return voter.epochGovernor();\n    }\n\n    /// @notice Transfers amount to veBTC holders. Token is BTC.\n    function transferFirstRecipient(uint256 amount) internal override {\n        token.safeTransfer(address(rewardsDistributor), amount);\n        // checkpoint token balance in rewards distributor\n        rewardsDistributor.checkpointToken();\n    }\n\n    /// @notice Transfers amount to stake gauges. Token is BTC.\n    function transferSecondRecipient(uint256 amount) internal override {\n        token.safeApprove(address(voter), amount);\n        voter.notifyRewardAmount(amount);\n    }\n}\n"
    },
    "contracts/governance/IVotes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// Modified IVotes interface for tokenId based voting\ninterface IVotes {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(\n        address indexed delegator,\n        uint256 indexed fromDelegate,\n        uint256 indexed toDelegate\n    );\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(\n        address indexed delegate,\n        uint256 previousBalance,\n        uint256 newBalance\n    );\n\n    /**\n     * @dev Returns the amount of votes that `tokenId` had at a specific moment in the past.\n     *      If the account passed in is not the owner, returns 0.\n     */\n    function getPastVotes(\n        address account,\n        uint256 tokenId,\n        uint256 timepoint\n    ) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(\n        uint256 timepoint\n    ) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `tokenId` has chosen. Can never be equal to the delegator's `tokenId`.\n     *      Returns 0 if not delegated.\n     */\n    function delegates(uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(uint256 delegator, uint256 delegatee) external;\n\n    /**\n     * @dev Delegates votes from `delegator` to `delegatee`. Signer must own `delegator`.\n     */\n    function delegateBySig(\n        uint256 delegator,\n        uint256 delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/interfaces/factories/IFactoryRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IFactoryRegistry {\n    error PathAlreadyApproved();\n    error PathNotApproved();\n    error PoolFactoryAlreadyApproved();\n    error SameAddress();\n    error ZeroAddress();\n\n    event Approve(\n        address indexed poolFactory,\n        address indexed votingRewardsFactory,\n        address indexed gaugeFactory\n    );\n    event Unapprove(\n        address indexed poolFactory,\n        address indexed votingRewardsFactory,\n        address indexed gaugeFactory\n    );\n    event SetManagedRewardsFactory(address indexed _newRewardsFactory);\n\n    /// @notice Approve a set of factories used in Mezodrome Protocol.  Router is now able to swap with pools created\n    //          by the poolFactory\n    /// @dev Callable by onlyOwner\n    /// @param poolFactory .\n    /// @param votingRewardsFactory .\n    /// @param gaugeFactory .\n    function approve(\n        address poolFactory,\n        address votingRewardsFactory,\n        address gaugeFactory\n    ) external;\n\n    /// @notice Unapprove a set of factories used in Mezodrome Protocol. Router is no longer able to swap with pools\n    ///         created by the poolFactory\n    /// @dev Callable by onlyOwner\n    /// @param poolFactory .\n    /// @param votingRewardsFactory .\n    /// @param gaugeFactory .\n    function unapprove(\n        address poolFactory,\n        address votingRewardsFactory,\n        address gaugeFactory\n    ) external;\n\n    /// @notice Check if a set of factories are approved for use in Mezodrome Protocol\n    /// @param poolFactory .\n    /// @param votingRewardsFactory .\n    /// @param gaugeFactory .\n    /// @return True if set of factories are approved, else false\n    function isApproved(\n        address poolFactory,\n        address votingRewardsFactory,\n        address gaugeFactory\n    ) external view returns (bool);\n\n    /// @notice Factory to create free and locked rewards for a managed veNFT\n    function managedRewardsFactory() external view returns (address);\n\n    /// @notice Set the rewards factory address\n    /// @dev Callable by onlyOwner\n    /// @param _newManagedRewardsFactory address of new managedRewardsFactory\n    function setManagedRewardsFactory(\n        address _newManagedRewardsFactory\n    ) external;\n\n    /// @notice Get all PoolFactories used by the registry\n    /// @dev The same PoolFactory address cannot be used twice\n    /// @return Array of PoolFactory addresses\n    function poolFactories() external view returns (address[] memory);\n\n    /// @notice Check if a PoolFactory is registered within the factory registry.  Router uses this method to\n    ///         ensure a pool swapped from is approved.\n    /// @param poolFactory .\n    /// @return True if PoolFactory is approved, else false\n    function poolFactoryExists(\n        address poolFactory\n    ) external view returns (bool);\n\n    /// @notice Get the length of the poolFactories array\n    function poolFactoriesLength() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/factories/IManagedRewardsFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IManagedRewardsFactory {\n    event ManagedRewardCreated(\n        address indexed voter,\n        address indexed lockedManagedReward,\n        address indexed freeManagedReward\n    );\n\n    /// @notice creates a LockedManagedReward and a FreeManagedReward contract for a managed veNFT\n    /// @param _forwarder Address of trusted forwarder\n    /// @param _voter Address of Voter.sol\n    /// @return lockedManagedReward Address of LockedManagedReward contract created\n    /// @return freeManagedReward   Address of FreeManagedReward contract created\n    function createRewards(\n        address _forwarder,\n        address _voter\n    ) external returns (address lockedManagedReward, address freeManagedReward);\n}\n"
    },
    "contracts/interfaces/IEpochGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IEpochGovernor {\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    function result() external returns (ProposalState);\n}\n"
    },
    "contracts/interfaces/IReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IReward {\n    error InvalidReward();\n    error NotAuthorized();\n    error NotGauge();\n    error NotEscrowToken();\n    error NotSingleToken();\n    error NotVotingEscrow();\n    error NotWhitelisted();\n    error ZeroAmount();\n\n    event Deposit(\n        address indexed from,\n        uint256 indexed tokenId,\n        uint256 amount\n    );\n    event Withdraw(\n        address indexed from,\n        uint256 indexed tokenId,\n        uint256 amount\n    );\n    event NotifyReward(\n        address indexed from,\n        address indexed reward,\n        uint256 indexed epoch,\n        uint256 amount\n    );\n    event ClaimRewards(\n        address indexed from,\n        address indexed reward,\n        uint256 amount\n    );\n\n    /// @notice Deposit an amount into the rewards contract to earn future rewards associated to a veNFT\n    /// @dev Internal notation used as only callable internally by `authorized`.\n    /// @param amount   Amount deposited for the veNFT\n    /// @param tokenId  Unique identifier of the veNFT\n    function _deposit(uint256 amount, uint256 tokenId) external;\n\n    /// @notice Withdraw an amount from the rewards contract associated to a veNFT\n    /// @dev Internal notation used as only callable internally by `authorized`.\n    /// @param amount   Amount deposited for the veNFT\n    /// @param tokenId  Unique identifier of the veNFT\n    function _withdraw(uint256 amount, uint256 tokenId) external;\n\n    /// @notice Claim the rewards earned by a veNFT staker\n    /// @param tokenId  Unique identifier of the veNFT\n    /// @param tokens   Array of tokens to claim rewards of\n    function getReward(uint256 tokenId, address[] memory tokens) external;\n\n    /// @notice Add rewards for stakers to earn\n    /// @param token    Address of token to reward\n    /// @param amount   Amount of token to transfer to rewards\n    function notifyRewardAmount(address token, uint256 amount) external;\n\n    /// @notice Determine the prior balance for an account as of a block number\n    /// @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n    /// @param tokenId      The token of the NFT to check\n    /// @param timestamp    The timestamp to get the balance at\n    /// @return The balance the account had as of the given block\n    function getPriorBalanceIndex(\n        uint256 tokenId,\n        uint256 timestamp\n    ) external view returns (uint256);\n\n    /// @notice Determine the prior index of supply staked by of a timestamp\n    /// @dev Timestamp must be <= current timestamp\n    /// @param timestamp The timestamp to get the index at\n    /// @return Index of supply checkpoint\n    function getPriorSupplyIndex(\n        uint256 timestamp\n    ) external view returns (uint256);\n\n    /// @notice Calculate how much in rewards are earned for a specific token and veNFT\n    /// @param token Address of token to fetch rewards of\n    /// @param tokenId Unique identifier of the veNFT\n    /// @return Amount of token earned in rewards\n    function earned(\n        address token,\n        uint256 tokenId\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IRewardsDistributor {\n    event CheckpointToken(uint256 time, uint256 tokens);\n    event Claimed(\n        uint256 indexed tokenId,\n        uint256 indexed epochStart,\n        uint256 indexed epochEnd,\n        uint256 amount\n    );\n\n    error NotDepositor();\n\n    /// @notice Called by Splitter to notify Distributor of rebases\n    function checkpointToken() external;\n\n    /// @notice Returns the amount of rebases claimable for a given token ID\n    /// @dev Allows claiming of rebases up to 50 epochs old\n    /// @param tokenId The token ID to check\n    /// @return The amount of rebases claimable for the given token ID\n    function claimable(uint256 tokenId) external view returns (uint256);\n\n    /// @notice Claims rebases for a given token ID\n    /// @dev Allows claiming of rebases up to 50 epochs old\n    /// @param tokenId The token ID to claim for\n    /// @return The amount of rebases claimed\n    function claim(uint256 tokenId) external returns (uint256);\n\n    /// @notice Claims rebases for a list of token IDs\n    /// @param tokenIds The token IDs to claim for\n    /// @return Whether or not the claim succeeded\n    function claimMany(uint256[] calldata tokenIds) external returns (bool);\n\n    /// @notice Used to set splitter once on initialization\n    /// @dev Callable once by Splitter only, Splitter is immutable\n    function setDepositor(address _depositor) external;\n}\n"
    },
    "contracts/interfaces/ISplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\ninterface ISplitter {\n    error AlreadyNudged();\n    error NotEpochGovernor();\n\n    event Nudge(uint256 indexed _period, uint256 _oldRate, uint256 _newRate);\n\n    /// @notice Allows epoch governor to modify the fee splitter by at most 1 basis\n    ///         tick per epoch on a scale to a maximum of 100 or to a minimum of 1.\n    /// @dev Throws if not epoch governor.\n    ///      Throws if already nudged this epoch.\n    ///      Throws if nudging above maximum rate.\n    ///      Throws if nudging below minimum rate.\n    ///      This contract is coupled to EpochGovernor as it requires three option\n    ///      simple majority voting.\n    function nudge() external;\n\n    /// @notice Processes emissions and rebases. Callable once per epoch.\n    /// @return _period Start of current epoch.\n    function updatePeriod() external returns (uint256 _period);\n}\n"
    },
    "contracts/interfaces/IVeArtProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IVeArtProxy {\n    function tokenURI(\n        uint256 _tokenId\n    ) external view returns (string memory output);\n}\n"
    },
    "contracts/interfaces/IVoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\ninterface IVoter {\n    error AlreadyVotedOrDeposited();\n    error DistributeWindow();\n    error FactoryPathNotApproved();\n    error GaugeAlreadyKilled();\n    error GaugeAlreadyRevived();\n    error GaugeExists();\n    error GaugeDoesNotExist(address _pool);\n    error GaugeNotAlive(address _gauge);\n    error InactiveManagedNFT();\n    error MaximumVotingNumberTooLow();\n    error NonZeroVotes();\n    error NotAPool();\n    error NotApprovedOrOwner();\n    error NotGovernor();\n    error NotEmergencyCouncil();\n    error NotSplitter();\n    error NotWhitelistedNFT();\n    error NotWhitelistedToken();\n    error SameValue();\n    error SpecialVotingWindow();\n    error TooManyPools();\n    error UnequalLengths();\n    error ZeroBalance();\n    error ZeroAddress();\n\n    event GaugeCreated(\n        address indexed poolFactory,\n        address indexed votingRewardsFactory,\n        address indexed gaugeFactory,\n        address pool,\n        address bribeVotingReward,\n        address feeVotingReward,\n        address gauge,\n        address creator\n    );\n    event GaugeKilled(address indexed gauge);\n    event GaugeRevived(address indexed gauge);\n    event Voted(\n        address indexed voter,\n        address indexed pool,\n        uint256 indexed tokenId,\n        uint256 weight,\n        uint256 totalWeight,\n        uint256 timestamp\n    );\n    event Abstained(\n        address indexed voter,\n        address indexed pool,\n        uint256 indexed tokenId,\n        uint256 weight,\n        uint256 totalWeight,\n        uint256 timestamp\n    );\n    event NotifyReward(\n        address indexed sender,\n        address indexed reward,\n        uint256 amount\n    );\n    event DistributeReward(\n        address indexed sender,\n        address indexed gauge,\n        uint256 amount\n    );\n    event WhitelistToken(\n        address indexed whitelister,\n        address indexed token,\n        bool indexed _bool\n    );\n    event WhitelistNFT(\n        address indexed whitelister,\n        uint256 indexed tokenId,\n        bool indexed _bool\n    );\n\n    /// @notice Store trusted forwarder address to pass into factories\n    function forwarder() external view returns (address);\n\n    /// @notice The ve token that governs these contracts\n    function ve() external view returns (address);\n\n    /// @notice Factory registry for valid pool / gauge / rewards factories\n    function factoryRegistry() external view returns (address);\n\n    /// @notice Address of a splitter contract\n    function splitter() external view returns (address);\n\n    /// @notice Standard OZ IGovernor using ve for vote weights.\n    function governor() external view returns (address);\n\n    /// @notice Custom Epoch Governor using ve for vote weights.\n    function epochGovernor() external view returns (address);\n\n    /// @notice credibly neutral party similar to Curve's Emergency DAO\n    function emergencyCouncil() external view returns (address);\n\n    /// @dev Total Voting Weights\n    function totalWeight() external view returns (uint256);\n\n    /// @dev Most number of pools one voter can vote for at once\n    function maxVotingNum() external view returns (uint256);\n\n    // mappings\n    /// @dev Pool => Gauge\n    function gauges(address pool) external view returns (address);\n\n    /// @dev Gauge => Pool\n    function poolForGauge(address gauge) external view returns (address);\n\n    /// @dev Gauge => Fees Voting Reward\n    function gaugeToFees(address gauge) external view returns (address);\n\n    /// @dev Gauge => Bribes Voting Reward\n    function gaugeToBribe(address gauge) external view returns (address);\n\n    /// @dev Pool => Weights\n    function weights(address pool) external view returns (uint256);\n\n    /// @dev NFT => Pool => Votes\n    function votes(\n        uint256 tokenId,\n        address pool\n    ) external view returns (uint256);\n\n    /// @dev NFT => Total voting weight of NFT\n    function usedWeights(uint256 tokenId) external view returns (uint256);\n\n    /// @dev Nft => Timestamp of last vote (ensures single vote per epoch)\n    function lastVoted(uint256 tokenId) external view returns (uint256);\n\n    /// @dev Address => Gauge\n    function isGauge(address) external view returns (bool);\n\n    /// @dev Token => Whitelisted status\n    function isWhitelistedToken(address token) external view returns (bool);\n\n    /// @dev TokenId => Whitelisted status\n    function isWhitelistedNFT(uint256 tokenId) external view returns (bool);\n\n    /// @dev Gauge => Liveness status\n    function isAlive(address gauge) external view returns (bool);\n\n    /// @dev Gauge => Amount claimable\n    function claimable(address gauge) external view returns (uint256);\n\n    /// @notice Number of pools with a Gauge\n    function length() external view returns (uint256);\n\n    /// @notice Called by Splitter to distribute weekly emissions rewards for disbursement amongst gauges.\n    /// @dev Assumes totalWeight != 0 (Will never be zero as long as users are voting).\n    ///      Throws if not called by splitter.\n    /// @param _amount Amount of rewards to distribute.\n    function notifyRewardAmount(uint256 _amount) external;\n\n    /// @dev Utility to distribute to gauges of pools in range _start to _finish.\n    /// @param _start   Starting index of gauges to distribute to.\n    /// @param _finish  Ending index of gauges to distribute to.\n    function distribute(uint256 _start, uint256 _finish) external;\n\n    /// @dev Utility to distribute to gauges of pools in array.\n    /// @param _gauges Array of gauges to distribute to.\n    function distribute(address[] memory _gauges) external;\n\n    /// @notice Called by users to update voting balances in voting rewards contracts.\n    /// @param _tokenId Id of veNFT whose balance you wish to update.\n    function poke(uint256 _tokenId) external;\n\n    /// @notice Called by users to vote for pools. Votes distributed proportionally based on weights.\n    ///         Can only vote or deposit into a managed NFT once per epoch.\n    ///         Can only vote for gauges that have not been killed.\n    /// @dev Weights are distributed proportional to the sum of the weights in the array.\n    ///      Throws if length of _poolVote and _weights do not match.\n    /// @param _tokenId     Id of veNFT you are voting with.\n    /// @param _poolVote    Array of pools you are voting for.\n    /// @param _weights     Weights of pools.\n    function vote(\n        uint256 _tokenId,\n        address[] calldata _poolVote,\n        uint256[] calldata _weights\n    ) external;\n\n    /// @notice Called by users to reset voting state. Required if you wish to make changes to\n    ///         veNFT state (e.g. merge, split, deposit into managed etc).\n    ///         Cannot reset in the same epoch that you voted in.\n    ///         Can vote or deposit into a managed NFT again after reset.\n    /// @param _tokenId Id of veNFT you are reseting.\n    function reset(uint256 _tokenId) external;\n\n    /// @notice Called by users to deposit into a managed NFT.\n    ///         Can only vote or deposit into a managed NFT once per epoch.\n    ///         Note that NFTs deposited into a managed NFT will be re-locked\n    ///         to the maximum lock time on withdrawal.\n    /// @dev Throws if not approved or owner.\n    ///      Throws if managed NFT is inactive.\n    ///      Throws if depositing within privileged window (one hour prior to epoch flip).\n    function depositManaged(uint256 _tokenId, uint256 _mTokenId) external;\n\n    /// @notice Called by users to withdraw from a managed NFT.\n    ///         Cannot do it in the same epoch that you deposited into a managed NFT.\n    ///         Can vote or deposit into a managed NFT again after withdrawing.\n    ///         Note that the NFT withdrawn is re-locked to the maximum lock time.\n    function withdrawManaged(uint256 _tokenId) external;\n\n    /// @notice Claim emissions from gauges.\n    /// @param _gauges Array of gauges to collect emissions from.\n    function claimRewards(address[] memory _gauges) external;\n\n    /// @notice Claim bribes for a given NFT.\n    /// @dev Utility to help batch bribe claims.\n    /// @param _bribes  Array of BribeVotingReward contracts to collect from.\n    /// @param _tokens  Array of tokens that are used as bribes.\n    /// @param _tokenId Id of veNFT that you wish to claim bribes for.\n    function claimBribes(\n        address[] memory _bribes,\n        address[][] memory _tokens,\n        uint256 _tokenId\n    ) external;\n\n    /// @notice Claim fees for a given NFT.\n    /// @dev Utility to help batch fee claims.\n    /// @param _fees    Array of FeesVotingReward contracts to collect from.\n    /// @param _tokens  Array of tokens that are used as fees.\n    /// @param _tokenId Id of veNFT that you wish to claim fees for.\n    function claimFees(\n        address[] memory _fees,\n        address[][] memory _tokens,\n        uint256 _tokenId\n    ) external;\n\n    /// @notice Set new governor.\n    /// @dev Throws if not called by governor.\n    /// @param _governor .\n    function setGovernor(address _governor) external;\n\n    /// @notice Set new epoch based governor.\n    /// @dev Throws if not called by governor.\n    /// @param _epochGovernor .\n    function setEpochGovernor(address _epochGovernor) external;\n\n    /// @notice Set new emergency council.\n    /// @dev Throws if not called by emergency council.\n    /// @param _emergencyCouncil .\n    function setEmergencyCouncil(address _emergencyCouncil) external;\n\n    /// @notice Set maximum number of gauges that can be voted for.\n    /// @dev Throws if not called by governor.\n    ///      Throws if _maxVotingNum is too low.\n    ///      Throws if the values are the same.\n    /// @param _maxVotingNum .\n    function setMaxVotingNum(uint256 _maxVotingNum) external;\n\n    /// @notice Whitelist (or unwhitelist) token for use in bribes.\n    /// @dev Throws if not called by governor.\n    /// @param _token .\n    /// @param _bool .\n    function whitelistToken(address _token, bool _bool) external;\n\n    /// @notice Whitelist (or unwhitelist) token id for voting in last hour prior to epoch flip.\n    /// @dev Throws if not called by governor.\n    ///      Throws if already whitelisted.\n    /// @param _tokenId .\n    /// @param _bool .\n    function whitelistNFT(uint256 _tokenId, bool _bool) external;\n\n    /// @notice Create a new gauge (unpermissioned).\n    /// @dev Governor can create a new gauge for a pool with any address.\n    /// @param _poolFactory .\n    /// @param _votingRewardsFactory .\n    /// @param _gaugeFactory .\n    /// @param _pool .\n    function createGauge(\n        address _poolFactory,\n        address _votingRewardsFactory,\n        address _gaugeFactory,\n        address _pool\n    ) external returns (address);\n\n    /// @notice Kills a gauge. The gauge will not receive any new emissions and cannot be deposited into.\n    ///         Can still withdraw from gauge.\n    /// @dev Throws if not called by emergency council.\n    ///      Throws if gauge already killed.\n    /// @param _gauge .\n    function killGauge(address _gauge) external;\n\n    /// @notice Revives a killed gauge. Gauge will can receive emissions and deposits again.\n    /// @dev Throws if not called by emergency council.\n    ///      Throws if gauge is not killed.\n    /// @param _gauge .\n    function reviveGauge(address _gauge) external;\n\n    /// @dev Update claims to emissions for an array of gauges.\n    /// @param _gauges Array of gauges to update emissions for.\n    function updateFor(address[] memory _gauges) external;\n\n    /// @dev Update claims to emissions for gauges based on their pool id as stored in Voter.\n    /// @param _start   Starting index of pools.\n    /// @param _end     Ending index of pools.\n    function updateFor(uint256 _start, uint256 _end) external;\n\n    /// @dev Update claims to emissions for single gauge\n    /// @param _gauge .\n    function updateFor(address _gauge) external;\n}\n"
    },
    "contracts/interfaces/IVotingEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IERC165, IERC721, IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {IERC6372} from \"@openzeppelin/contracts/interfaces/IERC6372.sol\";\nimport {IERC4906} from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\nimport {IVotes} from \"../governance/IVotes.sol\";\n\ninterface IVotingEscrow is IVotes, IERC4906, IERC6372, IERC721Metadata {\n    struct LockedBalance {\n        int128 amount;\n        uint256 end;\n        bool isPermanent;\n    }\n\n    struct UserPoint {\n        int128 bias;\n        int128 slope; // # -dweight / dt\n        uint256 ts;\n        uint256 blk; // block\n        uint256 permanent;\n    }\n\n    struct GlobalPoint {\n        int128 bias;\n        int128 slope; // # -dweight / dt\n        uint256 ts;\n        uint256 blk; // block\n        uint256 permanentLockBalance;\n    }\n\n    /// @notice A checkpoint for recorded delegated voting weights at a certain timestamp\n    struct Checkpoint {\n        uint256 fromTimestamp;\n        address owner;\n        uint256 delegatedBalance;\n        uint256 delegatee;\n    }\n\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME\n    }\n\n    /// @dev Different types of veNFTs:\n    /// NORMAL  - typical veNFT\n    /// LOCKED  - veNFT which is locked into a MANAGED veNFT\n    /// MANAGED - veNFT which can accept the deposit of NORMAL veNFTs\n    enum EscrowType {\n        NORMAL,\n        LOCKED,\n        MANAGED\n    }\n\n    error AlreadyVoted();\n    error AmountTooBig();\n    error ERC721ReceiverRejectedTokens();\n    error ERC721TransferToNonERC721ReceiverImplementer();\n    error InvalidNonce();\n    error InvalidSignature();\n    error InvalidSignatureS();\n    error InvalidManagedNFTId();\n    error LockDurationNotInFuture();\n    error LockDurationTooLong();\n    error LockExpired();\n    error LockNotExpired();\n    error NoLockFound();\n    error NonExistentToken();\n    error NotApprovedOrOwner();\n    error NotDistributor();\n    error NotEmergencyCouncilOrGovernor();\n    error NotGovernor();\n    error NotGovernorOrManager();\n    error NotManagedNFT();\n    error NotManagedOrNormalNFT();\n    error NotLockedNFT();\n    error NotNormalNFT();\n    error NotPermanentLock();\n    error NotOwner();\n    error NotTeam();\n    error NotVoter();\n    error OwnershipChange();\n    error PermanentLock();\n    error SameAddress();\n    error SameNFT();\n    error SameState();\n    error SplitNoOwner();\n    error SplitNotAllowed();\n    error SignatureExpired();\n    error TooManyTokenIDs();\n    error ZeroAddress();\n    error ZeroAmount();\n    error ZeroBalance();\n\n    event Deposit(\n        address indexed provider,\n        uint256 indexed tokenId,\n        DepositType indexed depositType,\n        uint256 value,\n        uint256 locktime,\n        uint256 ts\n    );\n    event Withdraw(\n        address indexed provider,\n        uint256 indexed tokenId,\n        uint256 value,\n        uint256 ts\n    );\n    event LockPermanent(\n        address indexed _owner,\n        uint256 indexed _tokenId,\n        uint256 amount,\n        uint256 _ts\n    );\n    event UnlockPermanent(\n        address indexed _owner,\n        uint256 indexed _tokenId,\n        uint256 amount,\n        uint256 _ts\n    );\n    event Supply(uint256 prevSupply, uint256 supply);\n    event Merge(\n        address indexed _sender,\n        uint256 indexed _from,\n        uint256 indexed _to,\n        uint256 _amountFrom,\n        uint256 _amountTo,\n        uint256 _amountFinal,\n        uint256 _locktime,\n        uint256 _ts\n    );\n    event Split(\n        uint256 indexed _from,\n        uint256 indexed _tokenId1,\n        uint256 indexed _tokenId2,\n        address _sender,\n        uint256 _splitAmount1,\n        uint256 _splitAmount2,\n        uint256 _locktime,\n        uint256 _ts\n    );\n    event CreateManaged(\n        address indexed _to,\n        uint256 indexed _mTokenId,\n        address indexed _from,\n        address _lockedManagedReward,\n        address _freeManagedReward\n    );\n    event DepositManaged(\n        address indexed _owner,\n        uint256 indexed _tokenId,\n        uint256 indexed _mTokenId,\n        uint256 _weight,\n        uint256 _ts\n    );\n    event WithdrawManaged(\n        address indexed _owner,\n        uint256 indexed _tokenId,\n        uint256 indexed _mTokenId,\n        uint256 _weight,\n        uint256 _ts\n    );\n    event SetAllowedManager(address indexed _allowedManager);\n\n    // State variables\n    /// @notice Address of Meta-tx Forwarder\n    function forwarder() external view returns (address);\n\n    /// @notice Address of FactoryRegistry.sol\n    function factoryRegistry() external view returns (address);\n\n    /// @notice Address of token used to create a veNFT\n    function token() external view returns (address);\n\n    /// @notice Address of RewardsDistributor.sol\n    function distributor() external view returns (address);\n\n    /// @notice Address of Voter.sol\n    function voter() external view returns (address);\n\n    /// @notice Address of Protocol Team multisig\n    function team() external view returns (address);\n\n    /// @notice Address of art proxy used for on-chain art generation\n    function artProxy() external view returns (address);\n\n    /// @dev address which can create managed NFTs\n    function allowedManager() external view returns (address);\n\n    /// @dev Current count of token\n    function tokenId() external view returns (uint256);\n\n    /*///////////////////////////////////////////////////////////////\n                            MANAGED NFT STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping of token id to escrow type\n    ///      Takes advantage of the fact default value is EscrowType.NORMAL\n    function escrowType(uint256 tokenId) external view returns (EscrowType);\n\n    /// @dev Mapping of token id to managed id\n    function idToManaged(\n        uint256 tokenId\n    ) external view returns (uint256 managedTokenId);\n\n    /// @dev Mapping of user token id to managed token id to weight of token id\n    function weights(\n        uint256 tokenId,\n        uint256 managedTokenId\n    ) external view returns (uint256 weight);\n\n    /// @dev Mapping of managed id to deactivated state\n    function deactivated(uint256 tokenId) external view returns (bool inactive);\n\n    /// @dev Mapping from managed nft id to locked managed rewards\n    ///      `token` denominated rewards (rebases/rewards) stored in locked managed rewards contract\n    ///      to prevent co-mingling of assets\n    function managedToLocked(uint256 tokenId) external view returns (address);\n\n    /// @dev Mapping from managed nft id to free managed rewards contract\n    ///      these rewards can be freely withdrawn by users\n    function managedToFree(uint256 tokenId) external view returns (address);\n\n    /*///////////////////////////////////////////////////////////////\n                            MANAGED NFT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Create managed NFT (a permanent lock) for use within ecosystem.\n    /// @dev Throws if address already owns a managed NFT.\n    /// @return _mTokenId managed token id.\n    function createManagedLockFor(\n        address _to\n    ) external returns (uint256 _mTokenId);\n\n    /// @notice Delegates balance to managed nft\n    ///         Note that NFTs deposited into a managed NFT will be re-locked\n    ///         to the maximum lock time on withdrawal.\n    ///         Permanent locks that are deposited will automatically unlock.\n    /// @dev Managed nft will remain max-locked as long as there is at least one\n    ///      deposit or withdrawal per week.\n    ///      Throws if deposit nft is managed.\n    ///      Throws if recipient nft is not managed.\n    ///      Throws if deposit nft is already locked.\n    ///      Throws if not called by voter.\n    /// @param _tokenId tokenId of NFT being deposited\n    /// @param _mTokenId tokenId of managed NFT that will receive the deposit\n    function depositManaged(uint256 _tokenId, uint256 _mTokenId) external;\n\n    /// @notice Retrieves locked rewards and withdraws balance from managed nft.\n    ///         Note that the NFT withdrawn is re-locked to the maximum lock time.\n    /// @dev Throws if NFT not locked.\n    ///      Throws if not called by voter.\n    /// @param _tokenId tokenId of NFT being deposited.\n    function withdrawManaged(uint256 _tokenId) external;\n\n    /// @notice Permit one address to call createManagedLockFor() that is not Voter.governor()\n    function setAllowedManager(address _allowedManager) external;\n\n    /// @notice Set Managed NFT state. Inactive NFTs cannot be deposited into.\n    /// @param _mTokenId managed nft state to set\n    /// @param _state true => inactive, false => active\n    function setManagedState(uint256 _mTokenId, bool _state) external;\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function version() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function setTeam(address _team) external;\n\n    function setArtProxy(address _proxy) external;\n\n    /// @inheritdoc IERC721Metadata\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from owner address to mapping of index to tokenId\n    function ownerToNFTokenIdList(\n        address _owner,\n        uint256 _index\n    ) external view returns (uint256 _tokenId);\n\n    /// @inheritdoc IERC721\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /// @inheritdoc IERC721\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721\n    function getApproved(\n        uint256 _tokenId\n    ) external view returns (address operator);\n\n    /// @inheritdoc IERC721\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n\n    /// @notice Check whether spender is owner or an approved user for a given veNFT\n    /// @param _spender .\n    /// @param _tokenId .\n    function isApprovedOrOwner(\n        address _spender,\n        uint256 _tokenId\n    ) external returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721\n    function approve(address to, uint256 tokenId) external;\n\n    /// @inheritdoc IERC721\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /// @inheritdoc IERC721\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 _interfaceID\n    ) external view returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                             ESCROW STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Total count of epochs witnessed since contract creation\n    function epoch() external view returns (uint256);\n\n    /// @notice Total amount of token() deposited\n    function supply() external view returns (uint256);\n\n    /// @notice Aggregate permanent locked balances\n    function permanentLockBalance() external view returns (uint256);\n\n    function userPointEpoch(\n        uint256 _tokenId\n    ) external view returns (uint256 _epoch);\n\n    /// @notice time -> signed slope change\n    function slopeChanges(uint256 _timestamp) external view returns (int128);\n\n    /// @notice account -> can split\n    function canSplit(address _account) external view returns (bool);\n\n    /// @notice Global point history at a given index\n    function pointHistory(\n        uint256 _loc\n    ) external view returns (GlobalPoint memory);\n\n    /// @notice Get the LockedBalance (amount, end) of a _tokenId\n    /// @param _tokenId .\n    /// @return LockedBalance of _tokenId\n    function locked(\n        uint256 _tokenId\n    ) external view returns (LockedBalance memory);\n\n    /// @notice User -> UserPoint[userEpoch]\n    function userPointHistory(\n        uint256 _tokenId,\n        uint256 _loc\n    ) external view returns (UserPoint memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ESCROW LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Record global data to checkpoint\n    function checkpoint() external;\n\n    /// @notice Deposit `_value` tokens for `_tokenId` and add to the lock\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\n    ///      cannot extend their locktime and deposit for a brand new user\n    /// @param _tokenId lock NFT\n    /// @param _value Amount to add to user's lock\n    function depositFor(uint256 _tokenId, uint256 _value) external;\n\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lockDuration`\n    /// @param _value Amount to deposit\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @return TokenId of created veNFT\n    function createLock(\n        uint256 _value,\n        uint256 _lockDuration\n    ) external returns (uint256);\n\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lockDuration`\n    /// @param _value Amount to deposit\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    /// @return TokenId of created veNFT\n    function createLockFor(\n        uint256 _value,\n        uint256 _lockDuration,\n        address _to\n    ) external returns (uint256);\n\n    /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\n    /// @param _value Amount of tokens to deposit and add to the lock\n    function increaseAmount(uint256 _tokenId, uint256 _value) external;\n\n    /// @notice Extend the unlock time for `_tokenId`\n    ///         Cannot extend lock time of permanent locks\n    /// @param _lockDuration New number of seconds until tokens unlock\n    function increaseUnlockTime(\n        uint256 _tokenId,\n        uint256 _lockDuration\n    ) external;\n\n    /// @notice Withdraw all tokens for `_tokenId`\n    /// @dev Only possible if the lock is both expired and not permanent\n    ///      This will burn the veNFT. Any rebases or rewards that are unclaimed\n    ///      will no longer be claimable. Claim all rebases and rewards prior to calling this.\n    function withdraw(uint256 _tokenId) external;\n\n    /// @notice Merges `_from` into `_to`.\n    /// @dev Cannot merge `_from` locks that are permanent or have already voted this epoch.\n    ///      Cannot merge `_to` locks that have already expired.\n    ///      This will burn the veNFT. Any rebases or rewards that are unclaimed\n    ///      will no longer be claimable. Claim all rebases and rewards prior to calling this.\n    /// @param _from VeNFT to merge from.\n    /// @param _to VeNFT to merge into.\n    function merge(uint256 _from, uint256 _to) external;\n\n    /// @notice Splits veNFT into two new veNFTS - one with oldLocked.amount - `_amount`, and the second with `_amount`\n    /// @dev    This burns the tokenId of the target veNFT\n    ///         Callable by approved or owner\n    ///         If this is called by approved, approved will not have permissions to manipulate the newly created veNFTs\n    ///         Returns the two new split veNFTs to owner\n    ///         If `from` is permanent, will automatically dedelegate.\n    ///         This will burn the veNFT. Any rebases or rewards that are unclaimed\n    ///         will no longer be claimable. Claim all rebases and rewards prior to calling this.\n    /// @param _from VeNFT to split.\n    /// @param _amount Amount to split from veNFT.\n    /// @return _tokenId1 Return tokenId of veNFT with oldLocked.amount - `_amount`.\n    /// @return _tokenId2 Return tokenId of veNFT with `_amount`.\n    function split(\n        uint256 _from,\n        uint256 _amount\n    ) external returns (uint256 _tokenId1, uint256 _tokenId2);\n\n    /// @notice Toggle split for a specific address.\n    /// @dev Toggle split for address(0) to enable or disable for all.\n    /// @param _account Address to toggle split permissions\n    /// @param _bool True to allow, false to disallow\n    function toggleSplit(address _account, bool _bool) external;\n\n    /// @notice Permanently lock a veNFT. Voting power will be equal to\n    ///         `LockedBalance.amount` with no decay. Required to delegate.\n    /// @dev Only callable by unlocked normal veNFTs.\n    /// @param _tokenId tokenId to lock.\n    function lockPermanent(uint256 _tokenId) external;\n\n    /// @notice Unlock a permanently locked veNFT. Voting power will decay.\n    ///         Will automatically dedelegate if delegated.\n    /// @dev Only callable by permanently locked veNFTs.\n    ///      Cannot unlock if already voted this epoch.\n    /// @param _tokenId tokenId to unlock.\n    function unlockPermanent(uint256 _tokenId) external;\n\n    /*///////////////////////////////////////////////////////////////\n                           GAUGE VOTING STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Get the voting power for _tokenId at the current timestamp\n    /// @dev Returns 0 if called in the same block as a transfer.\n    /// @param _tokenId .\n    /// @return Voting power\n    function balanceOfNFT(uint256 _tokenId) external view returns (uint256);\n\n    /// @notice Get the voting power for _tokenId at a given timestamp\n    /// @param _tokenId .\n    /// @param _t Timestamp to query voting power\n    /// @return Voting power\n    function balanceOfNFTAt(\n        uint256 _tokenId,\n        uint256 _t\n    ) external view returns (uint256);\n\n    /// @notice Calculate total voting power at current timestamp\n    /// @return Total voting power at current timestamp\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Calculate total voting power at a given timestamp\n    /// @param _t Timestamp to query total voting power\n    /// @return Total voting power at given timestamp\n    function totalSupplyAt(uint256 _t) external view returns (uint256);\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE VOTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice See if a queried _tokenId has actively voted\n    /// @param _tokenId .\n    /// @return True if voted, else false\n    function voted(uint256 _tokenId) external view returns (bool);\n\n    /// @notice Set the global state voter and distributor\n    /// @dev This is only called once, at setup\n    function setVoterAndDistributor(\n        address _voter,\n        address _distributor\n    ) external;\n\n    /// @notice Set `voted` for _tokenId to true or false\n    /// @dev Only callable by voter\n    /// @param _tokenId .\n    /// @param _voted .\n    function voting(uint256 _tokenId, bool _voted) external;\n\n    /*///////////////////////////////////////////////////////////////\n                            DAO VOTING STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The number of checkpoints for each tokenId\n    function numCheckpoints(uint256 tokenId) external view returns (uint48);\n\n    /// @notice A record of states for signing / validating signatures\n    function nonces(address account) external view returns (uint256);\n\n    /// @inheritdoc IVotes\n    function delegates(uint256 delegator) external view returns (uint256);\n\n    /// @notice A record of delegated token checkpoints for each account, by index\n    /// @param tokenId .\n    /// @param index .\n    /// @return Checkpoint\n    function checkpoints(\n        uint256 tokenId,\n        uint48 index\n    ) external view returns (Checkpoint memory);\n\n    /// @inheritdoc IVotes\n    function getPastVotes(\n        address account,\n        uint256 tokenId,\n        uint256 timestamp\n    ) external view returns (uint256);\n\n    /// @inheritdoc IVotes\n    function getPastTotalSupply(\n        uint256 timestamp\n    ) external view returns (uint256);\n\n    /*///////////////////////////////////////////////////////////////\n                             DAO VOTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVotes\n    function delegate(uint256 delegator, uint256 delegatee) external;\n\n    /// @inheritdoc IVotes\n    function delegateBySig(\n        uint256 delegator,\n        uint256 delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC6372 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC6372\n    function clock() external view returns (uint48);\n\n    /// @inheritdoc IERC6372\n    function CLOCK_MODE() external view returns (string memory);\n}\n"
    },
    "contracts/libraries/SafeCastLibrary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\n/// @title SafeCast Library\n/// @author velodrome.finance\n/// @notice Safely convert unsigned and signed integers without overflow / underflow\nlibrary SafeCastLibrary {\n    error SafeCastOverflow();\n    error SafeCastUnderflow();\n\n    /// @dev Safely convert uint256 to int128\n    function toInt128(uint256 value) internal pure returns (int128) {\n        if (value > uint128(type(int128).max)) revert SafeCastOverflow();\n        return int128(uint128(value));\n    }\n\n    /// @dev Safely convert int128 to uint256\n    function toUint256(int128 value) internal pure returns (uint256) {\n        if (value < 0) revert SafeCastUnderflow();\n        return uint256(int256(value));\n    }\n}\n"
    },
    "contracts/Splitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IEpochGovernor} from \"./interfaces/IEpochGovernor.sol\";\nimport {ISplitter} from \"./interfaces/ISplitter.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IRewardsDistributor} from \"./interfaces/IRewardsDistributor.sol\";\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\n\n/// @title Splitter\n/// @notice An abstract contract for tokens splitting between addresses defined\n///         in the implementation contract. Amount of the split tokens depends on\n///         the current position of the gauge needle that can be moved each epoch\n///         by the Epoch Governor.\nabstract contract Splitter is ISplitter {\n    using SafeERC20 for IERC20;\n\n    /// @notice Token for fee distribution.\n    IERC20 public immutable token;\n\n    /// @notice The maximum value of the gauge needle.\n    uint256 public constant MAXIMUM_GAUGE_SCALE = 100;\n\n    /// @notice The minimum value of the gauge needle.\n    uint256 public constant MINIMUM_GAUGE_SCALE = 1;\n\n    /// @notice Duration of epoch.\n    uint256 public constant WEEK = 1 weeks;\n\n    /// @notice Needle tick change per proposal.\n    uint256 public constant TICK = 1;\n\n    /// @notice Start time of currently active epoch.\n    uint256 public activePeriod;\n\n    /// @notice The current position of the gauge needle.\n    uint256 public needle;\n\n    /// @dev activePeriod => proposal existing, used to enforce one proposal per epoch.\n    mapping(uint256 => bool) public proposals;\n\n    /// @dev Emitted when the epoch period is updated.\n    event PeriodUpdated(\n        uint256 oldPeriod,\n        uint256 newPeriod,\n        uint256 firstRecipientAmount,\n        uint256 secondRecipientAmount\n    );\n\n    /// @notice Constructor to set up the fee splitter.\n    constructor(address _ve) {\n        token = IERC20(IVotingEscrow(_ve).token());\n    }\n\n    /// @notice Moves the gauge needle by 1 tick per epoch.\n    function nudge() external {\n        address epochGovernor = epochGovernor();\n        if (msg.sender != epochGovernor) revert NotEpochGovernor();\n\n        uint256 period = activePeriod;\n        if (proposals[period]) revert AlreadyNudged();\n\n        IEpochGovernor.ProposalState state = IEpochGovernor(epochGovernor)\n            .result();\n\n        uint256 oldNeedle = needle;\n        if (state != IEpochGovernor.ProposalState.Expired) {\n            // move the needle up by 1 tick\n            if (state == IEpochGovernor.ProposalState.Succeeded) {\n                needle = oldNeedle + TICK > MAXIMUM_GAUGE_SCALE\n                    ? MAXIMUM_GAUGE_SCALE\n                    : needle + TICK;\n            } else {\n                // move the needle down by 1 tick\n                needle = oldNeedle - TICK < MINIMUM_GAUGE_SCALE\n                    ? MINIMUM_GAUGE_SCALE\n                    : needle - TICK;\n            }\n        }\n\n        proposals[period] = true;\n        // Might happen that needle did not move due to abstained or expired proposal.\n        emit Nudge(period, oldNeedle, needle);\n    }\n\n    /// @notice Updates the period of the current epoch. This function can be called\n    ///         by anyone. Chain fees accumulate in this contract continuously and\n    ///         can be distributed between the first and second recipient after\n    ///         the end of the specified period. In other words, the release of\n    ///         the accumulated fees must wait until the end of the period.\n    /// @dev    Needle position is used to determine the distribution ratio between\n    ///         the first and second recipient.\n    ///         1...first recipient amount..|..second recipient amount..100 [%]\n    ///                                     ^\n    ///                                   needle\n\n    function updatePeriod() external returns (uint256 period) {\n        period = activePeriod;\n        if (block.timestamp >= period + WEEK) {\n            uint256 oldPeriod = period;\n            period = (block.timestamp / WEEK) * WEEK;\n            activePeriod = period;\n\n            uint256 firstRecipientAmount;\n            uint256 secondRecipientAmount;\n\n            uint256 currentBalance = token.balanceOf(address(this));\n            if (currentBalance > 0) {\n                firstRecipientAmount =\n                    (currentBalance * needle) /\n                    MAXIMUM_GAUGE_SCALE;\n                secondRecipientAmount = currentBalance - firstRecipientAmount;\n\n                transferFirstRecipient(firstRecipientAmount);\n                transferSecondRecipient(secondRecipientAmount);\n            }\n\n            emit PeriodUpdated(\n                oldPeriod,\n                period,\n                firstRecipientAmount,\n                secondRecipientAmount\n            );\n        }\n    }\n\n    /// @notice Returns the address of the epoch governor.\n    ///         Must adhere to a 1 week epoch of a splitter.\n    function epochGovernor() internal view virtual returns (address);\n\n    /// @notice Transfers amount to the first recipient.\n    function transferFirstRecipient(uint256 amount) internal virtual;\n\n    /// @notice Transfers amount to the second recipient.\n    function transferSecondRecipient(uint256 amount) internal virtual;\n}\n"
    },
    "contracts/ve/Balance.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\nimport {SafeCastLibrary} from \"../libraries/SafeCastLibrary.sol\";\nimport {VotingEscrowState} from \"./VotingEscrowState.sol\";\n\nlibrary Balance {\n    using SafeCastLibrary for uint256;\n    using SafeCastLibrary for int128;\n\n    uint256 internal constant WEEK = 1 weeks;\n\n    /// @notice Binary search to get the user point index for a token id at or prior to a given timestamp\n    /// @dev If a user point does not exist prior to the timestamp, this will return 0.\n    /// @param _tokenId .\n    /// @param _timestamp .\n    /// @return User point index\n    function getPastUserPointIndex(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        uint256 _timestamp\n    ) internal view returns (uint256) {\n        uint256 _userEpoch = self.userPointEpoch[_tokenId];\n        if (_userEpoch == 0) return 0;\n        // First check most recent balance\n        if (self._userPointHistory[_tokenId][_userEpoch].ts <= _timestamp)\n            return (_userEpoch);\n        // Next check implicit zero balance\n        if (self._userPointHistory[_tokenId][1].ts > _timestamp) return 0;\n\n        uint256 lower = 0;\n        uint256 upper = _userEpoch;\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            IVotingEscrow.UserPoint storage userPoint = self._userPointHistory[\n                _tokenId\n            ][center];\n            if (userPoint.ts == _timestamp) {\n                return center;\n            } else if (userPoint.ts < _timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    /// @notice Binary search to get the global point index at or prior to a given timestamp\n    /// @dev If a checkpoint does not exist prior to the timestamp, this will return 0.\n    /// @param _timestamp .\n    /// @return Global point index\n    function getPastGlobalPointIndex(\n        VotingEscrowState.Storage storage self,\n        uint256 _timestamp\n    ) internal view returns (uint256) {\n        if (self.epoch == 0) return 0;\n        // First check most recent balance\n        if (self._pointHistory[self.epoch].ts <= _timestamp)\n            return (self.epoch);\n        // Next check implicit zero balance\n        if (self._pointHistory[1].ts > _timestamp) return 0;\n\n        uint256 lower = 0;\n        uint256 upper = self.epoch;\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            IVotingEscrow.GlobalPoint storage globalPoint = self._pointHistory[\n                center\n            ];\n            if (globalPoint.ts == _timestamp) {\n                return center;\n            } else if (globalPoint.ts < _timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    /// @notice Get the current voting power for `_tokenId`\n    /// @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\n    ///      Fetches last user point prior to a certain timestamp, then walks forward to timestamp.\n    /// @param _tokenId NFT for lock\n    /// @param _t Epoch time to return voting power at\n    /// @return User voting power\n    function _balanceOfNFTAt(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        uint256 _t\n    ) internal view returns (uint256) {\n        uint256 _epoch = getPastUserPointIndex(self, _tokenId, _t);\n        // epoch 0 is an empty point\n        if (_epoch == 0) return 0;\n        IVotingEscrow.UserPoint memory lastPoint = self._userPointHistory[\n            _tokenId\n        ][_epoch];\n        if (lastPoint.permanent != 0) {\n            return lastPoint.permanent;\n        } else {\n            lastPoint.bias -= lastPoint.slope * (_t - lastPoint.ts).toInt128();\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n            return lastPoint.bias.toUint256();\n        }\n    }\n\n    function _balanceOfNFT(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId\n    ) external view returns (uint256) {\n        if (self.ownershipChange[_tokenId] == block.number) return 0;\n        return _balanceOfNFTAt(self, _tokenId, block.timestamp);\n    }\n\n    /// @notice Calculate total voting power at some point in the past\n    /// @param _t Time to calculate the total voting power at\n    /// @return Total voting power at that time\n    function supplyAt(\n        VotingEscrowState.Storage storage self,\n        uint256 _t\n    ) external view returns (uint256) {\n        uint256 epoch_ = getPastGlobalPointIndex(self, _t);\n        // epoch 0 is an empty point\n        if (epoch_ == 0) return 0;\n        IVotingEscrow.GlobalPoint memory _point = self._pointHistory[epoch_];\n        int128 bias = _point.bias;\n        int128 slope = _point.slope;\n        uint256 ts = _point.ts;\n        uint256 t_i = (ts / WEEK) * WEEK;\n        for (uint256 i = 0; i < 255; ++i) {\n            t_i += WEEK;\n            int128 dSlope = 0;\n            if (t_i > _t) {\n                t_i = _t;\n            } else {\n                dSlope = self.slopeChanges[t_i];\n            }\n            bias -= slope * (t_i - ts).toInt128();\n            if (t_i == _t) {\n                break;\n            }\n            slope += dSlope;\n            ts = t_i;\n        }\n\n        if (bias < 0) {\n            bias = 0;\n        }\n        return bias.toUint256() + _point.permanentLockBalance;\n    }\n}\n"
    },
    "contracts/ve/Delegation.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport {VotingEscrowState} from \"./VotingEscrowState.sol\";\nimport {NFT} from \"./NFT.sol\";\nimport {VeERC2771Context} from \"./VeERC2771Context.sol\";\nimport {SafeCastLibrary} from \"../libraries/SafeCastLibrary.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\nimport {IVotes} from \"../governance/IVotes.sol\";\n\nlibrary Delegation {\n    using SafeCastLibrary for int128;\n    using NFT for VotingEscrowState.Storage;\n    using VeERC2771Context for VotingEscrowState.Storage;\n\n    struct SignatureData {\n        uint256 delegator;\n        uint256 delegatee;\n        uint256 nonce;\n        uint256 expiry;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\n            \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\n        );\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\n            \"Delegation(uint256 delegator,uint256 delegatee,uint256 nonce,uint256 expiry)\"\n        );\n\n    function delegate(\n        VotingEscrowState.Storage storage self,\n        uint256 delegator,\n        uint256 delegatee\n    ) external {\n        if (!self._isApprovedOrOwner(self._msgSender(), delegator))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        return _delegate(self, delegator, delegatee);\n    }\n\n    function delegateBySig(\n        VotingEscrowState.Storage storage self,\n        SignatureData calldata signatureData,\n        string calldata contractName,\n        string calldata contractVersion\n    ) external {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (\n            uint256(signatureData.s) >\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n        ) revert IVotingEscrow.InvalidSignatureS();\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(contractName)),\n                keccak256(bytes(contractVersion)),\n                block.chainid,\n                address(this)\n            )\n        );\n        bytes32 structHash = keccak256(\n            abi.encode(\n                DELEGATION_TYPEHASH,\n                signatureData.delegator,\n                signatureData.delegatee,\n                signatureData.nonce,\n                signatureData.expiry\n            )\n        );\n        bytes32 digest = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n        address signatory = ecrecover(\n            digest,\n            signatureData.v,\n            signatureData.r,\n            signatureData.s\n        );\n        if (!self._isApprovedOrOwner(signatory, signatureData.delegator))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        if (signatory == address(0)) revert IVotingEscrow.InvalidSignature();\n        if (signatureData.nonce != self.nonces[signatory]++)\n            revert IVotingEscrow.InvalidNonce();\n        if (block.timestamp > signatureData.expiry)\n            revert IVotingEscrow.SignatureExpired();\n        return\n            _delegate(self, signatureData.delegator, signatureData.delegatee);\n    }\n\n    /// @notice Record user delegation checkpoints. Used by voting system.\n    /// @dev Skips delegation if already delegated to `delegatee`.\n    function _delegate(\n        VotingEscrowState.Storage storage self,\n        uint256 _delegator,\n        uint256 _delegatee\n    ) internal {\n        IVotingEscrow.LockedBalance memory delegateLocked = self._locked[\n            _delegator\n        ];\n        if (!delegateLocked.isPermanent)\n            revert IVotingEscrow.NotPermanentLock();\n        if (_delegatee != 0 && self._ownerOf(_delegatee) == address(0))\n            revert IVotingEscrow.NonExistentToken();\n        if (self.ownershipChange[_delegator] == block.number)\n            revert IVotingEscrow.OwnershipChange();\n        if (_delegatee == _delegator) _delegatee = 0;\n        uint256 currentDelegate = self._delegates[_delegator];\n        if (currentDelegate == _delegatee) return;\n\n        uint256 delegatedBalance = delegateLocked.amount.toUint256();\n        _checkpointDelegator(\n            self,\n            _delegator,\n            _delegatee,\n            self._ownerOf(_delegator)\n        );\n        _checkpointDelegatee(self, _delegatee, delegatedBalance, true);\n\n        emit IVotes.DelegateChanged(\n            self._msgSender(),\n            currentDelegate,\n            _delegatee\n        );\n    }\n\n    /// @notice Used by `_mint`, `_transferFrom`, `_burn` and `delegate`\n    ///         to update delegator voting checkpoints.\n    ///         Automatically dedelegates, then updates checkpoint.\n    /// @dev This function depends on `_locked` and must be called prior to token state changes.\n    ///      If you wish to dedelegate only, use `_delegate(tokenId, 0)` instead.\n    /// @param _delegator The delegator to update checkpoints for\n    /// @param _delegatee The new delegatee for the delegator. Cannot be equal to `_delegator` (use 0 instead).\n    /// @param _owner The new (or current) owner for the delegator\n    function _checkpointDelegator(\n        VotingEscrowState.Storage storage self,\n        uint256 _delegator,\n        uint256 _delegatee,\n        address _owner\n    ) internal {\n        uint256 delegatedBalance = self._locked[_delegator].amount.toUint256();\n        uint48 numCheckpoint = self.numCheckpoints[_delegator];\n        IVotingEscrow.Checkpoint storage cpOld = numCheckpoint > 0\n            ? self._checkpoints[_delegator][numCheckpoint - 1]\n            : self._checkpoints[_delegator][0];\n        // Dedelegate from delegatee if delegated\n        _checkpointDelegatee(self, cpOld.delegatee, delegatedBalance, false);\n        IVotingEscrow.Checkpoint storage cp = self._checkpoints[_delegator][\n            numCheckpoint\n        ];\n        cp.fromTimestamp = block.timestamp;\n        cp.delegatedBalance = cpOld.delegatedBalance;\n        cp.delegatee = _delegatee;\n        cp.owner = _owner;\n\n        if (_isCheckpointInNewBlock(self, _delegator)) {\n            self.numCheckpoints[_delegator]++;\n        } else {\n            self._checkpoints[_delegator][numCheckpoint - 1] = cp;\n            delete self._checkpoints[_delegator][numCheckpoint];\n        }\n\n        self._delegates[_delegator] = _delegatee;\n    }\n\n    /// @notice Update delegatee's `delegatedBalance` by `balance`.\n    ///         Only updates if delegating to a new delegatee.\n    /// @dev If used with `balance` == `_locked[_tokenId].amount`, then this is the same as\n    ///      delegating or dedelegating from `_tokenId`\n    ///      If used with `balance` < `_locked[_tokenId].amount`, then this is used to adjust\n    ///      `delegatedBalance` when a user's balance is modified (e.g. `increaseAmount`, `merge` etc).\n    ///      If `delegatee` is 0 (i.e. user is not delegating), then do nothing.\n    /// @param _delegatee The delegatee's tokenId\n    /// @param balance_ The delta in balance change\n    /// @param _increase True if balance is increasing, false if decreasing\n    function _checkpointDelegatee(\n        VotingEscrowState.Storage storage self,\n        uint256 _delegatee,\n        uint256 balance_,\n        bool _increase\n    ) internal {\n        if (_delegatee == 0) return;\n        uint48 numCheckpoint = self.numCheckpoints[_delegatee];\n        IVotingEscrow.Checkpoint storage cpOld = numCheckpoint > 0\n            ? self._checkpoints[_delegatee][numCheckpoint - 1]\n            : self._checkpoints[_delegatee][0];\n        IVotingEscrow.Checkpoint storage cp = self._checkpoints[_delegatee][\n            numCheckpoint\n        ];\n        cp.fromTimestamp = block.timestamp;\n        cp.owner = cpOld.owner;\n        // do not expect balance_ > cpOld.delegatedBalance when decrementing but just in case\n        cp.delegatedBalance = _increase\n            ? cpOld.delegatedBalance + balance_\n            : (\n                balance_ < cpOld.delegatedBalance\n                    ? cpOld.delegatedBalance - balance_\n                    : 0\n            );\n        cp.delegatee = cpOld.delegatee;\n\n        if (_isCheckpointInNewBlock(self, _delegatee)) {\n            self.numCheckpoints[_delegatee]++;\n        } else {\n            self._checkpoints[_delegatee][numCheckpoint - 1] = cp;\n            delete self._checkpoints[_delegatee][numCheckpoint];\n        }\n    }\n\n    function _isCheckpointInNewBlock(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId\n    ) internal view returns (bool) {\n        uint48 _nCheckPoints = self.numCheckpoints[_tokenId];\n\n        if (\n            _nCheckPoints > 0 &&\n            self._checkpoints[_tokenId][_nCheckPoints - 1].fromTimestamp ==\n            block.timestamp\n        ) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /// @notice Retrieves historical voting balance for a token id at a given timestamp.\n    /// @dev If a checkpoint does not exist prior to the timestamp, this will return 0.\n    ///      The user must also own the token at the time in order to receive a voting balance.\n    /// @param _account .\n    /// @param _tokenId .\n    /// @param _timestamp .\n    /// @return Total voting balance including delegations at a given timestamp.\n    function getPastVotes(\n        VotingEscrowState.Storage storage self,\n        address _account,\n        uint256 _tokenId,\n        uint256 _timestamp\n    ) external view returns (uint256) {\n        uint48 _checkIndex = getPastVotesIndex(self, _tokenId, _timestamp);\n        IVotingEscrow.Checkpoint memory lastCheckpoint = self._checkpoints[\n            _tokenId\n        ][_checkIndex];\n        // If no point exists prior to the given timestamp, return 0\n        if (lastCheckpoint.fromTimestamp > _timestamp) return 0;\n        // Check ownership\n        if (_account != lastCheckpoint.owner) return 0;\n        uint256 votes = lastCheckpoint.delegatedBalance;\n        return\n            lastCheckpoint.delegatee == 0\n                ? votes +\n                    IVotingEscrow(address(this)).balanceOfNFTAt(\n                        _tokenId,\n                        _timestamp\n                    )\n                : votes;\n    }\n\n    /// @notice Binary search to get the voting checkpoint for a token id at or prior to a given timestamp.\n    /// @dev If a checkpoint does not exist prior to the timestamp, this will return 0.\n    /// @param _tokenId .\n    /// @param _timestamp .\n    /// @return The index of the checkpoint.\n    function getPastVotesIndex(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        uint256 _timestamp\n    ) internal view returns (uint48) {\n        uint48 nCheckpoints = self.numCheckpoints[_tokenId];\n        if (nCheckpoints == 0) return 0;\n        // First check most recent balance\n        if (\n            self._checkpoints[_tokenId][nCheckpoints - 1].fromTimestamp <=\n            _timestamp\n        ) return (nCheckpoints - 1);\n        // Next check implicit zero balance\n        if (self._checkpoints[_tokenId][0].fromTimestamp > _timestamp) return 0;\n\n        uint48 lower = 0;\n        uint48 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint48 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            IVotingEscrow.Checkpoint storage cp = self._checkpoints[_tokenId][\n                center\n            ];\n            if (cp.fromTimestamp == _timestamp) {\n                return center;\n            } else if (cp.fromTimestamp < _timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n}\n"
    },
    "contracts/ve/Escrow.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport {VotingEscrowState} from \"./VotingEscrowState.sol\";\nimport {Delegation} from \"./Delegation.sol\";\nimport {NFT} from \"./NFT.sol\";\nimport {VeERC2771Context} from \"./VeERC2771Context.sol\";\nimport {SafeCastLibrary} from \"../libraries/SafeCastLibrary.sol\";\nimport {IReward} from \"../interfaces/IReward.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC4906} from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nlibrary Escrow {\n    using SafeERC20 for IERC20;\n    using SafeCastLibrary for uint256;\n    using SafeCastLibrary for int128;\n    using NFT for VotingEscrowState.Storage;\n    using Delegation for VotingEscrowState.Storage;\n    using VeERC2771Context for VotingEscrowState.Storage;\n\n    uint256 internal constant WEEK = 1 weeks;\n    uint256 internal constant MAXTIME = 4 * 365 * 86400;\n    int128 internal constant iMAXTIME = 4 * 365 * 86400;\n    uint256 internal constant MULTIPLIER = 1 ether;\n\n    function depositFor(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        uint256 _value\n    ) external {\n        if (\n            self.escrowType[_tokenId] == IVotingEscrow.EscrowType.MANAGED &&\n            self._msgSender() != self.distributor\n        ) revert IVotingEscrow.NotDistributor();\n        _increaseAmountFor(\n            self,\n            _tokenId,\n            _value,\n            IVotingEscrow.DepositType.DEPOSIT_FOR_TYPE\n        );\n    }\n\n    /// @notice Deposit and lock tokens for a user\n    /// @param _tokenId NFT that holds lock\n    /// @param _value Amount to deposit\n    /// @param _unlockTime New time when to unlock the tokens, or 0 if unchanged\n    /// @param _oldLocked Previous locked amount / timestamp\n    /// @param _depositType The type of deposit\n    function _depositFor(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        uint256 _value,\n        uint256 _unlockTime,\n        IVotingEscrow.LockedBalance memory _oldLocked,\n        IVotingEscrow.DepositType _depositType\n    ) internal {\n        uint256 supplyBefore = self.supply;\n        self.supply = supplyBefore + _value;\n\n        // Set newLocked to _oldLocked without mangling memory\n        IVotingEscrow.LockedBalance memory newLocked;\n        (newLocked.amount, newLocked.end, newLocked.isPermanent) = (\n            _oldLocked.amount,\n            _oldLocked.end,\n            _oldLocked.isPermanent\n        );\n\n        // Adding to existing lock, or if a lock is expired - creating a new one\n        newLocked.amount += _value.toInt128();\n        if (_unlockTime != 0) {\n            newLocked.end = _unlockTime;\n        }\n        self._locked[_tokenId] = newLocked;\n\n        // Possibilities:\n        // Both _oldLocked.end could be current or expired (>/< block.timestamp)\n        // or if the lock is a permanent lock, then _oldLocked.end == 0\n        // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\n        // newLocked.end > block.timestamp (always)\n        _checkpoint(self, _tokenId, _oldLocked, newLocked);\n\n        address from = self._msgSender();\n        if (_value != 0) {\n            IERC20(self.token).safeTransferFrom(from, address(this), _value);\n        }\n\n        emit IVotingEscrow.Deposit(\n            from,\n            _tokenId,\n            _depositType,\n            _value,\n            newLocked.end,\n            block.timestamp\n        );\n        emit IVotingEscrow.Supply(supplyBefore, supplyBefore + _value);\n    }\n\n    /// @notice Record global and per-user data to checkpoints. Used by VotingEscrow system.\n    /// @param _tokenId NFT token ID. No user checkpoint if 0\n    /// @param _oldLocked Previous locked amount / end lock time for the user\n    /// @param _newLocked New locked amount / end lock time for the user\n    function _checkpoint(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        IVotingEscrow.LockedBalance memory _oldLocked,\n        IVotingEscrow.LockedBalance memory _newLocked\n    ) internal {\n        IVotingEscrow.UserPoint memory uOld;\n        IVotingEscrow.UserPoint memory uNew;\n        int128 oldDslope = 0;\n        int128 newDslope = 0;\n        uint256 _epoch = self.epoch;\n\n        if (_tokenId != 0) {\n            uNew.permanent = _newLocked.isPermanent\n                ? _newLocked.amount.toUint256()\n                : 0;\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (_oldLocked.end > block.timestamp && _oldLocked.amount > 0) {\n                uOld.slope = _oldLocked.amount / iMAXTIME;\n                uOld.bias =\n                    uOld.slope *\n                    (_oldLocked.end - block.timestamp).toInt128();\n            }\n            if (_newLocked.end > block.timestamp && _newLocked.amount > 0) {\n                uNew.slope = _newLocked.amount / iMAXTIME;\n                uNew.bias =\n                    uNew.slope *\n                    (_newLocked.end - block.timestamp).toInt128();\n            }\n\n            // Read values of scheduled changes in the slope\n            // _oldLocked.end can be in the past and in the future\n            // _newLocked.end can ONLY by in the FUTURE unless everything expired: than zeros\n            oldDslope = self.slopeChanges[_oldLocked.end];\n            if (_newLocked.end != 0) {\n                if (_newLocked.end == _oldLocked.end) {\n                    newDslope = oldDslope;\n                } else {\n                    newDslope = self.slopeChanges[_newLocked.end];\n                }\n            }\n        }\n\n        IVotingEscrow.GlobalPoint memory lastPoint = IVotingEscrow.GlobalPoint({\n            bias: 0,\n            slope: 0,\n            ts: block.timestamp,\n            blk: block.number,\n            permanentLockBalance: 0\n        });\n        if (_epoch > 0) {\n            lastPoint = self._pointHistory[_epoch];\n        }\n        uint256 lastCheckpoint = lastPoint.ts;\n        // initialLastPoint is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        IVotingEscrow.GlobalPoint memory initialLastPoint = IVotingEscrow\n            .GlobalPoint({\n                bias: lastPoint.bias,\n                slope: lastPoint.slope,\n                ts: lastPoint.ts,\n                blk: lastPoint.blk,\n                permanentLockBalance: lastPoint.permanentLockBalance\n            });\n        uint256 blockSlope = 0; // dblock/dt\n        if (block.timestamp > lastPoint.ts) {\n            blockSlope =\n                (MULTIPLIER * (block.number - lastPoint.blk)) /\n                (block.timestamp - lastPoint.ts);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        (_epoch, lastPoint) = _updateHistory(\n            self,\n            _epoch,\n            lastPoint,\n            lastCheckpoint,\n            initialLastPoint,\n            blockSlope\n        );\n\n        if (_tokenId != 0) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            lastPoint.slope += (uNew.slope - uOld.slope);\n            lastPoint.bias += (uNew.bias - uOld.bias);\n            if (lastPoint.slope < 0) {\n                lastPoint.slope = 0;\n            }\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n            lastPoint.permanentLockBalance = self.permanentLockBalance;\n        }\n\n        // If timestamp of last global point is the same, overwrite the last global point\n        // Else record the new global point into history\n        // Exclude epoch 0 (note: _epoch is always >= 1, see above)\n        // Two possible outcomes:\n        // Missing global checkpoints in prior weeks. In this case, _epoch = epoch + x, where x > 1\n        // No missing global checkpoints, but timestamp != block.timestamp. Create new checkpoint.\n        // No missing global checkpoints, but timestamp == block.timestamp. Overwrite last checkpoint.\n        if (\n            _epoch != 1 && self._pointHistory[_epoch - 1].ts == block.timestamp\n        ) {\n            // _epoch = epoch + 1, so we do not increment epoch\n            self._pointHistory[_epoch - 1] = lastPoint;\n        } else {\n            // more than one global point may have been written, so we update epoch\n            self.epoch = _epoch;\n            self._pointHistory[_epoch] = lastPoint;\n        }\n\n        if (_tokenId != 0) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [_newLocked.end]\n            // and add old_user_slope to [_oldLocked.end]\n            if (_oldLocked.end > block.timestamp) {\n                // oldDslope was <something> - uOld.slope, so we cancel that\n                oldDslope += uOld.slope;\n                if (_newLocked.end == _oldLocked.end) {\n                    oldDslope -= uNew.slope; // It was a new deposit, not extension\n                }\n                self.slopeChanges[_oldLocked.end] = oldDslope;\n            }\n\n            if (_newLocked.end > block.timestamp) {\n                // update slope if new lock is greater than old lock and is not permanent or if old lock is permanent\n                if ((_newLocked.end > _oldLocked.end)) {\n                    newDslope -= uNew.slope; // old slope disappeared at this point\n                    self.slopeChanges[_newLocked.end] = newDslope;\n                }\n                // else: we recorded it already in oldDslope\n            }\n            // If timestamp of last user point is the same, overwrite the last user point\n            // Else record the new user point into history\n            // Exclude epoch 0\n            uNew.ts = block.timestamp;\n            uNew.blk = block.number;\n            uint256 userEpoch = self.userPointEpoch[_tokenId];\n            if (\n                userEpoch != 0 &&\n                self._userPointHistory[_tokenId][userEpoch].ts ==\n                block.timestamp\n            ) {\n                self._userPointHistory[_tokenId][userEpoch] = uNew;\n            } else {\n                self.userPointEpoch[_tokenId] = ++userEpoch;\n                self._userPointHistory[_tokenId][userEpoch] = uNew;\n            }\n        }\n    }\n\n    function _updateHistory(\n        VotingEscrowState.Storage storage self,\n        uint256 _epoch,\n        IVotingEscrow.GlobalPoint memory lastPoint,\n        uint256 lastCheckpoint,\n        IVotingEscrow.GlobalPoint memory initialLastPoint,\n        uint256 blockSlope\n    ) internal returns (uint256, IVotingEscrow.GlobalPoint memory) {\n        uint256 t_i = (lastCheckpoint / WEEK) * WEEK;\n        for (uint256 i = 0; i < 255; ++i) {\n            // Hopefully it won't happen that this won't get used in 5 years!\n            // If it does, users will be able to withdraw but vote weight will be broken\n            t_i += WEEK; // Initial value of t_i is always larger than the ts of the last point\n            int128 d_slope = 0;\n            if (t_i > block.timestamp) {\n                t_i = block.timestamp;\n            } else {\n                d_slope = self.slopeChanges[t_i];\n            }\n            lastPoint.bias -=\n                lastPoint.slope *\n                (t_i - lastCheckpoint).toInt128();\n            lastPoint.slope += d_slope;\n            if (lastPoint.bias < 0) {\n                // This can happen\n                lastPoint.bias = 0;\n            }\n            if (lastPoint.slope < 0) {\n                // This cannot happen - just in case\n                lastPoint.slope = 0;\n            }\n            lastCheckpoint = t_i;\n            lastPoint.ts = t_i;\n            lastPoint.blk =\n                initialLastPoint.blk +\n                (blockSlope * (t_i - initialLastPoint.ts)) /\n                MULTIPLIER;\n            _epoch += 1;\n            if (t_i == block.timestamp) {\n                lastPoint.blk = block.number;\n                break;\n            } else {\n                self._pointHistory[_epoch] = lastPoint;\n            }\n        }\n        return (_epoch, lastPoint);\n    }\n\n    /// @dev Deposit `_value` tokens for `_to` and lock for `_lockDuration`\n    /// @param _value Amount to deposit\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    function _createLock(\n        VotingEscrowState.Storage storage self,\n        uint256 _value,\n        uint256 _lockDuration,\n        address _to\n    ) external returns (uint256) {\n        uint256 unlockTime = ((block.timestamp + _lockDuration) / WEEK) * WEEK; // Locktime is rounded down to weeks\n\n        if (_value == 0) revert IVotingEscrow.ZeroAmount();\n        if (unlockTime <= block.timestamp)\n            revert IVotingEscrow.LockDurationNotInFuture();\n        if (unlockTime > block.timestamp + MAXTIME)\n            revert IVotingEscrow.LockDurationTooLong();\n\n        uint256 _tokenId = ++self.tokenId;\n        self._mint(_to, _tokenId);\n\n        _depositFor(\n            self,\n            _tokenId,\n            _value,\n            unlockTime,\n            self._locked[_tokenId],\n            IVotingEscrow.DepositType.CREATE_LOCK_TYPE\n        );\n        return _tokenId;\n    }\n\n    function increaseAmount(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        uint256 _value\n    ) external {\n        if (!self._isApprovedOrOwner(self._msgSender(), _tokenId))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        _increaseAmountFor(\n            self,\n            _tokenId,\n            _value,\n            IVotingEscrow.DepositType.INCREASE_LOCK_AMOUNT\n        );\n    }\n\n    function _increaseAmountFor(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        uint256 _value,\n        IVotingEscrow.DepositType _depositType\n    ) internal {\n        IVotingEscrow.EscrowType _escrowType = self.escrowType[_tokenId];\n        if (_escrowType == IVotingEscrow.EscrowType.LOCKED)\n            revert IVotingEscrow.NotManagedOrNormalNFT();\n\n        IVotingEscrow.LockedBalance memory oldLocked = self._locked[_tokenId];\n\n        if (_value == 0) revert IVotingEscrow.ZeroAmount();\n        if (oldLocked.amount <= 0) revert IVotingEscrow.NoLockFound();\n        if (oldLocked.end <= block.timestamp && !oldLocked.isPermanent)\n            revert IVotingEscrow.LockExpired();\n\n        if (oldLocked.isPermanent) self.permanentLockBalance += _value;\n        self._checkpointDelegatee(self._delegates[_tokenId], _value, true);\n        _depositFor(self, _tokenId, _value, 0, oldLocked, _depositType);\n\n        if (_escrowType == IVotingEscrow.EscrowType.MANAGED) {\n            // increaseAmount called on managed tokens are treated as locked rewards\n            address _lockedManagedReward = self.managedToLocked[_tokenId];\n            address _token = self.token;\n            IERC20(_token).safeApprove(_lockedManagedReward, _value);\n            IReward(_lockedManagedReward).notifyRewardAmount(_token, _value);\n            IERC20(_token).safeApprove(_lockedManagedReward, 0);\n        }\n\n        emit IERC4906.MetadataUpdate(_tokenId);\n    }\n\n    function increaseUnlockTime(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        uint256 _lockDuration\n    ) external {\n        if (!self._isApprovedOrOwner(self._msgSender(), _tokenId))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.NORMAL)\n            revert IVotingEscrow.NotNormalNFT();\n\n        IVotingEscrow.LockedBalance memory oldLocked = self._locked[_tokenId];\n        if (oldLocked.isPermanent) revert IVotingEscrow.PermanentLock();\n        uint256 unlockTime = ((block.timestamp + _lockDuration) / WEEK) * WEEK; // Locktime is rounded down to weeks\n\n        if (oldLocked.end <= block.timestamp)\n            revert IVotingEscrow.LockExpired();\n        if (oldLocked.amount <= 0) revert IVotingEscrow.NoLockFound();\n        if (unlockTime <= oldLocked.end)\n            revert IVotingEscrow.LockDurationNotInFuture();\n        if (unlockTime > block.timestamp + MAXTIME)\n            revert IVotingEscrow.LockDurationTooLong();\n\n        _depositFor(\n            self,\n            _tokenId,\n            0,\n            unlockTime,\n            oldLocked,\n            IVotingEscrow.DepositType.INCREASE_UNLOCK_TIME\n        );\n\n        emit IERC4906.MetadataUpdate(_tokenId);\n    }\n\n    function withdraw(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId\n    ) external {\n        address sender = self._msgSender();\n        if (!self._isApprovedOrOwner(sender, _tokenId))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        if (self.voted[_tokenId]) revert IVotingEscrow.AlreadyVoted();\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.NORMAL)\n            revert IVotingEscrow.NotNormalNFT();\n\n        IVotingEscrow.LockedBalance memory oldLocked = self._locked[_tokenId];\n        if (oldLocked.isPermanent) revert IVotingEscrow.PermanentLock();\n        if (block.timestamp < oldLocked.end)\n            revert IVotingEscrow.LockNotExpired();\n        uint256 value = oldLocked.amount.toUint256();\n\n        // Burn the NFT\n        self._burn(_tokenId);\n        self._locked[_tokenId] = IVotingEscrow.LockedBalance(0, 0, false);\n        uint256 supplyBefore = self.supply;\n        self.supply = supplyBefore - value;\n\n        // oldLocked can have either expired <= timestamp or zero end\n        // oldLocked has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(\n            self,\n            _tokenId,\n            oldLocked,\n            IVotingEscrow.LockedBalance(0, 0, false)\n        );\n\n        IERC20(self.token).safeTransfer(sender, value);\n\n        emit IVotingEscrow.Withdraw(sender, _tokenId, value, block.timestamp);\n        emit IVotingEscrow.Supply(supplyBefore, supplyBefore - value);\n    }\n\n    function merge(\n        VotingEscrowState.Storage storage self,\n        uint256 _from,\n        uint256 _to\n    ) external {\n        address sender = self._msgSender();\n        if (self.voted[_from]) revert IVotingEscrow.AlreadyVoted();\n        if (self.escrowType[_from] != IVotingEscrow.EscrowType.NORMAL)\n            revert IVotingEscrow.NotNormalNFT();\n        if (self.escrowType[_to] != IVotingEscrow.EscrowType.NORMAL)\n            revert IVotingEscrow.NotNormalNFT();\n        if (_from == _to) revert IVotingEscrow.SameNFT();\n        if (!self._isApprovedOrOwner(sender, _from))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        if (!self._isApprovedOrOwner(sender, _to))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        IVotingEscrow.LockedBalance memory oldLockedTo = self._locked[_to];\n        if (oldLockedTo.end <= block.timestamp && !oldLockedTo.isPermanent)\n            revert IVotingEscrow.LockExpired();\n\n        IVotingEscrow.LockedBalance memory oldLockedFrom = self._locked[_from];\n        if (oldLockedFrom.isPermanent) revert IVotingEscrow.PermanentLock();\n        uint256 end = oldLockedFrom.end >= oldLockedTo.end\n            ? oldLockedFrom.end\n            : oldLockedTo.end;\n\n        self._burn(_from);\n        self._locked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\n        _checkpoint(\n            self,\n            _from,\n            oldLockedFrom,\n            IVotingEscrow.LockedBalance(0, 0, false)\n        );\n\n        IVotingEscrow.LockedBalance memory newLockedTo;\n        newLockedTo.amount = oldLockedTo.amount + oldLockedFrom.amount;\n        newLockedTo.isPermanent = oldLockedTo.isPermanent;\n        if (newLockedTo.isPermanent) {\n            self.permanentLockBalance += oldLockedFrom.amount.toUint256();\n        } else {\n            newLockedTo.end = end;\n        }\n        self._checkpointDelegatee(\n            self._delegates[_to],\n            oldLockedFrom.amount.toUint256(),\n            true\n        );\n        _checkpoint(self, _to, oldLockedTo, newLockedTo);\n        self._locked[_to] = newLockedTo;\n\n        emit IVotingEscrow.Merge(\n            sender,\n            _from,\n            _to,\n            oldLockedFrom.amount.toUint256(),\n            oldLockedTo.amount.toUint256(),\n            newLockedTo.amount.toUint256(),\n            newLockedTo.end,\n            block.timestamp\n        );\n        emit IERC4906.MetadataUpdate(_to);\n    }\n\n    function split(\n        VotingEscrowState.Storage storage self,\n        uint256 _from,\n        uint256 _amount\n    ) external returns (uint256 _tokenId1, uint256 _tokenId2) {\n        address sender = self._msgSender();\n        address owner = self._ownerOf(_from);\n        if (owner == address(0)) revert IVotingEscrow.SplitNoOwner();\n        if (!self.canSplit[owner] && !self.canSplit[address(0)])\n            revert IVotingEscrow.SplitNotAllowed();\n        if (self.escrowType[_from] != IVotingEscrow.EscrowType.NORMAL)\n            revert IVotingEscrow.NotNormalNFT();\n        if (self.voted[_from]) revert IVotingEscrow.AlreadyVoted();\n        if (!self._isApprovedOrOwner(sender, _from))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        IVotingEscrow.LockedBalance memory newLocked = self._locked[_from];\n        if (newLocked.end <= block.timestamp && !newLocked.isPermanent)\n            revert IVotingEscrow.LockExpired();\n        int128 _splitAmount = _amount.toInt128();\n        if (_splitAmount == 0) revert IVotingEscrow.ZeroAmount();\n        if (newLocked.amount <= _splitAmount)\n            revert IVotingEscrow.AmountTooBig();\n\n        // Zero out and burn old veNFT\n        self._burn(_from);\n        self._locked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\n        _checkpoint(\n            self,\n            _from,\n            newLocked,\n            IVotingEscrow.LockedBalance(0, 0, false)\n        );\n\n        // Create new veNFT using old balance - amount\n        newLocked.amount -= _splitAmount;\n        _tokenId1 = _createSplitNFT(self, owner, newLocked);\n\n        // Create new veNFT using amount\n        newLocked.amount = _splitAmount;\n        _tokenId2 = _createSplitNFT(self, owner, newLocked);\n\n        emit IVotingEscrow.Split(\n            _from,\n            _tokenId1,\n            _tokenId2,\n            sender,\n            self._locked[_tokenId1].amount.toUint256(),\n            _splitAmount.toUint256(),\n            newLocked.end,\n            block.timestamp\n        );\n    }\n\n    function _createSplitNFT(\n        VotingEscrowState.Storage storage self,\n        address _to,\n        IVotingEscrow.LockedBalance memory _newLocked\n    ) internal returns (uint256 _tokenId) {\n        _tokenId = ++self.tokenId;\n        self._locked[_tokenId] = _newLocked;\n        _checkpoint(\n            self,\n            _tokenId,\n            IVotingEscrow.LockedBalance(0, 0, false),\n            _newLocked\n        );\n        self._mint(_to, _tokenId);\n    }\n\n    function toggleSplit(\n        VotingEscrowState.Storage storage self,\n        address _account,\n        bool _bool\n    ) external {\n        if (self._msgSender() != self.team) revert IVotingEscrow.NotTeam();\n        self.canSplit[_account] = _bool;\n    }\n\n    function lockPermanent(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId\n    ) external {\n        address sender = self._msgSender();\n        if (!self._isApprovedOrOwner(sender, _tokenId))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.NORMAL)\n            revert IVotingEscrow.NotNormalNFT();\n        IVotingEscrow.LockedBalance memory _newLocked = self._locked[_tokenId];\n        if (_newLocked.isPermanent) revert IVotingEscrow.PermanentLock();\n        if (_newLocked.end <= block.timestamp)\n            revert IVotingEscrow.LockExpired();\n        if (_newLocked.amount <= 0) revert IVotingEscrow.NoLockFound();\n\n        uint256 _amount = _newLocked.amount.toUint256();\n        self.permanentLockBalance += _amount;\n        _newLocked.end = 0;\n        _newLocked.isPermanent = true;\n        _checkpoint(self, _tokenId, self._locked[_tokenId], _newLocked);\n        self._locked[_tokenId] = _newLocked;\n\n        emit IVotingEscrow.LockPermanent(\n            sender,\n            _tokenId,\n            _amount,\n            block.timestamp\n        );\n        emit IERC4906.MetadataUpdate(_tokenId);\n    }\n\n    function unlockPermanent(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId\n    ) external {\n        address sender = self._msgSender();\n        if (!self._isApprovedOrOwner(sender, _tokenId))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.NORMAL)\n            revert IVotingEscrow.NotNormalNFT();\n        if (self.voted[_tokenId]) revert IVotingEscrow.AlreadyVoted();\n        IVotingEscrow.LockedBalance memory _newLocked = self._locked[_tokenId];\n        if (!_newLocked.isPermanent) revert IVotingEscrow.NotPermanentLock();\n\n        uint256 _amount = _newLocked.amount.toUint256();\n        self.permanentLockBalance -= _amount;\n        _newLocked.end = ((block.timestamp + MAXTIME) / WEEK) * WEEK;\n        _newLocked.isPermanent = false;\n        self._delegate(_tokenId, 0);\n        _checkpoint(self, _tokenId, self._locked[_tokenId], _newLocked);\n        self._locked[_tokenId] = _newLocked;\n\n        emit IVotingEscrow.UnlockPermanent(\n            sender,\n            _tokenId,\n            _amount,\n            block.timestamp\n        );\n        emit IERC4906.MetadataUpdate(_tokenId);\n    }\n}\n"
    },
    "contracts/ve/ManagedNFT.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport {VotingEscrowState} from \"./VotingEscrowState.sol\";\nimport {Escrow} from \"./Escrow.sol\";\nimport {NFT} from \"./NFT.sol\";\nimport {Delegation} from \"./Delegation.sol\";\nimport {Balance} from \"./Balance.sol\";\nimport {VeERC2771Context} from \"./VeERC2771Context.sol\";\nimport {SafeCastLibrary} from \"../libraries/SafeCastLibrary.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\nimport {IReward} from \"../interfaces/IReward.sol\";\nimport {IVoter} from \"../interfaces/IVoter.sol\";\nimport {IManagedRewardsFactory} from \"../interfaces/factories/IManagedRewardsFactory.sol\";\nimport {IFactoryRegistry} from \"../interfaces/factories/IFactoryRegistry.sol\";\nimport {IERC4906} from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\n\nlibrary ManagedNFT {\n    using SafeCastLibrary for uint256;\n    using SafeCastLibrary for int128;\n    using NFT for VotingEscrowState.Storage;\n    using Escrow for VotingEscrowState.Storage;\n    using Delegation for VotingEscrowState.Storage;\n    using Balance for VotingEscrowState.Storage;\n    using VeERC2771Context for VotingEscrowState.Storage;\n\n    function createManagedLockFor(\n        VotingEscrowState.Storage storage self,\n        address _to\n    ) external returns (uint256 _mTokenId) {\n        address sender = self._msgSender();\n        if (\n            sender != self.allowedManager &&\n            sender != IVoter(self.voter).governor()\n        ) revert IVotingEscrow.NotGovernorOrManager();\n\n        _mTokenId = ++self.tokenId;\n        self._mint(_to, _mTokenId);\n        self._depositFor(\n            _mTokenId,\n            0,\n            0,\n            IVotingEscrow.LockedBalance(0, 0, true),\n            IVotingEscrow.DepositType.CREATE_LOCK_TYPE\n        );\n\n        self.escrowType[_mTokenId] = IVotingEscrow.EscrowType.MANAGED;\n\n        (\n            address _lockedManagedReward,\n            address _freeManagedReward\n        ) = IManagedRewardsFactory(\n                IFactoryRegistry(self.factoryRegistry).managedRewardsFactory()\n            ).createRewards(self.trustedForwarder, self.voter);\n        self.managedToLocked[_mTokenId] = _lockedManagedReward;\n        self.managedToFree[_mTokenId] = _freeManagedReward;\n\n        emit IVotingEscrow.CreateManaged(\n            _to,\n            _mTokenId,\n            sender,\n            _lockedManagedReward,\n            _freeManagedReward\n        );\n    }\n\n    function depositManaged(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        uint256 _mTokenId\n    ) external {\n        if (self._msgSender() != self.voter) revert IVotingEscrow.NotVoter();\n        if (self.escrowType[_mTokenId] != IVotingEscrow.EscrowType.MANAGED)\n            revert IVotingEscrow.NotManagedNFT();\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.NORMAL)\n            revert IVotingEscrow.NotNormalNFT();\n        if (self._balanceOfNFTAt(_tokenId, block.timestamp) == 0)\n            revert IVotingEscrow.ZeroBalance();\n\n        // adjust user nft\n        int128 _amount = self._locked[_tokenId].amount;\n        if (self._locked[_tokenId].isPermanent) {\n            self.permanentLockBalance -= _amount.toUint256();\n            self._delegate(_tokenId, 0);\n        }\n        self._checkpoint(\n            _tokenId,\n            self._locked[_tokenId],\n            IVotingEscrow.LockedBalance(0, 0, false)\n        );\n        self._locked[_tokenId] = IVotingEscrow.LockedBalance(0, 0, false);\n\n        // adjust managed nft\n        uint256 _weight = _amount.toUint256();\n        self.permanentLockBalance += _weight;\n        IVotingEscrow.LockedBalance memory newLocked = self._locked[_mTokenId];\n        newLocked.amount += _amount;\n        self._checkpointDelegatee(self._delegates[_mTokenId], _weight, true);\n        self._checkpoint(_mTokenId, self._locked[_mTokenId], newLocked);\n        self._locked[_mTokenId] = newLocked;\n\n        self.weights[_tokenId][_mTokenId] = _weight;\n        self.idToManaged[_tokenId] = _mTokenId;\n        self.escrowType[_tokenId] = IVotingEscrow.EscrowType.LOCKED;\n\n        address _lockedManagedReward = self.managedToLocked[_mTokenId];\n        IReward(_lockedManagedReward)._deposit(_weight, _tokenId);\n        address _freeManagedReward = self.managedToFree[_mTokenId];\n        IReward(_freeManagedReward)._deposit(_weight, _tokenId);\n\n        emit IVotingEscrow.DepositManaged(\n            self._ownerOf(_tokenId),\n            _tokenId,\n            _mTokenId,\n            _weight,\n            block.timestamp\n        );\n        emit IERC4906.MetadataUpdate(_tokenId);\n    }\n\n    function withdrawManaged(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId\n    ) external {\n        uint256 _mTokenId = self.idToManaged[_tokenId];\n        if (self._msgSender() != self.voter) revert IVotingEscrow.NotVoter();\n        if (_mTokenId == 0) revert IVotingEscrow.InvalidManagedNFTId();\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.LOCKED)\n            revert IVotingEscrow.NotLockedNFT();\n\n        // update accrued rewards\n        address _lockedManagedReward = self.managedToLocked[_mTokenId];\n        address _freeManagedReward = self.managedToFree[_mTokenId];\n        uint256 _weight = self.weights[_tokenId][_mTokenId];\n        uint256 _reward = IReward(_lockedManagedReward).earned(\n            address(self.token),\n            _tokenId\n        );\n        uint256 _total = _weight + _reward;\n        uint256 _unlockTime = ((block.timestamp + Escrow.MAXTIME) /\n            Escrow.WEEK) * Escrow.WEEK;\n\n        // claim locked rewards (rebases + compounded reward)\n        address[] memory rewards = new address[](1);\n        rewards[0] = address(self.token);\n        IReward(_lockedManagedReward).getReward(_tokenId, rewards);\n\n        _adjustUserNFT(self, _tokenId, _total, _unlockTime);\n        _adjustManagedNFT(self, _mTokenId, _total);\n\n        IReward(_lockedManagedReward)._withdraw(_weight, _tokenId);\n        IReward(_freeManagedReward)._withdraw(_weight, _tokenId);\n\n        delete self.idToManaged[_tokenId];\n        delete self.weights[_tokenId][_mTokenId];\n        delete self.escrowType[_tokenId];\n\n        emit IVotingEscrow.WithdrawManaged(\n            self._ownerOf(_tokenId),\n            _tokenId,\n            _mTokenId,\n            _total,\n            block.timestamp\n        );\n        emit IERC4906.MetadataUpdate(_tokenId);\n    }\n\n    function _adjustUserNFT(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        uint256 _total,\n        uint256 _unlockTime\n    ) internal {\n        IVotingEscrow.LockedBalance memory newLockedNormal = IVotingEscrow\n            .LockedBalance(_total.toInt128(), _unlockTime, false);\n        self._checkpoint(_tokenId, self._locked[_tokenId], newLockedNormal);\n        self._locked[_tokenId] = newLockedNormal;\n    }\n\n    function _adjustManagedNFT(\n        VotingEscrowState.Storage storage self,\n        uint256 _mTokenId,\n        uint256 _total\n    ) internal {\n        IVotingEscrow.LockedBalance memory newLockedManaged = self._locked[\n            _mTokenId\n        ];\n        // do not expect _total > locked.amount / permanentLockBalance but just in case\n        newLockedManaged.amount -= (\n            _total.toInt128() < newLockedManaged.amount\n                ? _total.toInt128()\n                : newLockedManaged.amount\n        );\n        self.permanentLockBalance -= (\n            _total < self.permanentLockBalance\n                ? _total\n                : self.permanentLockBalance\n        );\n        self._checkpointDelegatee(self._delegates[_mTokenId], _total, false);\n        self._checkpoint(_mTokenId, self._locked[_mTokenId], newLockedManaged);\n        self._locked[_mTokenId] = newLockedManaged;\n    }\n\n    function setAllowedManager(\n        VotingEscrowState.Storage storage self,\n        address _allowedManager\n    ) external {\n        if (self._msgSender() != IVoter(self.voter).governor())\n            revert IVotingEscrow.NotGovernor();\n        if (_allowedManager == self.allowedManager)\n            revert IVotingEscrow.SameAddress();\n        if (_allowedManager == address(0)) revert IVotingEscrow.ZeroAddress();\n        self.allowedManager = _allowedManager;\n        emit IVotingEscrow.SetAllowedManager(_allowedManager);\n    }\n\n    function setManagedState(\n        VotingEscrowState.Storage storage self,\n        uint256 _mTokenId,\n        bool _state\n    ) external {\n        if (\n            self._msgSender() != IVoter(self.voter).emergencyCouncil() &&\n            self._msgSender() != IVoter(self.voter).governor()\n        ) revert IVotingEscrow.NotEmergencyCouncilOrGovernor();\n        if (self.escrowType[_mTokenId] != IVotingEscrow.EscrowType.MANAGED)\n            revert IVotingEscrow.NotManagedNFT();\n        if (self.deactivated[_mTokenId] == _state)\n            revert IVotingEscrow.SameState();\n        self.deactivated[_mTokenId] = _state;\n    }\n}\n"
    },
    "contracts/ve/NFT.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport {VotingEscrowState} from \"./VotingEscrowState.sol\";\nimport {Delegation} from \"./Delegation.sol\";\nimport {VeERC2771Context} from \"./VeERC2771Context.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\nimport {IVeArtProxy} from \"../interfaces/IVeArtProxy.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nlibrary NFT {\n    using Delegation for VotingEscrowState.Storage;\n    using VeERC2771Context for VotingEscrowState.Storage;\n\n    function approve(\n        VotingEscrowState.Storage storage self,\n        address _approved,\n        uint256 _tokenId\n    ) external {\n        address sender = self._msgSender();\n        address owner = _ownerOf(self, _tokenId);\n        // Throws if `_tokenId` is not a valid NFT\n        if (owner == address(0)) revert IVotingEscrow.ZeroAddress();\n        // Throws if `_approved` is the current owner\n        if (owner == _approved) revert IVotingEscrow.SameAddress();\n        // Check requirements\n        bool senderIsOwner = (_ownerOf(self, _tokenId) == sender);\n        bool senderIsApprovedForAll = (self.ownerToOperators[owner])[sender];\n        if (!senderIsOwner && !senderIsApprovedForAll)\n            revert IVotingEscrow.NotApprovedOrOwner();\n        // Set the approval\n        self.idToApprovals[_tokenId] = _approved;\n        emit IERC721.Approval(owner, _approved, _tokenId);\n    }\n\n    function setApprovalForAll(\n        VotingEscrowState.Storage storage self,\n        address _operator,\n        bool _approved\n    ) external {\n        address sender = self._msgSender();\n        // Throws if `_operator` is the `msg.sender`\n        if (_operator == sender) revert IVotingEscrow.SameAddress();\n        self.ownerToOperators[sender][_operator] = _approved;\n        emit IERC721.ApprovalForAll(sender, _operator, _approved);\n    }\n\n    function safeTransferFrom(\n        VotingEscrowState.Storage storage self,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory _data\n    ) external {\n        address sender = self._msgSender();\n        _transferFrom(self, _from, _to, _tokenId, sender);\n\n        if (_isContract(_to)) {\n            // Throws if transfer destination is a contract which does not implement 'onERC721Received'\n            try\n                IERC721Receiver(_to).onERC721Received(\n                    sender,\n                    _from,\n                    _tokenId,\n                    _data\n                )\n            returns (bytes4 response) {\n                if (\n                    response != IERC721Receiver(_to).onERC721Received.selector\n                ) {\n                    revert IVotingEscrow.ERC721ReceiverRejectedTokens();\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert IVotingEscrow\n                        .ERC721TransferToNonERC721ReceiverImplementer();\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    function _transferFrom(\n        VotingEscrowState.Storage storage self,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        address _sender\n    ) internal {\n        if (self.escrowType[_tokenId] == IVotingEscrow.EscrowType.LOCKED)\n            revert IVotingEscrow.NotManagedOrNormalNFT();\n        // Check requirements\n        if (!_isApprovedOrOwner(self, _sender, _tokenId))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        // Clear approval. Throws if `_from` is not the current owner\n        if (_ownerOf(self, _tokenId) != _from) revert IVotingEscrow.NotOwner();\n        delete self.idToApprovals[_tokenId];\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\n        _removeTokenFrom(self, _from, _tokenId);\n        // Update voting checkpoints\n        self._checkpointDelegator(_tokenId, 0, _to);\n        // Add NFT\n        _addTokenTo(self, _to, _tokenId);\n        // Set the block of ownership transfer (for Flash NFT protection)\n        self.ownershipChange[_tokenId] = block.number;\n        // Log the transfer\n        emit IERC721.Transfer(_from, _to, _tokenId);\n    }\n\n    function _isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /// @dev Add a NFT to a given address\n    ///      Throws if `_tokenId` is owned by someone.\n    function _addTokenTo(\n        VotingEscrowState.Storage storage self,\n        address _to,\n        uint256 _tokenId\n    ) internal {\n        // Throws if `_tokenId` is owned by someone\n        assert(_ownerOf(self, _tokenId) == address(0));\n        // Change the owner\n        self.idToOwner[_tokenId] = _to;\n        // Update owner token index tracking\n        _addTokenToOwnerList(self, _to, _tokenId);\n        // Change count tracking\n        self.ownerToNFTokenCount[_to] += 1;\n    }\n\n    /// @dev Function to mint tokens\n    ///      Throws if `_to` is zero address.\n    ///      Throws if `_tokenId` is owned by someone.\n    /// @param _to The address that will receive the minted tokens.\n    /// @param _tokenId The token id to mint.\n    /// @return A boolean that indicates if the operation was successful.\n    function _mint(\n        VotingEscrowState.Storage storage self,\n        address _to,\n        uint256 _tokenId\n    ) internal returns (bool) {\n        // Throws if `_to` is zero address\n        assert(_to != address(0));\n        // Add NFT. Throws if `_tokenId` is owned by someone\n        _addTokenTo(self, _to, _tokenId);\n        // Update voting checkpoints\n        self._checkpointDelegator(_tokenId, 0, _to);\n        emit IERC721.Transfer(address(0), _to, _tokenId);\n        return true;\n    }\n\n    /// @dev Add a NFT to an index mapping to a given address\n    /// @param _to address of the receiver\n    /// @param _tokenId uint ID Of the token to be added\n    function _addTokenToOwnerList(\n        VotingEscrowState.Storage storage self,\n        address _to,\n        uint256 _tokenId\n    ) internal {\n        uint256 currentCount = self.ownerToNFTokenCount[_to];\n\n        self.ownerToNFTokenIdList[_to][currentCount] = _tokenId;\n        self.tokenToOwnerIndex[_tokenId] = currentCount;\n    }\n\n    function _ownerOf(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId\n    ) internal view returns (address) {\n        return self.idToOwner[_tokenId];\n    }\n\n    function _isApprovedOrOwner(\n        VotingEscrowState.Storage storage self,\n        address _spender,\n        uint256 _tokenId\n    ) internal view returns (bool) {\n        address owner = _ownerOf(self, _tokenId);\n        bool spenderIsOwner = owner == _spender;\n        bool spenderIsApproved = _spender == self.idToApprovals[_tokenId];\n        bool spenderIsApprovedForAll = (self.ownerToOperators[owner])[_spender];\n        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\n    }\n\n    /// @dev Must be called prior to updating `LockedBalance`\n    function _burn(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId\n    ) internal {\n        address sender = self._msgSender();\n        if (!_isApprovedOrOwner(self, sender, _tokenId))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        address owner = _ownerOf(self, _tokenId);\n\n        // Clear approval\n        delete self.idToApprovals[_tokenId];\n        // Update voting checkpoints\n        self._checkpointDelegator(_tokenId, 0, address(0));\n        // Remove token\n        _removeTokenFrom(self, owner, _tokenId);\n        emit IERC721.Transfer(owner, address(0), _tokenId);\n    }\n\n    /// @dev Remove a NFT from a given address\n    ///      Throws if `_from` is not the current owner.\n    function _removeTokenFrom(\n        VotingEscrowState.Storage storage self,\n        address _from,\n        uint256 _tokenId\n    ) internal {\n        // Throws if `_from` is not the current owner\n        assert(_ownerOf(self, _tokenId) == _from);\n        // Change the owner\n        self.idToOwner[_tokenId] = address(0);\n        // Update owner token index tracking\n        _removeTokenFromOwnerList(self, _from, _tokenId);\n        // Change count tracking\n        self.ownerToNFTokenCount[_from] -= 1;\n    }\n\n    /// @dev Remove a NFT from an index mapping to a given address\n    /// @param _from address of the sender\n    /// @param _tokenId uint ID Of the token to be removed\n    function _removeTokenFromOwnerList(\n        VotingEscrowState.Storage storage self,\n        address _from,\n        uint256 _tokenId\n    ) internal {\n        // Delete\n        uint256 currentCount = self.ownerToNFTokenCount[_from] - 1;\n        uint256 currentIndex = self.tokenToOwnerIndex[_tokenId];\n\n        if (currentCount == currentIndex) {\n            // update ownerToNFTokenIdList\n            self.ownerToNFTokenIdList[_from][currentCount] = 0;\n            // update tokenToOwnerIndex\n            self.tokenToOwnerIndex[_tokenId] = 0;\n        } else {\n            uint256 lastTokenId = self.ownerToNFTokenIdList[_from][\n                currentCount\n            ];\n\n            // Add\n            // update ownerToNFTokenIdList\n            self.ownerToNFTokenIdList[_from][currentIndex] = lastTokenId;\n            // update tokenToOwnerIndex\n            self.tokenToOwnerIndex[lastTokenId] = currentIndex;\n\n            // Delete\n            // update ownerToNFTokenIdList\n            self.ownerToNFTokenIdList[_from][currentCount] = 0;\n            // update tokenToOwnerIndex\n            self.tokenToOwnerIndex[_tokenId] = 0;\n        }\n    }\n\n    function tokenURI(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId\n    ) external view returns (string memory) {\n        if (_ownerOf(self, _tokenId) == address(0))\n            revert IVotingEscrow.NonExistentToken();\n        return IVeArtProxy(self.artProxy).tokenURI(_tokenId);\n    }\n}\n"
    },
    "contracts/ve/VeERC2771Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Based on openzeppelin-contracts/contracts/metatx/ERC2771Context.sol\n\npragma solidity 0.8.24;\n\nimport {VotingEscrowState} from \"./VotingEscrowState.sol\";\n\n/**\n * @dev Context variant with ERC2771 support. Extracted to library to allow\n *      easy application inside libraries.\n */\nlibrary VeERC2771Context {\n    function isTrustedForwarder(\n        VotingEscrowState.Storage storage self,\n        address forwarder\n    ) internal view returns (bool) {\n        return forwarder == self.trustedForwarder;\n    }\n\n    function _msgSender(\n        VotingEscrowState.Storage storage self\n    ) internal view returns (address sender) {\n        if (isTrustedForwarder(self, msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            /// @solidity memory-safe-assembly\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return msg.sender;\n        }\n    }\n\n    function _msgData(\n        VotingEscrowState.Storage storage self\n    ) internal view returns (bytes calldata) {\n        if (isTrustedForwarder(self, msg.sender)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return msg.data;\n        }\n    }\n}\n"
    },
    "contracts/ve/VotingEscrowState.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\nimport {VeERC2771Context} from \"./VeERC2771Context.sol\";\nimport {IERC4906} from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\n\nlibrary VotingEscrowState {\n    using VeERC2771Context for Storage;\n\n    struct Storage {\n        /// @dev Address of Meta-tx Forwarder\n        address trustedForwarder;\n        /// @dev Address of FactoryRegistry.sol\n        address factoryRegistry;\n        /// @dev Address of token used to create a veNFT\n        address token;\n        /// @dev Address of RewardsDistributor.sol\n        address distributor;\n        /// @dev Address of Voter.sol\n        address voter;\n        /// @dev Address of Protocol Team multisig\n        address team;\n        /// @dev Address of art proxy used for on-chain art generation\n        address artProxy;\n        /// @dev Address which can create managed NFTs\n        address allowedManager;\n        /// @dev Global point history at a given index (epoch -> unsigned global point)\n        mapping(uint256 => IVotingEscrow.GlobalPoint) _pointHistory;\n        /// @dev Mapping of interface id to bool about whether or not it's supported\n        mapping(bytes4 => bool) supportedInterfaces;\n        /// @dev Current count of token\n        uint256 tokenId;\n        /*///////////////////////////////////////////////////////////////\n                                MANAGED NFT\n        //////////////////////////////////////////////////////////////*/\n\n        /// @dev Mapping of token id to escrow type\n        ///      Takes advantage of the fact default value is EscrowType.NORMAL\n        mapping(uint256 => IVotingEscrow.EscrowType) escrowType;\n        /// @dev Mapping of token id to managed id\n        mapping(uint256 => uint256) idToManaged;\n        /// @dev Mapping of user token id to managed token id to weight of token id\n        mapping(uint256 => mapping(uint256 => uint256)) weights;\n        /// @dev Mapping of managed id to deactivated state\n        mapping(uint256 => bool) deactivated;\n        /// @dev Mapping from managed nft id to locked managed rewards\n        ///      `token` denominated rewards (rebases/rewards) stored in locked\n        ///      managed rewards contract to prevent co-mingling of assets\n        mapping(uint256 => address) managedToLocked;\n        /// @dev Mapping from managed nft id to free managed rewards contract\n        ///      these rewards can be freely withdrawn by users\n        mapping(uint256 => address) managedToFree;\n        /*//////////////////////////////////////////////////////////////\n                            ERC721 BALANCE/OWNER\n        //////////////////////////////////////////////////////////////*/\n\n        /// @dev Mapping from NFT ID to the address that owns it.\n        mapping(uint256 => address) idToOwner;\n        /// @dev Mapping from owner address to count of his tokens.\n        mapping(address => uint256) ownerToNFTokenCount;\n        /*//////////////////////////////////////////////////////////////\n                                ERC721 APPROVAL\n        //////////////////////////////////////////////////////////////*/\n\n        /// @dev Mapping from NFT ID to approved address.\n        mapping(uint256 => address) idToApprovals;\n        /// @dev Mapping from owner address to mapping of operator addresses.\n        mapping(address => mapping(address => bool)) ownerToOperators;\n        mapping(uint256 => uint256) ownershipChange;\n        /*//////////////////////////////////////////////////////////////\n                            INTERNAL MINT/BURN\n        //////////////////////////////////////////////////////////////*/\n\n        /// @dev Mapping from owner address to mapping of index to tokenId\n        mapping(address => mapping(uint256 => uint256)) ownerToNFTokenIdList;\n        /// @dev Mapping from NFT ID to index of owner\n        mapping(uint256 => uint256) tokenToOwnerIndex;\n        /*//////////////////////////////////////////////////////////////\n                                    ESCROW\n        //////////////////////////////////////////////////////////////*/\n\n        /// @dev Total count of epochs witnessed since contract creation\n        uint256 epoch;\n        /// @dev Total amount of token() deposited\n        uint256 supply;\n        mapping(uint256 => IVotingEscrow.LockedBalance) _locked;\n        mapping(uint256 => IVotingEscrow.UserPoint[1000000000]) _userPointHistory;\n        mapping(uint256 => uint256) userPointEpoch;\n        /// @dev time -> signed slope change\n        mapping(uint256 => int128) slopeChanges;\n        /// @dev account -> can split\n        mapping(address => bool) canSplit;\n        /// @dev Aggregate permanent locked balances\n        uint256 permanentLockBalance;\n        /*///////////////////////////////////////////////////////////////\n                                    DAO VOTING\n        //////////////////////////////////////////////////////////////*/\n\n        /// @dev A record of each accounts delegate\n        mapping(uint256 => uint256) _delegates;\n        /// @dev A record of delegated token checkpoints for each tokenId, by index\n        mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint)) _checkpoints;\n        /// @dev The number of checkpoints for each tokenId\n        mapping(uint256 => uint48) numCheckpoints;\n        /// @dev A record of states for signing / validating signatures\n        mapping(address => uint256) nonces;\n        /*///////////////////////////////////////////////////////////////\n                                GAUGE VOTING\n        //////////////////////////////////////////////////////////////*/\n\n        /// @dev Information on whether a tokenId has already voted\n        mapping(uint256 => bool) voted;\n        // Reserved storage space in case we need to add more variables.\n        // The convention from OpenZeppelin suggests the storage space should\n        // add up to 50 slots. Here we want to have more slots as there are\n        // planned upgrades of the VotingEscrow contract. If more entires are\n        // added to the struct in the upcoming versions we need to reduce\n        // the array size.\n        // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n        uint256[50] __gap;\n    }\n\n    function setTeam(\n        VotingEscrowState.Storage storage self,\n        address _team\n    ) internal {\n        if (self._msgSender() != self.team) revert IVotingEscrow.NotTeam();\n        if (_team == address(0)) revert IVotingEscrow.ZeroAddress();\n        self.team = _team;\n    }\n\n    function setArtProxy(\n        VotingEscrowState.Storage storage self,\n        address _proxy\n    ) internal {\n        if (self._msgSender() != self.team) revert IVotingEscrow.NotTeam();\n        self.artProxy = _proxy;\n        emit IERC4906.BatchMetadataUpdate(0, type(uint256).max);\n    }\n\n    function setVoterAndDistributor(\n        VotingEscrowState.Storage storage self,\n        address _voter,\n        address _distributor\n    ) internal {\n        if (self._msgSender() != self.voter) revert IVotingEscrow.NotVoter();\n        self.voter = _voter;\n        self.distributor = _distributor;\n    }\n\n    function setVoting(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        bool _voted\n    ) internal {\n        if (self._msgSender() != self.voter) revert IVotingEscrow.NotVoter();\n        self.voted[_tokenId] = _voted;\n    }\n}\n"
    },
    "contracts/VeBTC.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.24;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\n\ncontract VeBTC is VotingEscrow {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _forwarder,\n        address _btc,\n        address _factoryRegistry\n    ) external initializer {\n        __initializeVotingEscrow(_forwarder, _btc, _factoryRegistry);\n    }\n\n    function name() external pure returns (string memory) {\n        return \"veBTC\";\n    }\n\n    function symbol() external pure returns (string memory) {\n        return \"veBTC\";\n    }\n\n    function version() external pure returns (string memory) {\n        return \"1.0.0\";\n    }\n\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/VotingEscrow.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {VotingEscrowState} from \"./ve/VotingEscrowState.sol\";\nimport {ManagedNFT} from \"./ve/ManagedNFT.sol\";\nimport {NFT} from \"./ve/NFT.sol\";\nimport {Escrow} from \"./ve/Escrow.sol\";\nimport {Delegation} from \"./ve/Delegation.sol\";\nimport {Balance} from \"./ve/Balance.sol\";\nimport {VeERC2771Context} from \"./ve/VeERC2771Context.sol\";\n\n/// @title Voting Escrow\n/// @notice veNFT implementation that escrows ERC-20 tokens in the form of an ERC-721 NFT\n/// @notice Votes have a weight depending on time, so that users are committed to the future of (whatever they are voting for)\n/// @author Modified from Solidly (https://github.com/solidlyexchange/solidly/blob/master/contracts/ve.sol)\n/// @author Modified from Curve (https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy)\n/// @author velodrome.finance, @figs999, @pegahcarter\n/// @dev Vote weight decays linearly over time. Lock time cannot be more than `MAXTIME` (4 years).\nabstract contract VotingEscrow is\n    IVotingEscrow,\n    Initializable,\n    ReentrancyGuardUpgradeable\n{\n    using VotingEscrowState for VotingEscrowState.Storage;\n    using NFT for VotingEscrowState.Storage;\n    using ManagedNFT for VotingEscrowState.Storage;\n    using Escrow for VotingEscrowState.Storage;\n    using Delegation for VotingEscrowState.Storage;\n    using Balance for VotingEscrowState.Storage;\n    using VeERC2771Context for VotingEscrowState.Storage;\n\n    VotingEscrowState.Storage internal self;\n\n    /// @dev ERC165 interface ID of ERC165\n    bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\n\n    /// @dev ERC165 interface ID of ERC721\n    bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\n\n    /// @dev ERC165 interface ID of ERC721Metadata\n    bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n    /// @dev ERC165 interface ID of ERC4906\n    bytes4 internal constant ERC4906_INTERFACE_ID = 0x49064906;\n\n    /// @dev ERC165 interface ID of ERC6372\n    bytes4 internal constant ERC6372_INTERFACE_ID = 0xda287a1d;\n\n    /// @param _trustedForwarder address of trusted forwarder\n    /// @param _token token address\n    /// @param _factoryRegistry Factory Registry address\n    function __initializeVotingEscrow(\n        address _trustedForwarder,\n        address _token,\n        address _factoryRegistry\n    ) internal {\n        __ReentrancyGuard_init();\n\n        self.trustedForwarder = _trustedForwarder;\n        self.token = _token;\n        self.factoryRegistry = _factoryRegistry;\n        self.team = self._msgSender();\n        self.voter = self._msgSender();\n\n        self._pointHistory[0].blk = block.number;\n        self._pointHistory[0].ts = block.timestamp;\n\n        self.supportedInterfaces[ERC165_INTERFACE_ID] = true;\n        self.supportedInterfaces[ERC721_INTERFACE_ID] = true;\n        self.supportedInterfaces[ERC721_METADATA_INTERFACE_ID] = true;\n        self.supportedInterfaces[ERC4906_INTERFACE_ID] = true;\n        self.supportedInterfaces[ERC6372_INTERFACE_ID] = true;\n\n        // mint-ish\n        emit Transfer(address(0), address(this), self.tokenId);\n        // burn-ish\n        emit Transfer(address(this), address(0), self.tokenId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MANAGED NFT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVotingEscrow\n    function createManagedLockFor(\n        address _to\n    ) external nonReentrant returns (uint256 _mTokenId) {\n        return self.createManagedLockFor(_to);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function depositManaged(\n        uint256 _tokenId,\n        uint256 _mTokenId\n    ) external nonReentrant {\n        self.depositManaged(_tokenId, _mTokenId);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function withdrawManaged(uint256 _tokenId) external nonReentrant {\n        self.withdrawManaged(_tokenId);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function setAllowedManager(address _allowedManager) external {\n        self.setAllowedManager(_allowedManager);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function setManagedState(uint256 _mTokenId, bool _state) external {\n        self.setManagedState(_mTokenId, _state);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    function setTeam(address _team) external {\n        self.setTeam(_team);\n    }\n\n    function setArtProxy(address _proxy) external {\n        self.setArtProxy(_proxy);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function tokenURI(uint256 _tokenId) external view returns (string memory) {\n        return self.tokenURI(_tokenId);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function ownerOf(uint256 _tokenId) external view returns (address) {\n        return self._ownerOf(_tokenId);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function balanceOf(address _owner) external view returns (uint256) {\n        return self.ownerToNFTokenCount[_owner];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function getApproved(uint256 _tokenId) external view returns (address) {\n        return self.idToApprovals[_tokenId];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function isApprovedForAll(\n        address _owner,\n        address _operator\n    ) external view returns (bool) {\n        return (self.ownerToOperators[_owner])[_operator];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function isApprovedOrOwner(\n        address _spender,\n        uint256 _tokenId\n    ) external view returns (bool) {\n        return self._isApprovedOrOwner(_spender, _tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVotingEscrow\n    function approve(address _approved, uint256 _tokenId) external {\n        self.approve(_approved, _tokenId);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function setApprovalForAll(address _operator, bool _approved) external {\n        self.setApprovalForAll(_operator, _approved);\n    }\n\n    /* TRANSFER FUNCTIONS */\n\n    /// @inheritdoc IVotingEscrow\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external {\n        self._transferFrom(_from, _to, _tokenId, self._msgSender());\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external {\n        safeTransferFrom(_from, _to, _tokenId, \"\");\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory _data\n    ) public {\n        self.safeTransferFrom(_from, _to, _tokenId, _data);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVotingEscrow\n    function supportsInterface(\n        bytes4 _interfaceID\n    ) external view returns (bool) {\n        return self.supportedInterfaces[_interfaceID];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function locked(\n        uint256 _tokenId\n    ) external view returns (LockedBalance memory) {\n        return self._locked[_tokenId];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function userPointHistory(\n        uint256 _tokenId,\n        uint256 _loc\n    ) external view returns (UserPoint memory) {\n        return self._userPointHistory[_tokenId][_loc];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function pointHistory(\n        uint256 _loc\n    ) external view returns (GlobalPoint memory) {\n        return self._pointHistory[_loc];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ESCROW LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVotingEscrow\n    function checkpoint() external nonReentrant {\n        self._checkpoint(\n            0,\n            LockedBalance(0, 0, false),\n            LockedBalance(0, 0, false)\n        );\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function depositFor(\n        uint256 _tokenId,\n        uint256 _value\n    ) external nonReentrant {\n        self.depositFor(_tokenId, _value);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function createLock(\n        uint256 _value,\n        uint256 _lockDuration\n    ) external nonReentrant returns (uint256) {\n        return self._createLock(_value, _lockDuration, self._msgSender());\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function createLockFor(\n        uint256 _value,\n        uint256 _lockDuration,\n        address _to\n    ) external nonReentrant returns (uint256) {\n        return self._createLock(_value, _lockDuration, _to);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function increaseAmount(\n        uint256 _tokenId,\n        uint256 _value\n    ) external nonReentrant {\n        self.increaseAmount(_tokenId, _value);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function increaseUnlockTime(\n        uint256 _tokenId,\n        uint256 _lockDuration\n    ) external nonReentrant {\n        self.increaseUnlockTime(_tokenId, _lockDuration);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function withdraw(uint256 _tokenId) external nonReentrant {\n        self.withdraw(_tokenId);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function merge(uint256 _from, uint256 _to) external nonReentrant {\n        self.merge(_from, _to);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function split(\n        uint256 _from,\n        uint256 _amount\n    ) external nonReentrant returns (uint256 _tokenId1, uint256 _tokenId2) {\n        return self.split(_from, _amount);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function toggleSplit(address _account, bool _bool) external {\n        self.toggleSplit(_account, _bool);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function lockPermanent(uint256 _tokenId) external {\n        self.lockPermanent(_tokenId);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function unlockPermanent(uint256 _tokenId) external {\n        self.unlockPermanent(_tokenId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           GAUGE VOTING STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVotingEscrow\n    function balanceOfNFT(uint256 _tokenId) public view returns (uint256) {\n        return self._balanceOfNFT(_tokenId);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function balanceOfNFTAt(\n        uint256 _tokenId,\n        uint256 _t\n    ) external view returns (uint256) {\n        return self._balanceOfNFTAt(_tokenId, _t);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function totalSupply() external view returns (uint256) {\n        return self.supplyAt(block.timestamp);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function totalSupplyAt(uint256 _timestamp) external view returns (uint256) {\n        return self.supplyAt(_timestamp);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE VOTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVotingEscrow\n    function setVoterAndDistributor(\n        address _voter,\n        address _distributor\n    ) external {\n        self.setVoterAndDistributor(_voter, _distributor);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function voting(uint256 _tokenId, bool _voted) external {\n        self.setVoting(_tokenId, _voted);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function delegates(uint256 delegator) external view returns (uint256) {\n        return self._delegates[delegator];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function checkpoints(\n        uint256 _tokenId,\n        uint48 _index\n    ) external view returns (Checkpoint memory) {\n        return self._checkpoints[_tokenId][_index];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function getPastVotes(\n        address _account,\n        uint256 _tokenId,\n        uint256 _timestamp\n    ) external view returns (uint256) {\n        return self.getPastVotes(_account, _tokenId, _timestamp);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function getPastTotalSupply(\n        uint256 _timestamp\n    ) external view returns (uint256) {\n        return self.supplyAt(_timestamp);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             DAO VOTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVotingEscrow\n    function delegate(uint256 delegator, uint256 delegatee) external {\n        return self.delegate(delegator, delegatee);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function delegateBySig(\n        uint256 delegator,\n        uint256 delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        return\n            self.delegateBySig(\n                Delegation.SignatureData({\n                    delegator: delegator,\n                    delegatee: delegatee,\n                    nonce: nonce,\n                    expiry: expiry,\n                    v: v,\n                    r: r,\n                    s: s\n                }),\n                this.name(),\n                this.version()\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC6372 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVotingEscrow\n    function clock() external view returns (uint48) {\n        return uint48(block.timestamp);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function CLOCK_MODE() external pure returns (string memory) {\n        return \"mode=timestamp\";\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVotingEscrow\n    function allowedManager() external view returns (address) {\n        return self.allowedManager;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function artProxy() external view returns (address) {\n        return self.artProxy;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function canSplit(address _account) external view returns (bool) {\n        return self.canSplit[_account];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function deactivated(\n        uint256 _tokenId\n    ) external view returns (bool inactive) {\n        return self.deactivated[_tokenId];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function distributor() external view returns (address) {\n        return self.distributor;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function epoch() external view returns (uint256) {\n        return self.epoch;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function escrowType(uint256 _tokenId) external view returns (EscrowType) {\n        return self.escrowType[_tokenId];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function factoryRegistry() external view returns (address) {\n        return self.factoryRegistry;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function forwarder() external view returns (address) {\n        return self.trustedForwarder;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function idToManaged(uint256 _tokenId) external view returns (uint256) {\n        return self.idToManaged[_tokenId];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function managedToFree(uint256 _tokenId) external view returns (address) {\n        return self.managedToFree[_tokenId];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function managedToLocked(uint256 _tokenId) external view returns (address) {\n        return self.managedToLocked[_tokenId];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function nonces(address _account) external view returns (uint256) {\n        return self.nonces[_account];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function numCheckpoints(uint256 _tokenId) external view returns (uint48) {\n        return self.numCheckpoints[_tokenId];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function ownerToNFTokenIdList(\n        address _owner,\n        uint256 _index\n    ) external view returns (uint256) {\n        return self.ownerToNFTokenIdList[_owner][_index];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function permanentLockBalance() external view returns (uint256) {\n        return self.permanentLockBalance;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function slopeChanges(uint256 _timestamp) external view returns (int128) {\n        return self.slopeChanges[_timestamp];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function supply() external view returns (uint256) {\n        return self.supply;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function team() external view returns (address) {\n        return self.team;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function token() external view returns (address) {\n        return self.token;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function tokenId() external view returns (uint256) {\n        return self.tokenId;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function userPointEpoch(uint256 _tokenId) external view returns (uint256) {\n        return self.userPointEpoch[_tokenId];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function voted(uint256 _tokenId) external view returns (bool) {\n        return self.voted[_tokenId];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function voter() external view returns (address) {\n        return self.voter;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function weights(\n        uint256 _tokenId,\n        uint256 _managedTokenId\n    ) external view returns (uint256) {\n        return self.weights[_tokenId][_managedTokenId];\n    }\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    function DOMAIN_TYPEHASH() external pure returns (bytes32) {\n        return Delegation.DOMAIN_TYPEHASH;\n    }\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    function DELEGATION_TYPEHASH() external pure returns (bytes32) {\n        return Delegation.DELEGATION_TYPEHASH;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "evmVersion": "london",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}