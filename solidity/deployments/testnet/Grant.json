{
  "address": "0x03e54A7CF45f474DEAe1b7884ba862d2c1B3B833",
  "abi": [
    {
      "inputs": [],
      "name": "NotGrantManager",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "_tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_grantee",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_grantManager",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_vestingEnd",
          "type": "uint256"
        }
      ],
      "name": "CreateGrant",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_grantManager",
          "type": "address"
        }
      ],
      "name": "SetGrantManager",
      "type": "event"
    }
  ],
  "transactionHash": "0xae9ad87894b94d27a92e2500b54d384d73c4ecda9f8a2b4bb747d3b2c25efa5a",
  "receipt": {
    "to": null,
    "from": "0x6e80164ea60673D64d5d6228beb684a1274Bb017",
    "contractAddress": "0x03e54A7CF45f474DEAe1b7884ba862d2c1B3B833",
    "transactionIndex": 0,
    "gasUsed": "243953",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x58813b34cbdd78d92957eca70e80c88668e1c19d1b5454955f92e81fab6e08f3",
    "transactionHash": "0xae9ad87894b94d27a92e2500b54d384d73c4ecda9f8a2b4bb747d3b2c25efa5a",
    "logs": [],
    "blockNumber": 6312378,
    "cumulativeGasUsed": "243953",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "8fa39d1f75a81de120cc40b3f4adb866",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"NotGrantManager\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_grantee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_grantManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_vestingEnd\",\"type\":\"uint256\"}],\"name\":\"CreateGrant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_grantManager\",\"type\":\"address\"}],\"name\":\"SetGrantManager\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ve/Grant.sol\":\"Grant\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\",\"keccak256\":\"0xd04b0f06e0666f29cf7cccc82894de541e19bb30a765b107b1e40bb7fe5f7d7a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC4906.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4906.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\n\\n/// @title EIP-721 Metadata Update Extension\\ninterface IERC4906 is IERC165, IERC721 {\\n    /// @dev This event emits when the metadata of a token is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFT.\\n    event MetadataUpdate(uint256 _tokenId);\\n\\n    /// @dev This event emits when the metadata of a range of tokens is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFTs.\\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\\n}\\n\",\"keccak256\":\"0x2a9dadb806be80dd451821f1f1190eb9aa6f6edae85b185db29d60767cc0c5f4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC6372.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC6372 {\\n    /**\\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\\n     */\\n    function clock() external view returns (uint48);\\n\\n    /**\\n     * @dev Description of the clock\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function CLOCK_MODE() external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xcaea9aeda3816ba872358c828f4f01455c22ae48ced49c4c7d72bd74176c09b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721.sol\\\";\\n\",\"keccak256\":\"0xaf297d12d8d4a57fe01a70f0ef38908f208e3faedc577056d0b728fa2f3ccf0c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xec63854014a5b4f2b3290ab9103a21bdf902a508d0f41a8573fea49e98bf571a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\n     * 0 before setting it to a non-zero value.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0x909d608c2db6eb165ca178c81289a07ed2e118e444d0025b2a85c97d0b44a4fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xa82b58eca1ee256be466e536706850163d2ec7821945abd6b4778cfb3bee37da\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/governance/IVotes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\n/// Modified IVotes interface for tokenId based voting\\ninterface IVotes {\\n    /**\\n     * @dev Emitted when an account changes their delegate.\\n     */\\n    event DelegateChanged(\\n        address indexed delegator,\\n        uint256 indexed fromDelegate,\\n        uint256 indexed toDelegate\\n    );\\n\\n    /**\\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\\n     */\\n    event DelegateVotesChanged(\\n        address indexed delegate,\\n        uint256 previousBalance,\\n        uint256 newBalance\\n    );\\n\\n    /**\\n     * @dev Returns the amount of votes that `tokenId` had at a specific moment in the past.\\n     *      If the account passed in is not the owner, returns 0.\\n     */\\n    function getPastVotes(\\n        address account,\\n        uint256 tokenId,\\n        uint256 timepoint\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\\n     * configured to use block numbers, this will return the value the end of the corresponding block.\\n     *\\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\\n     * vote.\\n     */\\n    function getPastTotalSupply(\\n        uint256 timepoint\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the delegate that `tokenId` has chosen. Can never be equal to the delegator's `tokenId`.\\n     *      Returns 0 if not delegated.\\n     */\\n    function delegates(uint256 tokenId) external view returns (uint256);\\n\\n    /**\\n     * @dev Delegates votes from the sender to `delegatee`.\\n     */\\n    function delegate(uint256 delegator, uint256 delegatee) external;\\n\\n    /**\\n     * @dev Delegates votes from `delegator` to `delegatee`. Signer must own `delegator`.\\n     */\\n    function delegateBySig(\\n        uint256 delegator,\\n        uint256 delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\",\"keccak256\":\"0x9d443ede6b412305137804890806312f30351178fd3781b3a9417bfd3eea558c\",\"license\":\"MIT\"},\"contracts/interfaces/IReward.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\ninterface IReward {\\n    error InvalidReward();\\n    error NotAuthorized();\\n    error NotGauge();\\n    error NotEscrowToken();\\n    error NotSingleToken();\\n    error NotVotingEscrow();\\n    error NotWhitelisted();\\n    error ZeroAmount();\\n\\n    event Deposit(\\n        address indexed from,\\n        uint256 indexed tokenId,\\n        uint256 amount\\n    );\\n    event Withdraw(\\n        address indexed from,\\n        uint256 indexed tokenId,\\n        uint256 amount\\n    );\\n    event NotifyReward(\\n        address indexed from,\\n        address indexed reward,\\n        uint256 indexed epoch,\\n        uint256 amount\\n    );\\n    event ClaimRewards(\\n        address indexed from,\\n        address indexed reward,\\n        uint256 amount\\n    );\\n\\n    /// @notice A checkpoint for marking balance\\n    struct Checkpoint {\\n        uint256 timestamp;\\n        uint256 balanceOf;\\n    }\\n\\n    /// @notice A checkpoint for marking supply\\n    struct SupplyCheckpoint {\\n        uint256 timestamp;\\n        uint256 supply;\\n    }\\n\\n    /// @notice Epoch duration constant (7 days)\\n    function duration() external pure returns (uint256);\\n\\n    /// @notice Address of Voter.sol\\n    function voter() external view returns (address);\\n\\n    /// @notice Address of VotingEscrow.sol\\n    function ve() external view returns (address);\\n\\n    /// @dev Address which has permission to externally call _deposit() & _withdraw()\\n    function authorized() external view returns (address);\\n\\n    /// @notice Total amount currently deposited via _deposit()\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Current amount deposited by tokenId\\n    function balanceOf(uint256 tokenId) external view returns (uint256);\\n\\n    /// @notice Amount of tokens to reward depositors for a given epoch\\n    /// @param token Address of token to reward\\n    /// @param epochStart Startime of rewards epoch\\n    /// @return Amount of token\\n    function tokenRewardsPerEpoch(\\n        address token,\\n        uint256 epochStart\\n    ) external view returns (uint256);\\n\\n    /// @notice Most recent timestamp a veNFT has claimed their rewards\\n    /// @param  token Address of token rewarded\\n    /// @param tokenId veNFT unique identifier\\n    /// @return Timestamp\\n    function lastEarn(\\n        address token,\\n        uint256 tokenId\\n    ) external view returns (uint256);\\n\\n    /// @notice True if a token is or has been an active reward token, else false\\n    function isReward(address token) external view returns (bool);\\n\\n    /// @notice The number of checkpoints for each tokenId deposited\\n    function numCheckpoints(uint256 tokenId) external view returns (uint256);\\n\\n    /// @notice The total number of checkpoints\\n    function supplyNumCheckpoints() external view returns (uint256);\\n\\n    /// @notice Deposit an amount into the rewards contract to earn future rewards associated to a veNFT\\n    /// @dev Internal notation used as only callable internally by `authorized`.\\n    /// @param amount   Amount deposited for the veNFT\\n    /// @param tokenId  Unique identifier of the veNFT\\n    function _deposit(uint256 amount, uint256 tokenId) external;\\n\\n    /// @notice Withdraw an amount from the rewards contract associated to a veNFT\\n    /// @dev Internal notation used as only callable internally by `authorized`.\\n    /// @param amount   Amount deposited for the veNFT\\n    /// @param tokenId  Unique identifier of the veNFT\\n    function _withdraw(uint256 amount, uint256 tokenId) external;\\n\\n    /// @notice Claim the rewards earned by a veNFT staker\\n    /// @param tokenId  Unique identifier of the veNFT\\n    /// @param tokens   Array of tokens to claim rewards of\\n    function getReward(uint256 tokenId, address[] memory tokens) external;\\n\\n    /// @notice Add rewards for stakers to earn\\n    /// @param token    Address of token to reward\\n    /// @param amount   Amount of token to transfer to rewards\\n    function notifyRewardAmount(address token, uint256 amount) external;\\n\\n    /// @notice Determine the prior balance for an account as of a block number\\n    /// @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n    /// @param tokenId      The token of the NFT to check\\n    /// @param timestamp    The timestamp to get the balance at\\n    /// @return The balance the account had as of the given block\\n    function getPriorBalanceIndex(\\n        uint256 tokenId,\\n        uint256 timestamp\\n    ) external view returns (uint256);\\n\\n    /// @notice Determine the prior index of supply staked by of a timestamp\\n    /// @dev Timestamp must be <= current timestamp\\n    /// @param timestamp The timestamp to get the index at\\n    /// @return Index of supply checkpoint\\n    function getPriorSupplyIndex(\\n        uint256 timestamp\\n    ) external view returns (uint256);\\n\\n    /// @notice Get number of rewards tokens\\n    function rewardsListLength() external view returns (uint256);\\n\\n    /// @notice Calculate how much in rewards are earned for a specific token and veNFT\\n    /// @param token Address of token to fetch rewards of\\n    /// @param tokenId Unique identifier of the veNFT\\n    /// @return Amount of token earned in rewards\\n    function earned(\\n        address token,\\n        uint256 tokenId\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xb2daaf8189e7ab1050182908664ab0fb7607838ec59c02511febd73584db3bb8\",\"license\":\"MIT\"},\"contracts/interfaces/IVotingEscrow.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\nimport {IERC165, IERC721, IERC721Metadata} from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\nimport {IERC6372} from \\\"@openzeppelin/contracts/interfaces/IERC6372.sol\\\";\\nimport {IERC4906} from \\\"@openzeppelin/contracts/interfaces/IERC4906.sol\\\";\\nimport {IVotes} from \\\"../governance/IVotes.sol\\\";\\n\\ninterface IVotingEscrow is IVotes, IERC4906, IERC6372, IERC721Metadata {\\n    struct LockedBalance {\\n        int128 amount;\\n        uint256 end;\\n        bool isPermanent;\\n    }\\n\\n    struct UserPoint {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint256 ts;\\n        uint256 blk; // block\\n        uint256 permanent;\\n    }\\n\\n    struct GlobalPoint {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint256 ts;\\n        uint256 blk; // block\\n        uint256 permanentLockBalance;\\n    }\\n\\n    /// @notice A checkpoint for recorded delegated voting weights at a certain timestamp\\n    struct Checkpoint {\\n        uint256 fromTimestamp;\\n        address owner;\\n        uint256 delegatedBalance;\\n        uint256 delegatee;\\n    }\\n\\n    enum DepositType {\\n        DEPOSIT_FOR_TYPE,\\n        CREATE_LOCK_TYPE,\\n        INCREASE_LOCK_AMOUNT,\\n        INCREASE_UNLOCK_TIME\\n    }\\n\\n    /// @dev Different types of veNFTs:\\n    /// NORMAL  - typical veNFT\\n    /// LOCKED  - veNFT which is locked into a MANAGED veNFT\\n    /// MANAGED - veNFT which can accept the deposit of NORMAL veNFTs\\n    enum EscrowType {\\n        NORMAL,\\n        LOCKED,\\n        MANAGED\\n    }\\n\\n    error AlreadyVoted();\\n    error AmountTooBig();\\n    error ERC721ReceiverRejectedTokens();\\n    error ERC721TransferToNonERC721ReceiverImplementer();\\n    error InvalidNonce();\\n    error InvalidSignature();\\n    error InvalidSignatureS();\\n    error InvalidManagedNFTId();\\n    error LockDurationNotInFuture();\\n    error LockDurationTooLong();\\n    error LockExpired();\\n    error LockNotExpired();\\n    error NoLockFound();\\n    error NonExistentToken();\\n    error NotApprovedOrOwner();\\n    error NotDistributor();\\n    error NotEmergencyCouncilOrGovernor();\\n    error NotGovernor();\\n    error NotGovernorOrManager();\\n    error NotManagedNFT();\\n    error NotManagedOrNormalNFT();\\n    error NotLockedNFT();\\n    error NotNormalNFT();\\n    error NotPermanentLock();\\n    error NotOwner();\\n    error NotTeam();\\n    error NotVoter();\\n    error OwnershipChange();\\n    error PermanentLock();\\n    error SameAddress();\\n    error SameNFT();\\n    error SameState();\\n    error SplitNoOwner();\\n    error SplitNotAllowed();\\n    error SignatureExpired();\\n    error TooManyTokenIDs();\\n    error ZeroAddress();\\n    error ZeroAmount();\\n    error ZeroBalance();\\n    error NotGrantManager();\\n    error UnvestedGrantNFT();\\n\\n    event Deposit(\\n        address indexed provider,\\n        uint256 indexed tokenId,\\n        DepositType indexed depositType,\\n        uint256 value,\\n        uint256 locktime,\\n        uint256 ts\\n    );\\n    event Withdraw(\\n        address indexed provider,\\n        uint256 indexed tokenId,\\n        uint256 value,\\n        uint256 ts\\n    );\\n    event LockPermanent(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 amount,\\n        uint256 _ts\\n    );\\n    event UnlockPermanent(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 amount,\\n        uint256 _ts\\n    );\\n    event Supply(uint256 prevSupply, uint256 supply);\\n    event Merge(\\n        address indexed _sender,\\n        uint256 indexed _from,\\n        uint256 indexed _to,\\n        uint256 _amountFrom,\\n        uint256 _amountTo,\\n        uint256 _amountFinal,\\n        uint256 _locktime,\\n        uint256 _ts\\n    );\\n    event Split(\\n        uint256 indexed _from,\\n        uint256 indexed _tokenId1,\\n        uint256 indexed _tokenId2,\\n        address _sender,\\n        uint256 _splitAmount1,\\n        uint256 _splitAmount2,\\n        uint256 _locktime,\\n        uint256 _ts\\n    );\\n    event CreateManaged(\\n        address indexed _to,\\n        uint256 indexed _mTokenId,\\n        address indexed _from,\\n        address _lockedManagedReward,\\n        address _freeManagedReward\\n    );\\n    event DepositManaged(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 indexed _mTokenId,\\n        uint256 _weight,\\n        uint256 _ts\\n    );\\n    event WithdrawManaged(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 indexed _mTokenId,\\n        uint256 _weight,\\n        uint256 _ts\\n    );\\n    event SetAllowedManager(address indexed _allowedManager);\\n    event CreateGrant(\\n        uint256 indexed _tokenId,\\n        address _grantee,\\n        address _grantManager,\\n        uint256 _vestingEnd\\n    );\\n    event SetGrantManager(address indexed _grantManager);\\n\\n    // State variables\\n    /// @notice Address of Meta-tx Forwarder\\n    function forwarder() external view returns (address);\\n\\n    /// @notice Address of FactoryRegistry.sol\\n    function factoryRegistry() external view returns (address);\\n\\n    /// @notice Address of token used to create a veNFT\\n    function token() external view returns (address);\\n\\n    /// @notice Address of RewardsDistributor.sol\\n    function distributor() external view returns (address);\\n\\n    /// @notice Address of Voter.sol\\n    function voter() external view returns (address);\\n\\n    /// @notice Address of Protocol Team multisig\\n    function team() external view returns (address);\\n\\n    /// @dev address which can create managed NFTs\\n    function allowedManager() external view returns (address);\\n\\n    /// @dev Current count of token\\n    function tokenId() external view returns (uint256);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            MANAGED NFT STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Mapping of token id to escrow type\\n    ///      Takes advantage of the fact default value is EscrowType.NORMAL\\n    function escrowType(uint256 tokenId) external view returns (EscrowType);\\n\\n    /// @dev Mapping of token id to managed id\\n    function idToManaged(\\n        uint256 tokenId\\n    ) external view returns (uint256 managedTokenId);\\n\\n    /// @dev Mapping of user token id to managed token id to weight of token id\\n    function weights(\\n        uint256 tokenId,\\n        uint256 managedTokenId\\n    ) external view returns (uint256 weight);\\n\\n    /// @dev Mapping of managed id to deactivated state\\n    function deactivated(uint256 tokenId) external view returns (bool inactive);\\n\\n    /// @dev Mapping from managed nft id to locked managed rewards\\n    ///      `token` denominated rewards (rebases/rewards) stored in locked managed rewards contract\\n    ///      to prevent co-mingling of assets\\n    function managedToLocked(uint256 tokenId) external view returns (address);\\n\\n    /// @dev Mapping from managed nft id to free managed rewards contract\\n    ///      these rewards can be freely withdrawn by users\\n    function managedToFree(uint256 tokenId) external view returns (address);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            MANAGED NFT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Create managed NFT (a permanent lock) for use within ecosystem.\\n    /// @dev Throws if address already owns a managed NFT.\\n    /// @return _mTokenId managed token id.\\n    function createManagedLockFor(\\n        address _to\\n    ) external returns (uint256 _mTokenId);\\n\\n    /// @notice Delegates balance to managed nft\\n    ///         Note that NFTs deposited into a managed NFT will be re-locked\\n    ///         to the maximum lock time on withdrawal.\\n    ///         Permanent locks that are deposited will automatically unlock.\\n    /// @dev Managed nft will remain max-locked as long as there is at least one\\n    ///      deposit or withdrawal per week.\\n    ///      Throws if deposit nft is managed.\\n    ///      Throws if recipient nft is not managed.\\n    ///      Throws if deposit nft is already locked.\\n    ///      Throws if not called by voter.\\n    /// @param _tokenId tokenId of NFT being deposited\\n    /// @param _mTokenId tokenId of managed NFT that will receive the deposit\\n    function depositManaged(uint256 _tokenId, uint256 _mTokenId) external;\\n\\n    /// @notice Retrieves locked rewards and withdraws balance from managed nft.\\n    ///         Note that the NFT withdrawn is re-locked to the maximum lock time.\\n    /// @dev Throws if NFT not locked.\\n    ///      Throws if not called by voter.\\n    /// @param _tokenId tokenId of NFT being deposited.\\n    function withdrawManaged(uint256 _tokenId) external;\\n\\n    /// @notice Permit one address to call createManagedLockFor() that is not Voter.governor()\\n    function setAllowedManager(address _allowedManager) external;\\n\\n    /// @notice Set Managed NFT state. Inactive NFTs cannot be deposited into.\\n    /// @param _mTokenId managed nft state to set\\n    /// @param _state true => inactive, false => active\\n    function setManagedState(uint256 _mTokenId, bool _state) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function version() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function setTeam(address _team) external;\\n\\n    /// @inheritdoc IERC721Metadata\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Mapping from owner address to mapping of index to tokenId\\n    function ownerToNFTokenIdList(\\n        address _owner,\\n        uint256 _index\\n    ) external view returns (uint256 _tokenId);\\n\\n    /// @inheritdoc IERC721\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /// @inheritdoc IERC721\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC721\\n    function getApproved(\\n        uint256 _tokenId\\n    ) external view returns (address operator);\\n\\n    /// @inheritdoc IERC721\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n\\n    /// @notice Check whether spender is owner or an approved user for a given veNFT\\n    /// @param _spender .\\n    /// @param _tokenId .\\n    function isApprovedOrOwner(\\n        address _spender,\\n        uint256 _tokenId\\n    ) external returns (bool);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC721\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /// @inheritdoc IERC721\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /// @inheritdoc IERC721\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /// @inheritdoc IERC721\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /// @inheritdoc IERC721\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(\\n        bytes4 _interfaceID\\n    ) external view returns (bool);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ESCROW STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Total count of epochs witnessed since contract creation\\n    function epoch() external view returns (uint256);\\n\\n    /// @notice Total amount of token() deposited\\n    function supply() external view returns (uint256);\\n\\n    /// @notice Aggregate permanent locked balances\\n    function permanentLockBalance() external view returns (uint256);\\n\\n    function userPointEpoch(\\n        uint256 _tokenId\\n    ) external view returns (uint256 _epoch);\\n\\n    /// @notice time -> signed slope change\\n    function slopeChanges(uint256 _timestamp) external view returns (int128);\\n\\n    /// @notice account -> can split\\n    function canSplit(address _account) external view returns (bool);\\n\\n    /// @notice Global point history at a given index\\n    function pointHistory(\\n        uint256 _loc\\n    ) external view returns (GlobalPoint memory);\\n\\n    /// @notice Get the LockedBalance (amount, end) of a _tokenId\\n    /// @param _tokenId .\\n    /// @return LockedBalance of _tokenId\\n    function locked(\\n        uint256 _tokenId\\n    ) external view returns (LockedBalance memory);\\n\\n    /// @notice User -> UserPoint[userEpoch]\\n    function userPointHistory(\\n        uint256 _tokenId,\\n        uint256 _loc\\n    ) external view returns (UserPoint memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ESCROW LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Record global data to checkpoint\\n    function checkpoint() external;\\n\\n    /// @notice Deposit `_value` tokens for `_tokenId` and add to the lock\\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\\n    ///      cannot extend their locktime and deposit for a brand new user\\n    /// @param _tokenId lock NFT\\n    /// @param _value Amount to add to user's lock\\n    function depositFor(uint256 _tokenId, uint256 _value) external;\\n\\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lockDuration`\\n    /// @param _value Amount to deposit\\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\\n    /// @return TokenId of created veNFT\\n    function createLock(\\n        uint256 _value,\\n        uint256 _lockDuration\\n    ) external returns (uint256);\\n\\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lockDuration`\\n    /// @param _value Amount to deposit\\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\\n    /// @param _to Address to deposit\\n    /// @return TokenId of created veNFT\\n    function createLockFor(\\n        uint256 _value,\\n        uint256 _lockDuration,\\n        address _to\\n    ) external returns (uint256);\\n\\n    /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\\n    /// @param _value Amount of tokens to deposit and add to the lock\\n    function increaseAmount(uint256 _tokenId, uint256 _value) external;\\n\\n    /// @notice Extend the unlock time for `_tokenId`\\n    ///         Cannot extend lock time of permanent locks\\n    /// @param _lockDuration New number of seconds until tokens unlock\\n    function increaseUnlockTime(\\n        uint256 _tokenId,\\n        uint256 _lockDuration\\n    ) external;\\n\\n    /// @notice Withdraw all tokens for `_tokenId`\\n    /// @dev Only possible if the lock is both expired and not permanent\\n    ///      This will burn the veNFT. Any rebases or rewards that are unclaimed\\n    ///      will no longer be claimable. Claim all rebases and rewards prior to calling this.\\n    function withdraw(uint256 _tokenId) external;\\n\\n    /// @notice Merges `_from` into `_to`.\\n    /// @dev Cannot merge `_from` locks that are permanent or have already voted this epoch.\\n    ///      Cannot merge `_to` locks that have already expired.\\n    ///      Cannot merge if either `_from` or `_to` is veNFT created for\\n    ///      a grant that has not fully vested yet.\\n    ///      This will burn the veNFT. Any rebases or rewards that are unclaimed\\n    ///      will no longer be claimable. Claim all rebases and rewards prior to calling this.\\n    /// @param _from VeNFT to merge from.\\n    /// @param _to VeNFT to merge into.\\n    function merge(uint256 _from, uint256 _to) external;\\n\\n    /// @notice Splits veNFT into two new veNFTS - one with oldLocked.amount - `_amount`, and the second with `_amount`\\n    /// @dev    This burns the tokenId of the target veNFT\\n    ///         Callable by approved or owner\\n    ///         If this is called by approved, approved will not have permissions to manipulate the newly created veNFTs\\n    ///         Returns the two new split veNFTs to owner\\n    ///         If `from` is permanent, will automatically dedelegate.\\n    ///         This will burn the veNFT. Any rebases or rewards that are unclaimed\\n    ///         will no longer be claimable. Claim all rebases and rewards prior to calling this.\\n    /// @param _from VeNFT to split.\\n    /// @param _amount Amount to split from veNFT.\\n    /// @return _tokenId1 Return tokenId of veNFT with oldLocked.amount - `_amount`.\\n    /// @return _tokenId2 Return tokenId of veNFT with `_amount`.\\n    function split(\\n        uint256 _from,\\n        uint256 _amount\\n    ) external returns (uint256 _tokenId1, uint256 _tokenId2);\\n\\n    /// @notice Toggle split for a specific address.\\n    /// @dev Toggle split for address(0) to enable or disable for all.\\n    /// @param _account Address to toggle split permissions\\n    /// @param _bool True to allow, false to disallow\\n    function toggleSplit(address _account, bool _bool) external;\\n\\n    /// @notice Permanently lock a veNFT. Voting power will be equal to\\n    ///         `LockedBalance.amount` with no decay. Required to delegate.\\n    /// @dev Only callable by unlocked normal veNFTs.\\n    /// @param _tokenId tokenId to lock.\\n    function lockPermanent(uint256 _tokenId) external;\\n\\n    /// @notice Unlock a permanently locked veNFT. Voting power will decay.\\n    ///         Will automatically dedelegate if delegated.\\n    /// @dev Only callable by permanently locked veNFTs.\\n    ///      Cannot unlock if already voted this epoch.\\n    /// @param _tokenId tokenId to unlock.\\n    function unlockPermanent(uint256 _tokenId) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           GAUGE VOTING STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Get the voting power for _tokenId at the current timestamp\\n    /// @dev Returns 0 if called in the same block as a transfer.\\n    /// @param _tokenId .\\n    /// @return Voting power\\n    function balanceOfNFT(uint256 _tokenId) external view returns (uint256);\\n\\n    /// @notice Get the voting power for _tokenId at a given timestamp\\n    /// @param _tokenId .\\n    /// @param _t Timestamp to query voting power\\n    /// @return Voting power\\n    function balanceOfNFTAt(\\n        uint256 _tokenId,\\n        uint256 _t\\n    ) external view returns (uint256);\\n\\n    /// @notice Calculate total voting power at current timestamp\\n    /// @return Total voting power at current timestamp\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Calculate total voting power at a given timestamp\\n    /// @param _t Timestamp to query total voting power\\n    /// @return Total voting power at given timestamp\\n    function totalSupplyAt(uint256 _t) external view returns (uint256);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            GAUGE VOTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice See if a queried _tokenId has actively voted\\n    /// @param _tokenId .\\n    /// @return True if voted, else false\\n    function voted(uint256 _tokenId) external view returns (bool);\\n\\n    /// @notice Set the global state voter and distributor\\n    /// @dev This is only called once, at setup\\n    function setVoterAndDistributor(\\n        address _voter,\\n        address _distributor\\n    ) external;\\n\\n    /// @notice Set `voted` for _tokenId to true or false\\n    /// @dev Only callable by voter\\n    /// @param _tokenId .\\n    /// @param _voted .\\n    function voting(uint256 _tokenId, bool _voted) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            DAO VOTING STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The number of checkpoints for each tokenId\\n    function numCheckpoints(uint256 tokenId) external view returns (uint48);\\n\\n    /// @notice A record of states for signing / validating signatures\\n    function nonces(address account) external view returns (uint256);\\n\\n    /// @inheritdoc IVotes\\n    function delegates(uint256 delegator) external view returns (uint256);\\n\\n    /// @notice A record of delegated token checkpoints for each account, by index\\n    /// @param tokenId .\\n    /// @param index .\\n    /// @return Checkpoint\\n    function checkpoints(\\n        uint256 tokenId,\\n        uint48 index\\n    ) external view returns (Checkpoint memory);\\n\\n    /// @inheritdoc IVotes\\n    function getPastVotes(\\n        address account,\\n        uint256 tokenId,\\n        uint256 timestamp\\n    ) external view returns (uint256);\\n\\n    /// @inheritdoc IVotes\\n    function getPastTotalSupply(\\n        uint256 timestamp\\n    ) external view returns (uint256);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             DAO VOTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IVotes\\n    function delegate(uint256 delegator, uint256 delegatee) external;\\n\\n    /// @inheritdoc IVotes\\n    function delegateBySig(\\n        uint256 delegator,\\n        uint256 delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC6372 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC6372\\n    function clock() external view returns (uint48);\\n\\n    /// @inheritdoc IERC6372\\n    function CLOCK_MODE() external view returns (string memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                TOKEN GRANT\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Deposit `_value` of tokens as a grant and lock for `_vestingEnd`\\n    ///         with the provided `_grantManager`.\\n    /// @param _value Amount to deposit\\n    /// @param _grantee The grantee's address\\n    /// @param _grantManager The grant manager who can revoke the grant\\n    /// @param _vestingEnd The end of the vesting schedule. The lock will be\\n    ///        rounded down to nearest week but the original vesting end is\\n    ///        recorded in the contract.\\n    /// @return TokenId of created veNFT\\n    function createGrantLockFor(\\n        uint256 _value,\\n        address _grantee,\\n        address _grantManager,\\n        uint256 _vestingEnd\\n    ) external returns (uint256);\\n\\n    /// @notice Allows the existing grant manager to set a new grant manager\\n    ///         address.\\n    /// @param _tokenId tokenId of the veNFT\\n    /// @param _newGrantManager The new grant manager address\\n    function setGrantManager(\\n        uint256 _tokenId,\\n        address _newGrantManager\\n    ) external;\\n\\n    /// @notice Returns the grant manager address for the given veNFT\\n    /// @param _tokenId tokenId of the veNFT\\n    function grantManager(uint256 _tokenId) external view returns (address);\\n\\n    /// @notice Returns the vesting schedule end for the given veNFT.\\n    ///         Zero if the veNFT was not created as a grant.\\n    /// @param _tokenId tokenId of the veNFT\\n    function vestingEnd(uint256 _tokenId) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x12fc409f27c9e659dffeedb14c460d993d1cde4df6918f7ec26ec21bbe989845\",\"license\":\"MIT\"},\"contracts/libraries/SafeCastLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.24;\\n\\n/// @title SafeCast Library\\n/// @author velodrome.finance\\n/// @notice Safely convert unsigned and signed integers without overflow / underflow\\nlibrary SafeCastLibrary {\\n    error SafeCastOverflow();\\n    error SafeCastUnderflow();\\n\\n    /// @dev Safely convert uint256 to int128\\n    function toInt128(uint256 value) internal pure returns (int128) {\\n        if (value > uint128(type(int128).max)) revert SafeCastOverflow();\\n        return int128(uint128(value));\\n    }\\n\\n    /// @dev Safely convert int128 to uint256\\n    function toUint256(int128 value) internal pure returns (uint256) {\\n        if (value < 0) revert SafeCastUnderflow();\\n        return uint256(int256(value));\\n    }\\n}\\n\",\"keccak256\":\"0xfc419390f2423ffa802e9a3a11ee859b01fee9ffdb0fca855008d6b7d6b25bd6\",\"license\":\"BUSL-1.1\"},\"contracts/ve/Delegation.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.24;\\n\\nimport {VotingEscrowState} from \\\"./VotingEscrowState.sol\\\";\\nimport {NFT} from \\\"./NFT.sol\\\";\\nimport {VeERC2771Context} from \\\"./VeERC2771Context.sol\\\";\\nimport {SafeCastLibrary} from \\\"../libraries/SafeCastLibrary.sol\\\";\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport {IVotes} from \\\"../governance/IVotes.sol\\\";\\n\\nlibrary Delegation {\\n    using SafeCastLibrary for int128;\\n    using NFT for VotingEscrowState.Storage;\\n    using VeERC2771Context for VotingEscrowState.Storage;\\n\\n    struct SignatureData {\\n        uint256 delegator;\\n        uint256 delegatee;\\n        uint256 nonce;\\n        uint256 expiry;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH =\\n        keccak256(\\n            \\\"EIP712Domain(string name,string contractVersion,uint256 chainId,address verifyingContract)\\\"\\n        );\\n\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\\n    bytes32 public constant DELEGATION_TYPEHASH =\\n        keccak256(\\n            \\\"Delegation(uint256 delegator,uint256 delegatee,uint256 nonce,uint256 expiry)\\\"\\n        );\\n\\n    function delegate(\\n        VotingEscrowState.Storage storage self,\\n        uint256 delegator,\\n        uint256 delegatee\\n    ) external {\\n        if (!self._isApprovedOrOwner(self._msgSender(), delegator))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        return _delegate(self, delegator, delegatee);\\n    }\\n\\n    function delegateBySig(\\n        VotingEscrowState.Storage storage self,\\n        SignatureData calldata signatureData,\\n        string calldata contractName,\\n        string calldata contractVersion\\n    ) external {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (\\n            uint256(signatureData.s) >\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\\n        ) revert IVotingEscrow.InvalidSignatureS();\\n        bytes32 domainSeparator = keccak256(\\n            abi.encode(\\n                DOMAIN_TYPEHASH,\\n                keccak256(bytes(contractName)),\\n                keccak256(bytes(contractVersion)),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                DELEGATION_TYPEHASH,\\n                signatureData.delegator,\\n                signatureData.delegatee,\\n                signatureData.nonce,\\n                signatureData.expiry\\n            )\\n        );\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash)\\n        );\\n        address signatory = ecrecover(\\n            digest,\\n            signatureData.v,\\n            signatureData.r,\\n            signatureData.s\\n        );\\n        if (!self._isApprovedOrOwner(signatory, signatureData.delegator))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        if (signatory == address(0)) revert IVotingEscrow.InvalidSignature();\\n        if (signatureData.nonce != self.nonces[signatory]++)\\n            revert IVotingEscrow.InvalidNonce();\\n        if (block.timestamp > signatureData.expiry)\\n            revert IVotingEscrow.SignatureExpired();\\n        return\\n            _delegate(self, signatureData.delegator, signatureData.delegatee);\\n    }\\n\\n    /// @notice Record user delegation checkpoints. Used by voting system.\\n    /// @dev Skips delegation if already delegated to `delegatee`.\\n    function _delegate(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _delegator,\\n        uint256 _delegatee\\n    ) internal {\\n        IVotingEscrow.LockedBalance memory delegateLocked = self._locked[\\n            _delegator\\n        ];\\n        if (!delegateLocked.isPermanent)\\n            revert IVotingEscrow.NotPermanentLock();\\n        if (_delegatee != 0 && self._ownerOf(_delegatee) == address(0))\\n            revert IVotingEscrow.NonExistentToken();\\n        if (self.ownershipChange[_delegator] == block.number)\\n            revert IVotingEscrow.OwnershipChange();\\n        if (_delegatee == _delegator) _delegatee = 0;\\n        uint256 currentDelegate = self._delegates[_delegator];\\n        if (currentDelegate == _delegatee) return;\\n\\n        uint256 delegatedBalance = delegateLocked.amount.toUint256();\\n        _checkpointDelegator(\\n            self,\\n            _delegator,\\n            _delegatee,\\n            self._ownerOf(_delegator)\\n        );\\n        _checkpointDelegatee(self, _delegatee, delegatedBalance, true);\\n\\n        emit IVotes.DelegateChanged(\\n            self._msgSender(),\\n            currentDelegate,\\n            _delegatee\\n        );\\n    }\\n\\n    /// @notice Used by `_mint`, `_transferFrom`, `_burn` and `delegate`\\n    ///         to update delegator voting checkpoints.\\n    ///         Automatically dedelegates, then updates checkpoint.\\n    /// @dev This function depends on `_locked` and must be called prior to token state changes.\\n    ///      If you wish to dedelegate only, use `_delegate(tokenId, 0)` instead.\\n    /// @param _delegator The delegator to update checkpoints for\\n    /// @param _delegatee The new delegatee for the delegator. Cannot be equal to `_delegator` (use 0 instead).\\n    /// @param _owner The new (or current) owner for the delegator\\n    function _checkpointDelegator(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _delegator,\\n        uint256 _delegatee,\\n        address _owner\\n    ) internal {\\n        uint256 delegatedBalance = self._locked[_delegator].amount.toUint256();\\n        uint48 numCheckpoint = self.numCheckpoints[_delegator];\\n        IVotingEscrow.Checkpoint storage cpOld = numCheckpoint > 0\\n            ? self._checkpoints[_delegator][numCheckpoint - 1]\\n            : self._checkpoints[_delegator][0];\\n        // Dedelegate from delegatee if delegated\\n        _checkpointDelegatee(self, cpOld.delegatee, delegatedBalance, false);\\n        IVotingEscrow.Checkpoint storage cp = self._checkpoints[_delegator][\\n            numCheckpoint\\n        ];\\n        cp.fromTimestamp = block.timestamp;\\n        cp.delegatedBalance = cpOld.delegatedBalance;\\n        cp.delegatee = _delegatee;\\n        cp.owner = _owner;\\n\\n        if (_isCheckpointInNewBlock(self, _delegator)) {\\n            self.numCheckpoints[_delegator]++;\\n        } else {\\n            self._checkpoints[_delegator][numCheckpoint - 1] = cp;\\n            delete self._checkpoints[_delegator][numCheckpoint];\\n        }\\n\\n        self._delegates[_delegator] = _delegatee;\\n    }\\n\\n    /// @notice Update delegatee's `delegatedBalance` by `balance`.\\n    ///         Only updates if delegating to a new delegatee.\\n    /// @dev If used with `balance` == `_locked[_tokenId].amount`, then this is the same as\\n    ///      delegating or dedelegating from `_tokenId`\\n    ///      If used with `balance` < `_locked[_tokenId].amount`, then this is used to adjust\\n    ///      `delegatedBalance` when a user's balance is modified (e.g. `increaseAmount`, `merge` etc).\\n    ///      If `delegatee` is 0 (i.e. user is not delegating), then do nothing.\\n    /// @param _delegatee The delegatee's tokenId\\n    /// @param balance_ The delta in balance change\\n    /// @param _increase True if balance is increasing, false if decreasing\\n    function _checkpointDelegatee(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _delegatee,\\n        uint256 balance_,\\n        bool _increase\\n    ) internal {\\n        if (_delegatee == 0) return;\\n        uint48 numCheckpoint = self.numCheckpoints[_delegatee];\\n        IVotingEscrow.Checkpoint storage cpOld = numCheckpoint > 0\\n            ? self._checkpoints[_delegatee][numCheckpoint - 1]\\n            : self._checkpoints[_delegatee][0];\\n        IVotingEscrow.Checkpoint storage cp = self._checkpoints[_delegatee][\\n            numCheckpoint\\n        ];\\n        cp.fromTimestamp = block.timestamp;\\n        cp.owner = cpOld.owner;\\n        // do not expect balance_ > cpOld.delegatedBalance when decrementing but just in case\\n        cp.delegatedBalance = _increase\\n            ? cpOld.delegatedBalance + balance_\\n            : (\\n                balance_ < cpOld.delegatedBalance\\n                    ? cpOld.delegatedBalance - balance_\\n                    : 0\\n            );\\n        cp.delegatee = cpOld.delegatee;\\n\\n        if (_isCheckpointInNewBlock(self, _delegatee)) {\\n            self.numCheckpoints[_delegatee]++;\\n        } else {\\n            self._checkpoints[_delegatee][numCheckpoint - 1] = cp;\\n            delete self._checkpoints[_delegatee][numCheckpoint];\\n        }\\n    }\\n\\n    function _isCheckpointInNewBlock(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) internal view returns (bool) {\\n        uint48 _nCheckPoints = self.numCheckpoints[_tokenId];\\n\\n        if (\\n            _nCheckPoints > 0 &&\\n            self._checkpoints[_tokenId][_nCheckPoints - 1].fromTimestamp ==\\n            block.timestamp\\n        ) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /// @notice Retrieves historical voting balance for a token id at a given timestamp.\\n    /// @dev If a checkpoint does not exist prior to the timestamp, this will return 0.\\n    ///      The user must also own the token at the time in order to receive a voting balance.\\n    /// @param _account .\\n    /// @param _tokenId .\\n    /// @param _timestamp .\\n    /// @return Total voting balance including delegations at a given timestamp.\\n    function getPastVotes(\\n        VotingEscrowState.Storage storage self,\\n        address _account,\\n        uint256 _tokenId,\\n        uint256 _timestamp\\n    ) external view returns (uint256) {\\n        uint48 _checkIndex = getPastVotesIndex(self, _tokenId, _timestamp);\\n        IVotingEscrow.Checkpoint memory lastCheckpoint = self._checkpoints[\\n            _tokenId\\n        ][_checkIndex];\\n        // If no point exists prior to the given timestamp, return 0\\n        if (lastCheckpoint.fromTimestamp > _timestamp) return 0;\\n        // Check ownership\\n        if (_account != lastCheckpoint.owner) return 0;\\n        uint256 votes = lastCheckpoint.delegatedBalance;\\n        return\\n            lastCheckpoint.delegatee == 0\\n                ? votes +\\n                    IVotingEscrow(address(this)).balanceOfNFTAt(\\n                        _tokenId,\\n                        _timestamp\\n                    )\\n                : votes;\\n    }\\n\\n    /// @notice Binary search to get the voting checkpoint for a token id at or prior to a given timestamp.\\n    /// @dev If a checkpoint does not exist prior to the timestamp, this will return 0.\\n    /// @param _tokenId .\\n    /// @param _timestamp .\\n    /// @return The index of the checkpoint.\\n    function getPastVotesIndex(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        uint256 _timestamp\\n    ) internal view returns (uint48) {\\n        uint48 nCheckpoints = self.numCheckpoints[_tokenId];\\n        if (nCheckpoints == 0) return 0;\\n        // First check most recent balance\\n        if (\\n            self._checkpoints[_tokenId][nCheckpoints - 1].fromTimestamp <=\\n            _timestamp\\n        ) return (nCheckpoints - 1);\\n        // Next check implicit zero balance\\n        if (self._checkpoints[_tokenId][0].fromTimestamp > _timestamp) return 0;\\n\\n        uint48 lower = 0;\\n        uint48 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint48 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            IVotingEscrow.Checkpoint storage cp = self._checkpoints[_tokenId][\\n                center\\n            ];\\n            if (cp.fromTimestamp == _timestamp) {\\n                return center;\\n            } else if (cp.fromTimestamp < _timestamp) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return lower;\\n    }\\n}\\n\",\"keccak256\":\"0xece6e6f074dfc6a50335fb384d42e01d9fa168292f8dc8e3b17e6f674953cd2f\",\"license\":\"BUSL-1.1\"},\"contracts/ve/Escrow.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.24;\\n\\nimport {VotingEscrowState} from \\\"./VotingEscrowState.sol\\\";\\nimport {Delegation} from \\\"./Delegation.sol\\\";\\nimport {NFT} from \\\"./NFT.sol\\\";\\nimport {VeERC2771Context} from \\\"./VeERC2771Context.sol\\\";\\nimport {SafeCastLibrary} from \\\"../libraries/SafeCastLibrary.sol\\\";\\nimport {IReward} from \\\"../interfaces/IReward.sol\\\";\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC4906} from \\\"@openzeppelin/contracts/interfaces/IERC4906.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nlibrary Escrow {\\n    using SafeERC20 for IERC20;\\n    using SafeCastLibrary for uint256;\\n    using SafeCastLibrary for int128;\\n    using NFT for VotingEscrowState.Storage;\\n    using Delegation for VotingEscrowState.Storage;\\n    using VeERC2771Context for VotingEscrowState.Storage;\\n\\n    uint256 internal constant WEEK = 1 weeks;\\n    uint256 internal constant MULTIPLIER = 1 ether;\\n\\n    function depositFor(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        uint256 _value\\n    ) external {\\n        if (\\n            self.escrowType[_tokenId] == IVotingEscrow.EscrowType.MANAGED &&\\n            self._msgSender() != self.distributor\\n        ) revert IVotingEscrow.NotDistributor();\\n        _increaseAmountFor(\\n            self,\\n            _tokenId,\\n            _value,\\n            IVotingEscrow.DepositType.DEPOSIT_FOR_TYPE\\n        );\\n    }\\n\\n    /// @notice Deposit and lock tokens for a user\\n    /// @param _tokenId NFT that holds lock\\n    /// @param _value Amount to deposit\\n    /// @param _unlockTime New time when to unlock the tokens, or 0 if unchanged\\n    /// @param _oldLocked Previous locked amount / timestamp\\n    /// @param _depositType The type of deposit\\n    function _depositFor(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        uint256 _value,\\n        uint256 _unlockTime,\\n        IVotingEscrow.LockedBalance memory _oldLocked,\\n        IVotingEscrow.DepositType _depositType\\n    ) internal {\\n        uint256 supplyBefore = self.supply;\\n        self.supply = supplyBefore + _value;\\n\\n        // Set newLocked to _oldLocked without mangling memory\\n        IVotingEscrow.LockedBalance memory newLocked;\\n        (newLocked.amount, newLocked.end, newLocked.isPermanent) = (\\n            _oldLocked.amount,\\n            _oldLocked.end,\\n            _oldLocked.isPermanent\\n        );\\n\\n        // Adding to existing lock, or if a lock is expired - creating a new one\\n        newLocked.amount += _value.toInt128();\\n        if (_unlockTime != 0) {\\n            newLocked.end = _unlockTime;\\n        }\\n        self._locked[_tokenId] = newLocked;\\n\\n        // Possibilities:\\n        // Both _oldLocked.end could be current or expired (>/< block.timestamp)\\n        // or if the lock is a permanent lock, then _oldLocked.end == 0\\n        // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\\n        // newLocked.end > block.timestamp (always)\\n        _checkpoint(self, _tokenId, _oldLocked, newLocked);\\n\\n        address from = self._msgSender();\\n        if (_value != 0) {\\n            IERC20(self.token).safeTransferFrom(from, address(this), _value);\\n        }\\n\\n        emit IVotingEscrow.Deposit(\\n            from,\\n            _tokenId,\\n            _depositType,\\n            _value,\\n            newLocked.end,\\n            block.timestamp\\n        );\\n        emit IVotingEscrow.Supply(supplyBefore, supplyBefore + _value);\\n    }\\n\\n    /// @notice Record global and per-user data to checkpoints. Used by VotingEscrow system.\\n    /// @param _tokenId NFT token ID. No user checkpoint if 0\\n    /// @param _oldLocked Previous locked amount / end lock time for the user\\n    /// @param _newLocked New locked amount / end lock time for the user\\n    function _checkpoint(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        IVotingEscrow.LockedBalance memory _oldLocked,\\n        IVotingEscrow.LockedBalance memory _newLocked\\n    ) internal {\\n        IVotingEscrow.UserPoint memory uOld;\\n        IVotingEscrow.UserPoint memory uNew;\\n        int128 oldDslope = 0;\\n        int128 newDslope = 0;\\n        uint256 _epoch = self.epoch;\\n\\n        if (_tokenId != 0) {\\n            uNew.permanent = _newLocked.isPermanent\\n                ? _newLocked.amount.toUint256()\\n                : 0;\\n            // Calculate slopes and biases\\n            // Kept at zero when they have to\\n            if (_oldLocked.end > block.timestamp && _oldLocked.amount > 0) {\\n                uOld.slope = _oldLocked.amount / self.maxLockTime.toInt128();\\n                uOld.bias =\\n                    uOld.slope *\\n                    (_oldLocked.end - block.timestamp).toInt128();\\n            }\\n            if (_newLocked.end > block.timestamp && _newLocked.amount > 0) {\\n                uNew.slope = _newLocked.amount / self.maxLockTime.toInt128();\\n                uNew.bias =\\n                    uNew.slope *\\n                    (_newLocked.end - block.timestamp).toInt128();\\n            }\\n\\n            // Read values of scheduled changes in the slope\\n            // _oldLocked.end can be in the past and in the future\\n            // _newLocked.end can ONLY by in the FUTURE unless everything expired: than zeros\\n            oldDslope = self.slopeChanges[_oldLocked.end];\\n            if (_newLocked.end != 0) {\\n                if (_newLocked.end == _oldLocked.end) {\\n                    newDslope = oldDslope;\\n                } else {\\n                    newDslope = self.slopeChanges[_newLocked.end];\\n                }\\n            }\\n        }\\n\\n        IVotingEscrow.GlobalPoint memory lastPoint = IVotingEscrow.GlobalPoint({\\n            bias: 0,\\n            slope: 0,\\n            ts: block.timestamp,\\n            blk: block.number,\\n            permanentLockBalance: 0\\n        });\\n        if (_epoch > 0) {\\n            lastPoint = self._pointHistory[_epoch];\\n        }\\n        uint256 lastCheckpoint = lastPoint.ts;\\n        // initialLastPoint is used for extrapolation to calculate block number\\n        // (approximately, for *At methods) and save them\\n        // as we cannot figure that out exactly from inside the contract\\n        IVotingEscrow.GlobalPoint memory initialLastPoint = IVotingEscrow\\n            .GlobalPoint({\\n                bias: lastPoint.bias,\\n                slope: lastPoint.slope,\\n                ts: lastPoint.ts,\\n                blk: lastPoint.blk,\\n                permanentLockBalance: lastPoint.permanentLockBalance\\n            });\\n        uint256 blockSlope = 0; // dblock/dt\\n        if (block.timestamp > lastPoint.ts) {\\n            blockSlope =\\n                (MULTIPLIER * (block.number - lastPoint.blk)) /\\n                (block.timestamp - lastPoint.ts);\\n        }\\n        // If last point is already recorded in this block, slope=0\\n        // But that's ok b/c we know the block in such case\\n\\n        // Go over weeks to fill history and calculate what the current point is\\n        (_epoch, lastPoint) = _updateHistory(\\n            self,\\n            _epoch,\\n            lastPoint,\\n            lastCheckpoint,\\n            initialLastPoint,\\n            blockSlope\\n        );\\n\\n        if (_tokenId != 0) {\\n            // If last point was in this block, the slope change has been applied already\\n            // But in such case we have 0 slope(s)\\n            lastPoint.slope += (uNew.slope - uOld.slope);\\n            lastPoint.bias += (uNew.bias - uOld.bias);\\n            if (lastPoint.slope < 0) {\\n                lastPoint.slope = 0;\\n            }\\n            if (lastPoint.bias < 0) {\\n                lastPoint.bias = 0;\\n            }\\n            lastPoint.permanentLockBalance = self.permanentLockBalance;\\n        }\\n\\n        // If timestamp of last global point is the same, overwrite the last global point\\n        // Else record the new global point into history\\n        // Exclude epoch 0 (note: _epoch is always >= 1, see above)\\n        // Two possible outcomes:\\n        // Missing global checkpoints in prior weeks. In this case, _epoch = epoch + x, where x > 1\\n        // No missing global checkpoints, but timestamp != block.timestamp. Create new checkpoint.\\n        // No missing global checkpoints, but timestamp == block.timestamp. Overwrite last checkpoint.\\n        if (\\n            _epoch != 1 && self._pointHistory[_epoch - 1].ts == block.timestamp\\n        ) {\\n            // _epoch = epoch + 1, so we do not increment epoch\\n            self._pointHistory[_epoch - 1] = lastPoint;\\n        } else {\\n            // more than one global point may have been written, so we update epoch\\n            self.epoch = _epoch;\\n            self._pointHistory[_epoch] = lastPoint;\\n        }\\n\\n        if (_tokenId != 0) {\\n            // Schedule the slope changes (slope is going down)\\n            // We subtract new_user_slope from [_newLocked.end]\\n            // and add old_user_slope to [_oldLocked.end]\\n            if (_oldLocked.end > block.timestamp) {\\n                // oldDslope was <something> - uOld.slope, so we cancel that\\n                oldDslope += uOld.slope;\\n                if (_newLocked.end == _oldLocked.end) {\\n                    oldDslope -= uNew.slope; // It was a new deposit, not extension\\n                }\\n                self.slopeChanges[_oldLocked.end] = oldDslope;\\n            }\\n\\n            if (_newLocked.end > block.timestamp) {\\n                // update slope if new lock is greater than old lock and is not permanent or if old lock is permanent\\n                if ((_newLocked.end > _oldLocked.end)) {\\n                    newDslope -= uNew.slope; // old slope disappeared at this point\\n                    self.slopeChanges[_newLocked.end] = newDslope;\\n                }\\n                // else: we recorded it already in oldDslope\\n            }\\n            // If timestamp of last user point is the same, overwrite the last user point\\n            // Else record the new user point into history\\n            // Exclude epoch 0\\n            uNew.ts = block.timestamp;\\n            uNew.blk = block.number;\\n            uint256 userEpoch = self.userPointEpoch[_tokenId];\\n            if (\\n                userEpoch != 0 &&\\n                self._userPointHistory[_tokenId][userEpoch].ts ==\\n                block.timestamp\\n            ) {\\n                self._userPointHistory[_tokenId][userEpoch] = uNew;\\n            } else {\\n                self.userPointEpoch[_tokenId] = ++userEpoch;\\n                self._userPointHistory[_tokenId][userEpoch] = uNew;\\n            }\\n        }\\n    }\\n\\n    function _updateHistory(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _epoch,\\n        IVotingEscrow.GlobalPoint memory lastPoint,\\n        uint256 lastCheckpoint,\\n        IVotingEscrow.GlobalPoint memory initialLastPoint,\\n        uint256 blockSlope\\n    ) internal returns (uint256, IVotingEscrow.GlobalPoint memory) {\\n        uint256 t_i = (lastCheckpoint / WEEK) * WEEK;\\n        for (uint256 i = 0; i < 255; ++i) {\\n            // Hopefully it won't happen that this won't get used in 5 years!\\n            // If it does, users will be able to withdraw but vote weight will be broken\\n            t_i += WEEK; // Initial value of t_i is always larger than the ts of the last point\\n            int128 d_slope = 0;\\n            if (t_i > block.timestamp) {\\n                t_i = block.timestamp;\\n            } else {\\n                d_slope = self.slopeChanges[t_i];\\n            }\\n            lastPoint.bias -=\\n                lastPoint.slope *\\n                (t_i - lastCheckpoint).toInt128();\\n            lastPoint.slope += d_slope;\\n            if (lastPoint.bias < 0) {\\n                // This can happen\\n                lastPoint.bias = 0;\\n            }\\n            if (lastPoint.slope < 0) {\\n                // This cannot happen - just in case\\n                lastPoint.slope = 0;\\n            }\\n            lastCheckpoint = t_i;\\n            lastPoint.ts = t_i;\\n            lastPoint.blk =\\n                initialLastPoint.blk +\\n                (blockSlope * (t_i - initialLastPoint.ts)) /\\n                MULTIPLIER;\\n            _epoch += 1;\\n            if (t_i == block.timestamp) {\\n                lastPoint.blk = block.number;\\n                break;\\n            } else {\\n                self._pointHistory[_epoch] = lastPoint;\\n            }\\n        }\\n        return (_epoch, lastPoint);\\n    }\\n\\n    /// @dev Deposit `_value` tokens for `_to` and lock for `_lockDuration`\\n    /// @param _value Amount to deposit\\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\\n    /// @param _to Address to deposit\\n    function _createLock(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _value,\\n        uint256 _lockDuration,\\n        address _to\\n    ) external returns (uint256) {\\n        uint256 unlockTime = ((block.timestamp + _lockDuration) / WEEK) * WEEK; // Locktime is rounded down to weeks\\n\\n        if (_value == 0) revert IVotingEscrow.ZeroAmount();\\n        if (unlockTime <= block.timestamp)\\n            revert IVotingEscrow.LockDurationNotInFuture();\\n        if (unlockTime > block.timestamp + self.maxLockTime)\\n            revert IVotingEscrow.LockDurationTooLong();\\n\\n        uint256 _tokenId = ++self.tokenId;\\n        self._mint(_to, _tokenId);\\n\\n        _depositFor(\\n            self,\\n            _tokenId,\\n            _value,\\n            unlockTime,\\n            self._locked[_tokenId],\\n            IVotingEscrow.DepositType.CREATE_LOCK_TYPE\\n        );\\n        return _tokenId;\\n    }\\n\\n    function increaseAmount(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        uint256 _value\\n    ) external {\\n        if (!self._isApprovedOrOwner(self._msgSender(), _tokenId))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        _increaseAmountFor(\\n            self,\\n            _tokenId,\\n            _value,\\n            IVotingEscrow.DepositType.INCREASE_LOCK_AMOUNT\\n        );\\n    }\\n\\n    function _increaseAmountFor(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        uint256 _value,\\n        IVotingEscrow.DepositType _depositType\\n    ) internal {\\n        IVotingEscrow.EscrowType _escrowType = self.escrowType[_tokenId];\\n        if (_escrowType == IVotingEscrow.EscrowType.LOCKED)\\n            revert IVotingEscrow.NotManagedOrNormalNFT();\\n\\n        IVotingEscrow.LockedBalance memory oldLocked = self._locked[_tokenId];\\n\\n        if (_value == 0) revert IVotingEscrow.ZeroAmount();\\n        if (oldLocked.amount <= 0) revert IVotingEscrow.NoLockFound();\\n        if (oldLocked.end <= block.timestamp && !oldLocked.isPermanent)\\n            revert IVotingEscrow.LockExpired();\\n\\n        if (oldLocked.isPermanent) self.permanentLockBalance += _value;\\n        self._checkpointDelegatee(self._delegates[_tokenId], _value, true);\\n        _depositFor(self, _tokenId, _value, 0, oldLocked, _depositType);\\n\\n        if (_escrowType == IVotingEscrow.EscrowType.MANAGED) {\\n            // increaseAmount called on managed tokens are treated as locked rewards\\n            address _lockedManagedReward = self.managedToLocked[_tokenId];\\n            address _token = self.token;\\n            IERC20(_token).safeApprove(_lockedManagedReward, _value);\\n            IReward(_lockedManagedReward).notifyRewardAmount(_token, _value);\\n            IERC20(_token).safeApprove(_lockedManagedReward, 0);\\n        }\\n\\n        emit IERC4906.MetadataUpdate(_tokenId);\\n    }\\n\\n    function increaseUnlockTime(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        uint256 _lockDuration\\n    ) external {\\n        if (!self._isApprovedOrOwner(self._msgSender(), _tokenId))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.NORMAL)\\n            revert IVotingEscrow.NotNormalNFT();\\n\\n        IVotingEscrow.LockedBalance memory oldLocked = self._locked[_tokenId];\\n        if (oldLocked.isPermanent) revert IVotingEscrow.PermanentLock();\\n        uint256 unlockTime = ((block.timestamp + _lockDuration) / WEEK) * WEEK; // Locktime is rounded down to weeks\\n\\n        if (oldLocked.end <= block.timestamp)\\n            revert IVotingEscrow.LockExpired();\\n        if (oldLocked.amount <= 0) revert IVotingEscrow.NoLockFound();\\n        if (unlockTime <= oldLocked.end)\\n            revert IVotingEscrow.LockDurationNotInFuture();\\n        if (unlockTime > block.timestamp + self.maxLockTime)\\n            revert IVotingEscrow.LockDurationTooLong();\\n\\n        _depositFor(\\n            self,\\n            _tokenId,\\n            0,\\n            unlockTime,\\n            oldLocked,\\n            IVotingEscrow.DepositType.INCREASE_UNLOCK_TIME\\n        );\\n\\n        emit IERC4906.MetadataUpdate(_tokenId);\\n    }\\n\\n    function withdraw(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) external {\\n        address sender = self._msgSender();\\n        if (!self._isApprovedOrOwner(sender, _tokenId))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        if (self.voted[_tokenId]) revert IVotingEscrow.AlreadyVoted();\\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.NORMAL)\\n            revert IVotingEscrow.NotNormalNFT();\\n\\n        IVotingEscrow.LockedBalance memory oldLocked = self._locked[_tokenId];\\n        if (oldLocked.isPermanent) revert IVotingEscrow.PermanentLock();\\n        if (block.timestamp < oldLocked.end)\\n            revert IVotingEscrow.LockNotExpired();\\n        uint256 value = oldLocked.amount.toUint256();\\n\\n        // Burn the NFT\\n        self._burn(_tokenId);\\n        self._locked[_tokenId] = IVotingEscrow.LockedBalance(0, 0, false);\\n        uint256 supplyBefore = self.supply;\\n        self.supply = supplyBefore - value;\\n\\n        // oldLocked can have either expired <= timestamp or zero end\\n        // oldLocked has only 0 end\\n        // Both can have >= 0 amount\\n        _checkpoint(\\n            self,\\n            _tokenId,\\n            oldLocked,\\n            IVotingEscrow.LockedBalance(0, 0, false)\\n        );\\n\\n        IERC20(self.token).safeTransfer(sender, value);\\n\\n        emit IVotingEscrow.Withdraw(sender, _tokenId, value, block.timestamp);\\n        emit IVotingEscrow.Supply(supplyBefore, supplyBefore - value);\\n    }\\n\\n    function merge(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _from,\\n        uint256 _to\\n    ) external {\\n        address sender = self._msgSender();\\n        if (self.voted[_from]) revert IVotingEscrow.AlreadyVoted();\\n        if (self.escrowType[_from] != IVotingEscrow.EscrowType.NORMAL)\\n            revert IVotingEscrow.NotNormalNFT();\\n        if (self.escrowType[_to] != IVotingEscrow.EscrowType.NORMAL)\\n            revert IVotingEscrow.NotNormalNFT();\\n        if (_from == _to) revert IVotingEscrow.SameNFT();\\n        if (!self._isApprovedOrOwner(sender, _from))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        if (!self._isApprovedOrOwner(sender, _to))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        IVotingEscrow.LockedBalance memory oldLockedTo = self._locked[_to];\\n        if (oldLockedTo.end <= block.timestamp && !oldLockedTo.isPermanent)\\n            revert IVotingEscrow.LockExpired();\\n        if (\\n            self.vestingEnd[_from] > block.timestamp ||\\n            self.vestingEnd[_to] > block.timestamp\\n        ) {\\n            revert IVotingEscrow.UnvestedGrantNFT();\\n        }\\n\\n        IVotingEscrow.LockedBalance memory oldLockedFrom = self._locked[_from];\\n        if (oldLockedFrom.isPermanent) revert IVotingEscrow.PermanentLock();\\n        uint256 end = oldLockedFrom.end >= oldLockedTo.end\\n            ? oldLockedFrom.end\\n            : oldLockedTo.end;\\n\\n        self._burn(_from);\\n        self._locked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\\n        _checkpoint(\\n            self,\\n            _from,\\n            oldLockedFrom,\\n            IVotingEscrow.LockedBalance(0, 0, false)\\n        );\\n\\n        IVotingEscrow.LockedBalance memory newLockedTo;\\n        newLockedTo.amount = oldLockedTo.amount + oldLockedFrom.amount;\\n        newLockedTo.isPermanent = oldLockedTo.isPermanent;\\n        if (newLockedTo.isPermanent) {\\n            self.permanentLockBalance += oldLockedFrom.amount.toUint256();\\n        } else {\\n            newLockedTo.end = end;\\n        }\\n        self._checkpointDelegatee(\\n            self._delegates[_to],\\n            oldLockedFrom.amount.toUint256(),\\n            true\\n        );\\n        _checkpoint(self, _to, oldLockedTo, newLockedTo);\\n        self._locked[_to] = newLockedTo;\\n\\n        emit IVotingEscrow.Merge(\\n            sender,\\n            _from,\\n            _to,\\n            oldLockedFrom.amount.toUint256(),\\n            oldLockedTo.amount.toUint256(),\\n            newLockedTo.amount.toUint256(),\\n            newLockedTo.end,\\n            block.timestamp\\n        );\\n        emit IERC4906.MetadataUpdate(_to);\\n    }\\n\\n    function split(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _from,\\n        uint256 _amount\\n    ) external returns (uint256 _tokenId1, uint256 _tokenId2) {\\n        address sender = self._msgSender();\\n        address owner = self._ownerOf(_from);\\n        if (owner == address(0)) revert IVotingEscrow.SplitNoOwner();\\n        if (!self.canSplit[owner] && !self.canSplit[address(0)])\\n            revert IVotingEscrow.SplitNotAllowed();\\n        if (self.escrowType[_from] != IVotingEscrow.EscrowType.NORMAL)\\n            revert IVotingEscrow.NotNormalNFT();\\n        if (self.voted[_from]) revert IVotingEscrow.AlreadyVoted();\\n        if (!self._isApprovedOrOwner(sender, _from))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        IVotingEscrow.LockedBalance memory newLocked = self._locked[_from];\\n        if (newLocked.end <= block.timestamp && !newLocked.isPermanent)\\n            revert IVotingEscrow.LockExpired();\\n        int128 _splitAmount = _amount.toInt128();\\n        if (_splitAmount == 0) revert IVotingEscrow.ZeroAmount();\\n        if (newLocked.amount <= _splitAmount)\\n            revert IVotingEscrow.AmountTooBig();\\n        if (self.vestingEnd[_from] > block.timestamp) {\\n            revert IVotingEscrow.UnvestedGrantNFT();\\n        }\\n\\n        // Zero out and burn old veNFT\\n        self._burn(_from);\\n        self._locked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\\n        _checkpoint(\\n            self,\\n            _from,\\n            newLocked,\\n            IVotingEscrow.LockedBalance(0, 0, false)\\n        );\\n\\n        // Create new veNFT using old balance - amount\\n        newLocked.amount -= _splitAmount;\\n        _tokenId1 = _createSplitNFT(self, owner, newLocked);\\n\\n        // Create new veNFT using amount\\n        newLocked.amount = _splitAmount;\\n        _tokenId2 = _createSplitNFT(self, owner, newLocked);\\n\\n        emit IVotingEscrow.Split(\\n            _from,\\n            _tokenId1,\\n            _tokenId2,\\n            sender,\\n            self._locked[_tokenId1].amount.toUint256(),\\n            _splitAmount.toUint256(),\\n            newLocked.end,\\n            block.timestamp\\n        );\\n    }\\n\\n    function _createSplitNFT(\\n        VotingEscrowState.Storage storage self,\\n        address _to,\\n        IVotingEscrow.LockedBalance memory _newLocked\\n    ) internal returns (uint256 _tokenId) {\\n        _tokenId = ++self.tokenId;\\n        self._locked[_tokenId] = _newLocked;\\n        _checkpoint(\\n            self,\\n            _tokenId,\\n            IVotingEscrow.LockedBalance(0, 0, false),\\n            _newLocked\\n        );\\n        self._mint(_to, _tokenId);\\n    }\\n\\n    function toggleSplit(\\n        VotingEscrowState.Storage storage self,\\n        address _account,\\n        bool _bool\\n    ) external {\\n        if (self._msgSender() != self.team) revert IVotingEscrow.NotTeam();\\n        self.canSplit[_account] = _bool;\\n    }\\n\\n    function lockPermanent(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) external {\\n        address sender = self._msgSender();\\n        if (!self._isApprovedOrOwner(sender, _tokenId))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.NORMAL)\\n            revert IVotingEscrow.NotNormalNFT();\\n        IVotingEscrow.LockedBalance memory _newLocked = self._locked[_tokenId];\\n        if (_newLocked.isPermanent) revert IVotingEscrow.PermanentLock();\\n        if (_newLocked.end <= block.timestamp)\\n            revert IVotingEscrow.LockExpired();\\n        if (_newLocked.amount <= 0) revert IVotingEscrow.NoLockFound();\\n\\n        uint256 _amount = _newLocked.amount.toUint256();\\n        self.permanentLockBalance += _amount;\\n        _newLocked.end = 0;\\n        _newLocked.isPermanent = true;\\n        _checkpoint(self, _tokenId, self._locked[_tokenId], _newLocked);\\n        self._locked[_tokenId] = _newLocked;\\n\\n        emit IVotingEscrow.LockPermanent(\\n            sender,\\n            _tokenId,\\n            _amount,\\n            block.timestamp\\n        );\\n        emit IERC4906.MetadataUpdate(_tokenId);\\n    }\\n\\n    function unlockPermanent(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) external {\\n        address sender = self._msgSender();\\n        if (!self._isApprovedOrOwner(sender, _tokenId))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.NORMAL)\\n            revert IVotingEscrow.NotNormalNFT();\\n        if (self.voted[_tokenId]) revert IVotingEscrow.AlreadyVoted();\\n        IVotingEscrow.LockedBalance memory _newLocked = self._locked[_tokenId];\\n        if (!_newLocked.isPermanent) revert IVotingEscrow.NotPermanentLock();\\n\\n        uint256 _amount = _newLocked.amount.toUint256();\\n        self.permanentLockBalance -= _amount;\\n        _newLocked.end = ((block.timestamp + self.maxLockTime) / WEEK) * WEEK;\\n        _newLocked.isPermanent = false;\\n        self._delegate(_tokenId, 0);\\n        _checkpoint(self, _tokenId, self._locked[_tokenId], _newLocked);\\n        self._locked[_tokenId] = _newLocked;\\n\\n        emit IVotingEscrow.UnlockPermanent(\\n            sender,\\n            _tokenId,\\n            _amount,\\n            block.timestamp\\n        );\\n        emit IERC4906.MetadataUpdate(_tokenId);\\n    }\\n}\\n\",\"keccak256\":\"0x910ffefb1177b3df153de77f8d06e87f2667b67534aa0d4a66dcaa7a2d5ed43b\",\"license\":\"BUSL-1.1\"},\"contracts/ve/Grant.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.8.24;\\n\\nimport {VotingEscrowState} from \\\"./VotingEscrowState.sol\\\";\\nimport {Escrow} from \\\"./Escrow.sol\\\";\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\n\\nlibrary Grant {\\n    using Escrow for VotingEscrowState.Storage;\\n\\n    function _createGrantLockFor(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _value,\\n        address _grantee,\\n        address _grantManager,\\n        uint256 _vestingEnd\\n    ) external returns (uint256) {\\n        uint256 lockDuration = _vestingEnd - block.timestamp;\\n\\n        uint256 tokenId = self._createLock(_value, lockDuration, _grantee);\\n        self.grantManager[tokenId] = _grantManager;\\n        self.vestingEnd[tokenId] = _vestingEnd;\\n\\n        emit IVotingEscrow.CreateGrant(\\n            tokenId,\\n            _grantee,\\n            _grantManager,\\n            _vestingEnd\\n        );\\n\\n        return tokenId;\\n    }\\n\\n    function _setGrantManager(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        address _newGrantManager\\n    ) external {\\n        if (msg.sender != self.grantManager[_tokenId]) {\\n            revert IVotingEscrow.NotGrantManager();\\n        }\\n\\n        self.grantManager[_tokenId] = _newGrantManager;\\n        emit IVotingEscrow.SetGrantManager(_newGrantManager);\\n    }\\n}\\n\",\"keccak256\":\"0x30d1b59f4f897f50fb592c8d589d661d868e1dbc2c179a61a181e89f6939b24a\",\"license\":\"GPL-3.0-or-later\"},\"contracts/ve/NFT.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.24;\\n\\nimport {VotingEscrowState} from \\\"./VotingEscrowState.sol\\\";\\nimport {Delegation} from \\\"./Delegation.sol\\\";\\nimport {VeERC2771Context} from \\\"./VeERC2771Context.sol\\\";\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\n\\nlibrary NFT {\\n    using Delegation for VotingEscrowState.Storage;\\n    using VeERC2771Context for VotingEscrowState.Storage;\\n\\n    function approve(\\n        VotingEscrowState.Storage storage self,\\n        address _approved,\\n        uint256 _tokenId\\n    ) external {\\n        address sender = self._msgSender();\\n        address owner = _ownerOf(self, _tokenId);\\n        // Throws if `_tokenId` is not a valid NFT\\n        if (owner == address(0)) revert IVotingEscrow.ZeroAddress();\\n        // Throws if `_approved` is the current owner\\n        if (owner == _approved) revert IVotingEscrow.SameAddress();\\n        // Check requirements\\n        bool senderIsOwner = (_ownerOf(self, _tokenId) == sender);\\n        bool senderIsApprovedForAll = (self.ownerToOperators[owner])[sender];\\n        if (!senderIsOwner && !senderIsApprovedForAll)\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        // Set the approval\\n        self.idToApprovals[_tokenId] = _approved;\\n        emit IERC721.Approval(owner, _approved, _tokenId);\\n    }\\n\\n    function setApprovalForAll(\\n        VotingEscrowState.Storage storage self,\\n        address _operator,\\n        bool _approved\\n    ) external {\\n        address sender = self._msgSender();\\n        // Throws if `_operator` is the `msg.sender`\\n        if (_operator == sender) revert IVotingEscrow.SameAddress();\\n        self.ownerToOperators[sender][_operator] = _approved;\\n        emit IERC721.ApprovalForAll(sender, _operator, _approved);\\n    }\\n\\n    function safeTransferFrom(\\n        VotingEscrowState.Storage storage self,\\n        address _from,\\n        address _to,\\n        uint256 _tokenId,\\n        bytes memory _data\\n    ) external {\\n        address sender = self._msgSender();\\n        _transferFrom(self, _from, _to, _tokenId, sender);\\n\\n        if (_isContract(_to)) {\\n            // Throws if transfer destination is a contract which does not implement 'onERC721Received'\\n            try\\n                IERC721Receiver(_to).onERC721Received(\\n                    sender,\\n                    _from,\\n                    _tokenId,\\n                    _data\\n                )\\n            returns (bytes4 response) {\\n                if (\\n                    response != IERC721Receiver(_to).onERC721Received.selector\\n                ) {\\n                    revert IVotingEscrow.ERC721ReceiverRejectedTokens();\\n                }\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert IVotingEscrow\\n                        .ERC721TransferToNonERC721ReceiverImplementer();\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function _transferFrom(\\n        VotingEscrowState.Storage storage self,\\n        address _from,\\n        address _to,\\n        uint256 _tokenId,\\n        address _sender\\n    ) internal {\\n        if (self.escrowType[_tokenId] == IVotingEscrow.EscrowType.LOCKED)\\n            revert IVotingEscrow.NotManagedOrNormalNFT();\\n        // Check requirements\\n        if (!_isApprovedOrOwner(self, _sender, _tokenId))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        // Clear approval. Throws if `_from` is not the current owner\\n        if (_ownerOf(self, _tokenId) != _from) revert IVotingEscrow.NotOwner();\\n        delete self.idToApprovals[_tokenId];\\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\\n        _removeTokenFrom(self, _from, _tokenId);\\n        // Update voting checkpoints\\n        self._checkpointDelegator(_tokenId, 0, _to);\\n        // Add NFT\\n        _addTokenTo(self, _to, _tokenId);\\n        // Set the block of ownership transfer (for Flash NFT protection)\\n        self.ownershipChange[_tokenId] = block.number;\\n        // Log the transfer\\n        emit IERC721.Transfer(_from, _to, _tokenId);\\n    }\\n\\n    function _isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /// @dev Add a NFT to a given address\\n    ///      Throws if `_tokenId` is owned by someone.\\n    function _addTokenTo(\\n        VotingEscrowState.Storage storage self,\\n        address _to,\\n        uint256 _tokenId\\n    ) internal {\\n        // Throws if `_tokenId` is owned by someone\\n        assert(_ownerOf(self, _tokenId) == address(0));\\n        // Change the owner\\n        self.idToOwner[_tokenId] = _to;\\n        // Update owner token index tracking\\n        _addTokenToOwnerList(self, _to, _tokenId);\\n        // Change count tracking\\n        self.ownerToNFTokenCount[_to] += 1;\\n    }\\n\\n    /// @dev Function to mint tokens\\n    ///      Throws if `_to` is zero address.\\n    ///      Throws if `_tokenId` is owned by someone.\\n    /// @param _to The address that will receive the minted tokens.\\n    /// @param _tokenId The token id to mint.\\n    /// @return A boolean that indicates if the operation was successful.\\n    function _mint(\\n        VotingEscrowState.Storage storage self,\\n        address _to,\\n        uint256 _tokenId\\n    ) internal returns (bool) {\\n        // Throws if `_to` is zero address\\n        assert(_to != address(0));\\n        // Add NFT. Throws if `_tokenId` is owned by someone\\n        _addTokenTo(self, _to, _tokenId);\\n        // Update voting checkpoints\\n        self._checkpointDelegator(_tokenId, 0, _to);\\n        emit IERC721.Transfer(address(0), _to, _tokenId);\\n        return true;\\n    }\\n\\n    /// @dev Add a NFT to an index mapping to a given address\\n    /// @param _to address of the receiver\\n    /// @param _tokenId uint ID Of the token to be added\\n    function _addTokenToOwnerList(\\n        VotingEscrowState.Storage storage self,\\n        address _to,\\n        uint256 _tokenId\\n    ) internal {\\n        uint256 currentCount = self.ownerToNFTokenCount[_to];\\n\\n        self.ownerToNFTokenIdList[_to][currentCount] = _tokenId;\\n        self.tokenToOwnerIndex[_tokenId] = currentCount;\\n    }\\n\\n    function _ownerOf(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) internal view returns (address) {\\n        return self.idToOwner[_tokenId];\\n    }\\n\\n    function _isApprovedOrOwner(\\n        VotingEscrowState.Storage storage self,\\n        address _spender,\\n        uint256 _tokenId\\n    ) internal view returns (bool) {\\n        address owner = _ownerOf(self, _tokenId);\\n        bool spenderIsOwner = owner == _spender;\\n        bool spenderIsApproved = _spender == self.idToApprovals[_tokenId];\\n        bool spenderIsApprovedForAll = (self.ownerToOperators[owner])[_spender];\\n        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\\n    }\\n\\n    /// @dev Must be called prior to updating `LockedBalance`\\n    function _burn(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) internal {\\n        address sender = self._msgSender();\\n        if (!_isApprovedOrOwner(self, sender, _tokenId))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        address owner = _ownerOf(self, _tokenId);\\n\\n        // Clear approval\\n        delete self.idToApprovals[_tokenId];\\n        // Update voting checkpoints\\n        self._checkpointDelegator(_tokenId, 0, address(0));\\n        // Remove token\\n        _removeTokenFrom(self, owner, _tokenId);\\n        emit IERC721.Transfer(owner, address(0), _tokenId);\\n    }\\n\\n    /// @dev Remove a NFT from a given address\\n    ///      Throws if `_from` is not the current owner.\\n    function _removeTokenFrom(\\n        VotingEscrowState.Storage storage self,\\n        address _from,\\n        uint256 _tokenId\\n    ) internal {\\n        // Throws if `_from` is not the current owner\\n        assert(_ownerOf(self, _tokenId) == _from);\\n        // Change the owner\\n        self.idToOwner[_tokenId] = address(0);\\n        // Update owner token index tracking\\n        _removeTokenFromOwnerList(self, _from, _tokenId);\\n        // Change count tracking\\n        self.ownerToNFTokenCount[_from] -= 1;\\n    }\\n\\n    /// @dev Remove a NFT from an index mapping to a given address\\n    /// @param _from address of the sender\\n    /// @param _tokenId uint ID Of the token to be removed\\n    function _removeTokenFromOwnerList(\\n        VotingEscrowState.Storage storage self,\\n        address _from,\\n        uint256 _tokenId\\n    ) internal {\\n        // Delete\\n        uint256 currentCount = self.ownerToNFTokenCount[_from] - 1;\\n        uint256 currentIndex = self.tokenToOwnerIndex[_tokenId];\\n\\n        if (currentCount == currentIndex) {\\n            // update ownerToNFTokenIdList\\n            self.ownerToNFTokenIdList[_from][currentCount] = 0;\\n            // update tokenToOwnerIndex\\n            self.tokenToOwnerIndex[_tokenId] = 0;\\n        } else {\\n            uint256 lastTokenId = self.ownerToNFTokenIdList[_from][\\n                currentCount\\n            ];\\n\\n            // Add\\n            // update ownerToNFTokenIdList\\n            self.ownerToNFTokenIdList[_from][currentIndex] = lastTokenId;\\n            // update tokenToOwnerIndex\\n            self.tokenToOwnerIndex[lastTokenId] = currentIndex;\\n\\n            // Delete\\n            // update ownerToNFTokenIdList\\n            self.ownerToNFTokenIdList[_from][currentCount] = 0;\\n            // update tokenToOwnerIndex\\n            self.tokenToOwnerIndex[_tokenId] = 0;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe28957bd70a2e83028e318ce7ad7899c28ab7d5acd3f711f322fe2da6a083137\",\"license\":\"BUSL-1.1\"},\"contracts/ve/VeERC2771Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Based on openzeppelin-contracts/contracts/metatx/ERC2771Context.sol\\n\\npragma solidity 0.8.24;\\n\\nimport {VotingEscrowState} from \\\"./VotingEscrowState.sol\\\";\\n\\n/**\\n * @dev Context variant with ERC2771 support. Extracted to library to allow\\n *      easy application inside libraries.\\n */\\nlibrary VeERC2771Context {\\n    function isTrustedForwarder(\\n        VotingEscrowState.Storage storage self,\\n        address forwarder\\n    ) internal view returns (bool) {\\n        return forwarder == self.trustedForwarder;\\n    }\\n\\n    function _msgSender(\\n        VotingEscrowState.Storage storage self\\n    ) internal view returns (address sender) {\\n        if (msg.data.length >= 20 && isTrustedForwarder(self, msg.sender)) {\\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n        } else {\\n            return msg.sender;\\n        }\\n    }\\n\\n    function _msgData(\\n        VotingEscrowState.Storage storage self\\n    ) internal view returns (bytes calldata) {\\n        if (isTrustedForwarder(self, msg.sender)) {\\n            return msg.data[:msg.data.length - 20];\\n        } else {\\n            return msg.data;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbcd5157897425f73b6819441db0b1a58383c6e92d452d269f5987b63235aeba5\",\"license\":\"MIT\"},\"contracts/ve/VotingEscrowState.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.24;\\n\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport {VeERC2771Context} from \\\"./VeERC2771Context.sol\\\";\\nimport {IERC4906} from \\\"@openzeppelin/contracts/interfaces/IERC4906.sol\\\";\\n\\nlibrary VotingEscrowState {\\n    using VeERC2771Context for Storage;\\n\\n    struct Storage {\\n        /// @dev Address of Meta-tx Forwarder\\n        address trustedForwarder;\\n        /// @dev Address of FactoryRegistry.sol\\n        address factoryRegistry;\\n        /// @dev Address of token used to create a veNFT\\n        address token;\\n        /// @dev Address of RewardsDistributor.sol\\n        address distributor;\\n        /// @dev Address of Voter.sol\\n        address voter;\\n        /// @dev Address of Protocol Team multisig\\n        address team;\\n        /// @dev Address which can create managed NFTs\\n        address allowedManager;\\n        /// @dev Global point history at a given index (epoch -> unsigned global point)\\n        mapping(uint256 => IVotingEscrow.GlobalPoint) _pointHistory;\\n        /// @dev Mapping of interface id to bool about whether or not it's supported\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        /// @dev Current count of token\\n        uint256 tokenId;\\n        /*///////////////////////////////////////////////////////////////\\n                                MANAGED NFT\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Mapping of token id to escrow type\\n        ///      Takes advantage of the fact default value is EscrowType.NORMAL\\n        mapping(uint256 => IVotingEscrow.EscrowType) escrowType;\\n        /// @dev Mapping of token id to managed id\\n        mapping(uint256 => uint256) idToManaged;\\n        /// @dev Mapping of user token id to managed token id to weight of token id\\n        mapping(uint256 => mapping(uint256 => uint256)) weights;\\n        /// @dev Mapping of managed id to deactivated state\\n        mapping(uint256 => bool) deactivated;\\n        /// @dev Mapping from managed nft id to locked managed rewards\\n        ///      `token` denominated rewards (rebases/rewards) stored in locked\\n        ///      managed rewards contract to prevent co-mingling of assets\\n        mapping(uint256 => address) managedToLocked;\\n        /// @dev Mapping from managed nft id to free managed rewards contract\\n        ///      these rewards can be freely withdrawn by users\\n        mapping(uint256 => address) managedToFree;\\n        /*//////////////////////////////////////////////////////////////\\n                            ERC721 BALANCE/OWNER\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Mapping from NFT ID to the address that owns it.\\n        mapping(uint256 => address) idToOwner;\\n        /// @dev Mapping from owner address to count of his tokens.\\n        mapping(address => uint256) ownerToNFTokenCount;\\n        /*//////////////////////////////////////////////////////////////\\n                                ERC721 APPROVAL\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Mapping from NFT ID to approved address.\\n        mapping(uint256 => address) idToApprovals;\\n        /// @dev Mapping from owner address to mapping of operator addresses.\\n        mapping(address => mapping(address => bool)) ownerToOperators;\\n        mapping(uint256 => uint256) ownershipChange;\\n        /*//////////////////////////////////////////////////////////////\\n                            INTERNAL MINT/BURN\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Mapping from owner address to mapping of index to tokenId\\n        mapping(address => mapping(uint256 => uint256)) ownerToNFTokenIdList;\\n        /// @dev Mapping from NFT ID to index of owner\\n        mapping(uint256 => uint256) tokenToOwnerIndex;\\n        /*//////////////////////////////////////////////////////////////\\n                                    ESCROW\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Total count of epochs witnessed since contract creation\\n        uint256 epoch;\\n        /// @dev Total amount of token() deposited\\n        uint256 supply;\\n        mapping(uint256 => IVotingEscrow.LockedBalance) _locked;\\n        mapping(uint256 => IVotingEscrow.UserPoint[1000000000]) _userPointHistory;\\n        mapping(uint256 => uint256) userPointEpoch;\\n        /// @dev time -> signed slope change\\n        mapping(uint256 => int128) slopeChanges;\\n        /// @dev account -> can split\\n        mapping(address => bool) canSplit;\\n        /// @dev Aggregate permanent locked balances\\n        uint256 permanentLockBalance;\\n        /// @dev Maximum lock time of the veNFT in seconds.\\n        ///      This value SHOULD NOT be changed after deployment\\n        ///      as it affects the voting power of all existing veNFTs.\\n        ///      It is defined here and not as constant because\\n        ///      different veNFT implementations have different\\n        ///      max lock times.\\n        uint256 maxLockTime;\\n        /*///////////////////////////////////////////////////////////////\\n                                    DAO VOTING\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev A record of each accounts delegate\\n        mapping(uint256 => uint256) _delegates;\\n        /// @dev A record of delegated token checkpoints for each tokenId, by index\\n        mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint)) _checkpoints;\\n        /// @dev The number of checkpoints for each tokenId\\n        mapping(uint256 => uint48) numCheckpoints;\\n        /// @dev A record of states for signing / validating signatures\\n        mapping(address => uint256) nonces;\\n        /*///////////////////////////////////////////////////////////////\\n                                GAUGE VOTING\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Information on whether a tokenId has already voted\\n        mapping(uint256 => bool) voted;\\n        /*///////////////////////////////////////////////////////////////\\n                                TOKEN GRANT\\n        //////////////////////////////////////////////////////////////*/\\n        /// @dev Mapping from tokenId to grant manager. The grant manager can\\n        ///      revoke a grant converted to veNFT.\\n        mapping(uint256 => address) grantManager;\\n        /// @dev Mapping from tokenId to the end date of the grant vesting\\n        ///      schedule. The end date is a UNIX timestamp.\\n        mapping(uint256 => uint256) vestingEnd;\\n        // Reserved storage space in case we need to add more variables.\\n        // The convention from OpenZeppelin suggests the storage space should\\n        // add up to 50 slots. Here we want to have more slots as there are\\n        // planned upgrades of the VotingEscrow contract. If more entires are\\n        // added to the struct in the upcoming versions we need to reduce\\n        // the array size.\\n        // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n        uint256[50] __gap;\\n    }\\n\\n    function setTeam(\\n        VotingEscrowState.Storage storage self,\\n        address _team\\n    ) internal {\\n        if (self._msgSender() != self.team) revert IVotingEscrow.NotTeam();\\n        if (_team == address(0)) revert IVotingEscrow.ZeroAddress();\\n        self.team = _team;\\n    }\\n\\n    function setVoterAndDistributor(\\n        VotingEscrowState.Storage storage self,\\n        address _voter,\\n        address _distributor\\n    ) internal {\\n        if (self._msgSender() != self.voter) revert IVotingEscrow.NotVoter();\\n        self.voter = _voter;\\n        self.distributor = _distributor;\\n    }\\n\\n    function setVoting(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        bool _voted\\n    ) internal {\\n        if (self._msgSender() != self.voter) revert IVotingEscrow.NotVoter();\\n        self.voted[_tokenId] = _voted;\\n    }\\n}\\n\",\"keccak256\":\"0xaf461d9f918f782e27fcd41ad3b047e7e9cb21286bfbb2fa5a9e6886bb8e8cbf\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x61037261003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100405760003560e01c80634706810214610045578063cd636cec14610077575b600080fd5b81801561005157600080fd5b50610065610060366004610279565b610099565b60405190815260200160405180910390f35b81801561008357600080fd5b506100976100923660046102c7565b6101cb565b005b6000806100a642846102fc565b6040516325cd0a5760e01b81526004810189905260248101889052604481018290526001600160a01b038716606482015290915060009073742C32c22Bb30D8660269461aA1883495EF3E077906325cd0a5790608401602060405180830381865af4158015610119573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061013d9190610323565b600081815260258a016020908152604080832080546001600160a01b0319166001600160a01b038b811691821790925560268e018452938290208990558151908b1681529182019290925290810186905290915081907fa46b6e42a7c972f6007e1c4f5d4ce1484af92c39b4c39d7b304fc68c2412e8bd9060600160405180910390a2979650505050505050565b60008281526025840160205260409020546001600160a01b03163314610204576040516305e955bd60e21b815260040160405180910390fd5b600082815260258401602052604080822080546001600160a01b0319166001600160a01b038516908117909155905190917f59cd09b86744a119db1e3a002a433f8d2a3ef6152d8ff3a0db3251a39291d55991a2505050565b80356001600160a01b038116811461027457600080fd5b919050565b600080600080600060a0868803121561029157600080fd5b85359450602086013593506102a86040870161025d565b92506102b66060870161025d565b949793965091946080013592915050565b6000806000606084860312156102dc57600080fd5b83359250602084013591506102f36040850161025d565b90509250925092565b8181038181111561031d57634e487b7160e01b600052601160045260246000fd5b92915050565b60006020828403121561033557600080fd5b505191905056fea26469706673582212209c9ece3049d2fd1a17083044834177c7acdc9aaddc5ceb85abe1190c7d88ddc864736f6c63430008180033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100405760003560e01c80634706810214610045578063cd636cec14610077575b600080fd5b81801561005157600080fd5b50610065610060366004610279565b610099565b60405190815260200160405180910390f35b81801561008357600080fd5b506100976100923660046102c7565b6101cb565b005b6000806100a642846102fc565b6040516325cd0a5760e01b81526004810189905260248101889052604481018290526001600160a01b038716606482015290915060009073__$01508fd810828cdfde30ab86b98ee2defa$__906325cd0a5790608401602060405180830381865af4158015610119573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061013d9190610323565b600081815260258a016020908152604080832080546001600160a01b0319166001600160a01b038b811691821790925560268e018452938290208990558151908b1681529182019290925290810186905290915081907fa46b6e42a7c972f6007e1c4f5d4ce1484af92c39b4c39d7b304fc68c2412e8bd9060600160405180910390a2979650505050505050565b60008281526025840160205260409020546001600160a01b03163314610204576040516305e955bd60e21b815260040160405180910390fd5b600082815260258401602052604080822080546001600160a01b0319166001600160a01b038516908117909155905190917f59cd09b86744a119db1e3a002a433f8d2a3ef6152d8ff3a0db3251a39291d55991a2505050565b80356001600160a01b038116811461027457600080fd5b919050565b600080600080600060a0868803121561029157600080fd5b85359450602086013593506102a86040870161025d565b92506102b66060870161025d565b949793965091946080013592915050565b6000806000606084860312156102dc57600080fd5b83359250602084013591506102f36040850161025d565b90509250925092565b8181038181111561031d57634e487b7160e01b600052601160045260246000fd5b92915050565b60006020828403121561033557600080fd5b505191905056fea26469706673582212209c9ece3049d2fd1a17083044834177c7acdc9aaddc5ceb85abe1190c7d88ddc864736f6c63430008180033",
  "libraries": {
    "Escrow": "0x742C32c22Bb30D8660269461aA1883495EF3E077"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}