{
  "address": "0x47372675f99f327490dF5cdCC125DC40818a8989",
  "abi": [
    {
      "inputs": [],
      "name": "ERC721ReceiverRejectedTokens",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ERC721TransferToNonERC721ReceiverImplementer",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotApprovedOrOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotManagedOrNormalNFT",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SafeCastUnderflow",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SameAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAddress",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "approved",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    }
  ],
  "transactionHash": "0x7368b51f387e13364ba371ccd06ee6705909a2816f2aab684a2bdb1d17628ebe",
  "receipt": {
    "to": null,
    "from": "0x6e80164ea60673D64d5d6228beb684a1274Bb017",
    "contractAddress": "0x47372675f99f327490dF5cdCC125DC40818a8989",
    "transactionIndex": 1,
    "gasUsed": "947029",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x5f79c1bf977cef1c6893a8f4fa43aa87d1d55a57282eddae5ec3823a42ffd3bf",
    "transactionHash": "0x7368b51f387e13364ba371ccd06ee6705909a2816f2aab684a2bdb1d17628ebe",
    "logs": [],
    "blockNumber": 6312376,
    "cumulativeGasUsed": "995660",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "8fa39d1f75a81de120cc40b3f4adb866",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"ERC721ReceiverRejectedTokens\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotApprovedOrOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotManagedOrNormalNFT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeCastUnderflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SameAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}],\"devdoc\":{\"events\":{\"Approval(address,address,uint256)\":{\"details\":\"Emitted when `owner` enables `approved` to manage the `tokenId` token.\"},\"ApprovalForAll(address,address,bool)\":{\"details\":\"Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\"},\"Transfer(address,address,uint256)\":{\"details\":\"Emitted when `tokenId` token is transferred from `from` to `to`.\"}},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ve/NFT.sol\":\"NFT\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\",\"keccak256\":\"0xd04b0f06e0666f29cf7cccc82894de541e19bb30a765b107b1e40bb7fe5f7d7a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC4906.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4906.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\n\\n/// @title EIP-721 Metadata Update Extension\\ninterface IERC4906 is IERC165, IERC721 {\\n    /// @dev This event emits when the metadata of a token is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFT.\\n    event MetadataUpdate(uint256 _tokenId);\\n\\n    /// @dev This event emits when the metadata of a range of tokens is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFTs.\\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\\n}\\n\",\"keccak256\":\"0x2a9dadb806be80dd451821f1f1190eb9aa6f6edae85b185db29d60767cc0c5f4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC6372.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC6372 {\\n    /**\\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\\n     */\\n    function clock() external view returns (uint48);\\n\\n    /**\\n     * @dev Description of the clock\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function CLOCK_MODE() external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xcaea9aeda3816ba872358c828f4f01455c22ae48ced49c4c7d72bd74176c09b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721.sol\\\";\\n\",\"keccak256\":\"0xaf297d12d8d4a57fe01a70f0ef38908f208e3faedc577056d0b728fa2f3ccf0c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xa82b58eca1ee256be466e536706850163d2ec7821945abd6b4778cfb3bee37da\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/governance/IVotes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\n/// Modified IVotes interface for tokenId based voting\\ninterface IVotes {\\n    /**\\n     * @dev Emitted when an account changes their delegate.\\n     */\\n    event DelegateChanged(\\n        address indexed delegator,\\n        uint256 indexed fromDelegate,\\n        uint256 indexed toDelegate\\n    );\\n\\n    /**\\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\\n     */\\n    event DelegateVotesChanged(\\n        address indexed delegate,\\n        uint256 previousBalance,\\n        uint256 newBalance\\n    );\\n\\n    /**\\n     * @dev Returns the amount of votes that `tokenId` had at a specific moment in the past.\\n     *      If the account passed in is not the owner, returns 0.\\n     */\\n    function getPastVotes(\\n        address account,\\n        uint256 tokenId,\\n        uint256 timepoint\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\\n     * configured to use block numbers, this will return the value the end of the corresponding block.\\n     *\\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\\n     * vote.\\n     */\\n    function getPastTotalSupply(\\n        uint256 timepoint\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the delegate that `tokenId` has chosen. Can never be equal to the delegator's `tokenId`.\\n     *      Returns 0 if not delegated.\\n     */\\n    function delegates(uint256 tokenId) external view returns (uint256);\\n\\n    /**\\n     * @dev Delegates votes from the sender to `delegatee`.\\n     */\\n    function delegate(uint256 delegator, uint256 delegatee) external;\\n\\n    /**\\n     * @dev Delegates votes from `delegator` to `delegatee`. Signer must own `delegator`.\\n     */\\n    function delegateBySig(\\n        uint256 delegator,\\n        uint256 delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\",\"keccak256\":\"0x9d443ede6b412305137804890806312f30351178fd3781b3a9417bfd3eea558c\",\"license\":\"MIT\"},\"contracts/interfaces/IVotingEscrow.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\nimport {IERC165, IERC721, IERC721Metadata} from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\nimport {IERC6372} from \\\"@openzeppelin/contracts/interfaces/IERC6372.sol\\\";\\nimport {IERC4906} from \\\"@openzeppelin/contracts/interfaces/IERC4906.sol\\\";\\nimport {IVotes} from \\\"../governance/IVotes.sol\\\";\\n\\ninterface IVotingEscrow is IVotes, IERC4906, IERC6372, IERC721Metadata {\\n    struct LockedBalance {\\n        int128 amount;\\n        uint256 end;\\n        bool isPermanent;\\n    }\\n\\n    struct UserPoint {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint256 ts;\\n        uint256 blk; // block\\n        uint256 permanent;\\n    }\\n\\n    struct GlobalPoint {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint256 ts;\\n        uint256 blk; // block\\n        uint256 permanentLockBalance;\\n    }\\n\\n    /// @notice A checkpoint for recorded delegated voting weights at a certain timestamp\\n    struct Checkpoint {\\n        uint256 fromTimestamp;\\n        address owner;\\n        uint256 delegatedBalance;\\n        uint256 delegatee;\\n    }\\n\\n    enum DepositType {\\n        DEPOSIT_FOR_TYPE,\\n        CREATE_LOCK_TYPE,\\n        INCREASE_LOCK_AMOUNT,\\n        INCREASE_UNLOCK_TIME\\n    }\\n\\n    /// @dev Different types of veNFTs:\\n    /// NORMAL  - typical veNFT\\n    /// LOCKED  - veNFT which is locked into a MANAGED veNFT\\n    /// MANAGED - veNFT which can accept the deposit of NORMAL veNFTs\\n    enum EscrowType {\\n        NORMAL,\\n        LOCKED,\\n        MANAGED\\n    }\\n\\n    error AlreadyVoted();\\n    error AmountTooBig();\\n    error ERC721ReceiverRejectedTokens();\\n    error ERC721TransferToNonERC721ReceiverImplementer();\\n    error InvalidNonce();\\n    error InvalidSignature();\\n    error InvalidSignatureS();\\n    error InvalidManagedNFTId();\\n    error LockDurationNotInFuture();\\n    error LockDurationTooLong();\\n    error LockExpired();\\n    error LockNotExpired();\\n    error NoLockFound();\\n    error NonExistentToken();\\n    error NotApprovedOrOwner();\\n    error NotDistributor();\\n    error NotEmergencyCouncilOrGovernor();\\n    error NotGovernor();\\n    error NotGovernorOrManager();\\n    error NotManagedNFT();\\n    error NotManagedOrNormalNFT();\\n    error NotLockedNFT();\\n    error NotNormalNFT();\\n    error NotPermanentLock();\\n    error NotOwner();\\n    error NotTeam();\\n    error NotVoter();\\n    error OwnershipChange();\\n    error PermanentLock();\\n    error SameAddress();\\n    error SameNFT();\\n    error SameState();\\n    error SplitNoOwner();\\n    error SplitNotAllowed();\\n    error SignatureExpired();\\n    error TooManyTokenIDs();\\n    error ZeroAddress();\\n    error ZeroAmount();\\n    error ZeroBalance();\\n    error NotGrantManager();\\n    error UnvestedGrantNFT();\\n\\n    event Deposit(\\n        address indexed provider,\\n        uint256 indexed tokenId,\\n        DepositType indexed depositType,\\n        uint256 value,\\n        uint256 locktime,\\n        uint256 ts\\n    );\\n    event Withdraw(\\n        address indexed provider,\\n        uint256 indexed tokenId,\\n        uint256 value,\\n        uint256 ts\\n    );\\n    event LockPermanent(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 amount,\\n        uint256 _ts\\n    );\\n    event UnlockPermanent(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 amount,\\n        uint256 _ts\\n    );\\n    event Supply(uint256 prevSupply, uint256 supply);\\n    event Merge(\\n        address indexed _sender,\\n        uint256 indexed _from,\\n        uint256 indexed _to,\\n        uint256 _amountFrom,\\n        uint256 _amountTo,\\n        uint256 _amountFinal,\\n        uint256 _locktime,\\n        uint256 _ts\\n    );\\n    event Split(\\n        uint256 indexed _from,\\n        uint256 indexed _tokenId1,\\n        uint256 indexed _tokenId2,\\n        address _sender,\\n        uint256 _splitAmount1,\\n        uint256 _splitAmount2,\\n        uint256 _locktime,\\n        uint256 _ts\\n    );\\n    event CreateManaged(\\n        address indexed _to,\\n        uint256 indexed _mTokenId,\\n        address indexed _from,\\n        address _lockedManagedReward,\\n        address _freeManagedReward\\n    );\\n    event DepositManaged(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 indexed _mTokenId,\\n        uint256 _weight,\\n        uint256 _ts\\n    );\\n    event WithdrawManaged(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 indexed _mTokenId,\\n        uint256 _weight,\\n        uint256 _ts\\n    );\\n    event SetAllowedManager(address indexed _allowedManager);\\n    event CreateGrant(\\n        uint256 indexed _tokenId,\\n        address _grantee,\\n        address _grantManager,\\n        uint256 _vestingEnd\\n    );\\n    event SetGrantManager(address indexed _grantManager);\\n\\n    // State variables\\n    /// @notice Address of Meta-tx Forwarder\\n    function forwarder() external view returns (address);\\n\\n    /// @notice Address of FactoryRegistry.sol\\n    function factoryRegistry() external view returns (address);\\n\\n    /// @notice Address of token used to create a veNFT\\n    function token() external view returns (address);\\n\\n    /// @notice Address of RewardsDistributor.sol\\n    function distributor() external view returns (address);\\n\\n    /// @notice Address of Voter.sol\\n    function voter() external view returns (address);\\n\\n    /// @notice Address of Protocol Team multisig\\n    function team() external view returns (address);\\n\\n    /// @dev address which can create managed NFTs\\n    function allowedManager() external view returns (address);\\n\\n    /// @dev Current count of token\\n    function tokenId() external view returns (uint256);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            MANAGED NFT STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Mapping of token id to escrow type\\n    ///      Takes advantage of the fact default value is EscrowType.NORMAL\\n    function escrowType(uint256 tokenId) external view returns (EscrowType);\\n\\n    /// @dev Mapping of token id to managed id\\n    function idToManaged(\\n        uint256 tokenId\\n    ) external view returns (uint256 managedTokenId);\\n\\n    /// @dev Mapping of user token id to managed token id to weight of token id\\n    function weights(\\n        uint256 tokenId,\\n        uint256 managedTokenId\\n    ) external view returns (uint256 weight);\\n\\n    /// @dev Mapping of managed id to deactivated state\\n    function deactivated(uint256 tokenId) external view returns (bool inactive);\\n\\n    /// @dev Mapping from managed nft id to locked managed rewards\\n    ///      `token` denominated rewards (rebases/rewards) stored in locked managed rewards contract\\n    ///      to prevent co-mingling of assets\\n    function managedToLocked(uint256 tokenId) external view returns (address);\\n\\n    /// @dev Mapping from managed nft id to free managed rewards contract\\n    ///      these rewards can be freely withdrawn by users\\n    function managedToFree(uint256 tokenId) external view returns (address);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            MANAGED NFT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Create managed NFT (a permanent lock) for use within ecosystem.\\n    /// @dev Throws if address already owns a managed NFT.\\n    /// @return _mTokenId managed token id.\\n    function createManagedLockFor(\\n        address _to\\n    ) external returns (uint256 _mTokenId);\\n\\n    /// @notice Delegates balance to managed nft\\n    ///         Note that NFTs deposited into a managed NFT will be re-locked\\n    ///         to the maximum lock time on withdrawal.\\n    ///         Permanent locks that are deposited will automatically unlock.\\n    /// @dev Managed nft will remain max-locked as long as there is at least one\\n    ///      deposit or withdrawal per week.\\n    ///      Throws if deposit nft is managed.\\n    ///      Throws if recipient nft is not managed.\\n    ///      Throws if deposit nft is already locked.\\n    ///      Throws if not called by voter.\\n    /// @param _tokenId tokenId of NFT being deposited\\n    /// @param _mTokenId tokenId of managed NFT that will receive the deposit\\n    function depositManaged(uint256 _tokenId, uint256 _mTokenId) external;\\n\\n    /// @notice Retrieves locked rewards and withdraws balance from managed nft.\\n    ///         Note that the NFT withdrawn is re-locked to the maximum lock time.\\n    /// @dev Throws if NFT not locked.\\n    ///      Throws if not called by voter.\\n    /// @param _tokenId tokenId of NFT being deposited.\\n    function withdrawManaged(uint256 _tokenId) external;\\n\\n    /// @notice Permit one address to call createManagedLockFor() that is not Voter.governor()\\n    function setAllowedManager(address _allowedManager) external;\\n\\n    /// @notice Set Managed NFT state. Inactive NFTs cannot be deposited into.\\n    /// @param _mTokenId managed nft state to set\\n    /// @param _state true => inactive, false => active\\n    function setManagedState(uint256 _mTokenId, bool _state) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function version() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function setTeam(address _team) external;\\n\\n    /// @inheritdoc IERC721Metadata\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Mapping from owner address to mapping of index to tokenId\\n    function ownerToNFTokenIdList(\\n        address _owner,\\n        uint256 _index\\n    ) external view returns (uint256 _tokenId);\\n\\n    /// @inheritdoc IERC721\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /// @inheritdoc IERC721\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC721\\n    function getApproved(\\n        uint256 _tokenId\\n    ) external view returns (address operator);\\n\\n    /// @inheritdoc IERC721\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n\\n    /// @notice Check whether spender is owner or an approved user for a given veNFT\\n    /// @param _spender .\\n    /// @param _tokenId .\\n    function isApprovedOrOwner(\\n        address _spender,\\n        uint256 _tokenId\\n    ) external returns (bool);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC721\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /// @inheritdoc IERC721\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /// @inheritdoc IERC721\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /// @inheritdoc IERC721\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /// @inheritdoc IERC721\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(\\n        bytes4 _interfaceID\\n    ) external view returns (bool);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ESCROW STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Total count of epochs witnessed since contract creation\\n    function epoch() external view returns (uint256);\\n\\n    /// @notice Total amount of token() deposited\\n    function supply() external view returns (uint256);\\n\\n    /// @notice Aggregate permanent locked balances\\n    function permanentLockBalance() external view returns (uint256);\\n\\n    function userPointEpoch(\\n        uint256 _tokenId\\n    ) external view returns (uint256 _epoch);\\n\\n    /// @notice time -> signed slope change\\n    function slopeChanges(uint256 _timestamp) external view returns (int128);\\n\\n    /// @notice account -> can split\\n    function canSplit(address _account) external view returns (bool);\\n\\n    /// @notice Global point history at a given index\\n    function pointHistory(\\n        uint256 _loc\\n    ) external view returns (GlobalPoint memory);\\n\\n    /// @notice Get the LockedBalance (amount, end) of a _tokenId\\n    /// @param _tokenId .\\n    /// @return LockedBalance of _tokenId\\n    function locked(\\n        uint256 _tokenId\\n    ) external view returns (LockedBalance memory);\\n\\n    /// @notice User -> UserPoint[userEpoch]\\n    function userPointHistory(\\n        uint256 _tokenId,\\n        uint256 _loc\\n    ) external view returns (UserPoint memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ESCROW LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Record global data to checkpoint\\n    function checkpoint() external;\\n\\n    /// @notice Deposit `_value` tokens for `_tokenId` and add to the lock\\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\\n    ///      cannot extend their locktime and deposit for a brand new user\\n    /// @param _tokenId lock NFT\\n    /// @param _value Amount to add to user's lock\\n    function depositFor(uint256 _tokenId, uint256 _value) external;\\n\\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lockDuration`\\n    /// @param _value Amount to deposit\\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\\n    /// @return TokenId of created veNFT\\n    function createLock(\\n        uint256 _value,\\n        uint256 _lockDuration\\n    ) external returns (uint256);\\n\\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lockDuration`\\n    /// @param _value Amount to deposit\\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\\n    /// @param _to Address to deposit\\n    /// @return TokenId of created veNFT\\n    function createLockFor(\\n        uint256 _value,\\n        uint256 _lockDuration,\\n        address _to\\n    ) external returns (uint256);\\n\\n    /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\\n    /// @param _value Amount of tokens to deposit and add to the lock\\n    function increaseAmount(uint256 _tokenId, uint256 _value) external;\\n\\n    /// @notice Extend the unlock time for `_tokenId`\\n    ///         Cannot extend lock time of permanent locks\\n    /// @param _lockDuration New number of seconds until tokens unlock\\n    function increaseUnlockTime(\\n        uint256 _tokenId,\\n        uint256 _lockDuration\\n    ) external;\\n\\n    /// @notice Withdraw all tokens for `_tokenId`\\n    /// @dev Only possible if the lock is both expired and not permanent\\n    ///      This will burn the veNFT. Any rebases or rewards that are unclaimed\\n    ///      will no longer be claimable. Claim all rebases and rewards prior to calling this.\\n    function withdraw(uint256 _tokenId) external;\\n\\n    /// @notice Merges `_from` into `_to`.\\n    /// @dev Cannot merge `_from` locks that are permanent or have already voted this epoch.\\n    ///      Cannot merge `_to` locks that have already expired.\\n    ///      Cannot merge if either `_from` or `_to` is veNFT created for\\n    ///      a grant that has not fully vested yet.\\n    ///      This will burn the veNFT. Any rebases or rewards that are unclaimed\\n    ///      will no longer be claimable. Claim all rebases and rewards prior to calling this.\\n    /// @param _from VeNFT to merge from.\\n    /// @param _to VeNFT to merge into.\\n    function merge(uint256 _from, uint256 _to) external;\\n\\n    /// @notice Splits veNFT into two new veNFTS - one with oldLocked.amount - `_amount`, and the second with `_amount`\\n    /// @dev    This burns the tokenId of the target veNFT\\n    ///         Callable by approved or owner\\n    ///         If this is called by approved, approved will not have permissions to manipulate the newly created veNFTs\\n    ///         Returns the two new split veNFTs to owner\\n    ///         If `from` is permanent, will automatically dedelegate.\\n    ///         This will burn the veNFT. Any rebases or rewards that are unclaimed\\n    ///         will no longer be claimable. Claim all rebases and rewards prior to calling this.\\n    /// @param _from VeNFT to split.\\n    /// @param _amount Amount to split from veNFT.\\n    /// @return _tokenId1 Return tokenId of veNFT with oldLocked.amount - `_amount`.\\n    /// @return _tokenId2 Return tokenId of veNFT with `_amount`.\\n    function split(\\n        uint256 _from,\\n        uint256 _amount\\n    ) external returns (uint256 _tokenId1, uint256 _tokenId2);\\n\\n    /// @notice Toggle split for a specific address.\\n    /// @dev Toggle split for address(0) to enable or disable for all.\\n    /// @param _account Address to toggle split permissions\\n    /// @param _bool True to allow, false to disallow\\n    function toggleSplit(address _account, bool _bool) external;\\n\\n    /// @notice Permanently lock a veNFT. Voting power will be equal to\\n    ///         `LockedBalance.amount` with no decay. Required to delegate.\\n    /// @dev Only callable by unlocked normal veNFTs.\\n    /// @param _tokenId tokenId to lock.\\n    function lockPermanent(uint256 _tokenId) external;\\n\\n    /// @notice Unlock a permanently locked veNFT. Voting power will decay.\\n    ///         Will automatically dedelegate if delegated.\\n    /// @dev Only callable by permanently locked veNFTs.\\n    ///      Cannot unlock if already voted this epoch.\\n    /// @param _tokenId tokenId to unlock.\\n    function unlockPermanent(uint256 _tokenId) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           GAUGE VOTING STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Get the voting power for _tokenId at the current timestamp\\n    /// @dev Returns 0 if called in the same block as a transfer.\\n    /// @param _tokenId .\\n    /// @return Voting power\\n    function balanceOfNFT(uint256 _tokenId) external view returns (uint256);\\n\\n    /// @notice Get the voting power for _tokenId at a given timestamp\\n    /// @param _tokenId .\\n    /// @param _t Timestamp to query voting power\\n    /// @return Voting power\\n    function balanceOfNFTAt(\\n        uint256 _tokenId,\\n        uint256 _t\\n    ) external view returns (uint256);\\n\\n    /// @notice Calculate total voting power at current timestamp\\n    /// @return Total voting power at current timestamp\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Calculate total voting power at a given timestamp\\n    /// @param _t Timestamp to query total voting power\\n    /// @return Total voting power at given timestamp\\n    function totalSupplyAt(uint256 _t) external view returns (uint256);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            GAUGE VOTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice See if a queried _tokenId has actively voted\\n    /// @param _tokenId .\\n    /// @return True if voted, else false\\n    function voted(uint256 _tokenId) external view returns (bool);\\n\\n    /// @notice Set the global state voter and distributor\\n    /// @dev This is only called once, at setup\\n    function setVoterAndDistributor(\\n        address _voter,\\n        address _distributor\\n    ) external;\\n\\n    /// @notice Set `voted` for _tokenId to true or false\\n    /// @dev Only callable by voter\\n    /// @param _tokenId .\\n    /// @param _voted .\\n    function voting(uint256 _tokenId, bool _voted) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            DAO VOTING STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The number of checkpoints for each tokenId\\n    function numCheckpoints(uint256 tokenId) external view returns (uint48);\\n\\n    /// @notice A record of states for signing / validating signatures\\n    function nonces(address account) external view returns (uint256);\\n\\n    /// @inheritdoc IVotes\\n    function delegates(uint256 delegator) external view returns (uint256);\\n\\n    /// @notice A record of delegated token checkpoints for each account, by index\\n    /// @param tokenId .\\n    /// @param index .\\n    /// @return Checkpoint\\n    function checkpoints(\\n        uint256 tokenId,\\n        uint48 index\\n    ) external view returns (Checkpoint memory);\\n\\n    /// @inheritdoc IVotes\\n    function getPastVotes(\\n        address account,\\n        uint256 tokenId,\\n        uint256 timestamp\\n    ) external view returns (uint256);\\n\\n    /// @inheritdoc IVotes\\n    function getPastTotalSupply(\\n        uint256 timestamp\\n    ) external view returns (uint256);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             DAO VOTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IVotes\\n    function delegate(uint256 delegator, uint256 delegatee) external;\\n\\n    /// @inheritdoc IVotes\\n    function delegateBySig(\\n        uint256 delegator,\\n        uint256 delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC6372 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC6372\\n    function clock() external view returns (uint48);\\n\\n    /// @inheritdoc IERC6372\\n    function CLOCK_MODE() external view returns (string memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                TOKEN GRANT\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Deposit `_value` of tokens as a grant and lock for `_vestingEnd`\\n    ///         with the provided `_grantManager`.\\n    /// @param _value Amount to deposit\\n    /// @param _grantee The grantee's address\\n    /// @param _grantManager The grant manager who can revoke the grant\\n    /// @param _vestingEnd The end of the vesting schedule. The lock will be\\n    ///        rounded down to nearest week but the original vesting end is\\n    ///        recorded in the contract.\\n    /// @return TokenId of created veNFT\\n    function createGrantLockFor(\\n        uint256 _value,\\n        address _grantee,\\n        address _grantManager,\\n        uint256 _vestingEnd\\n    ) external returns (uint256);\\n\\n    /// @notice Allows the existing grant manager to set a new grant manager\\n    ///         address.\\n    /// @param _tokenId tokenId of the veNFT\\n    /// @param _newGrantManager The new grant manager address\\n    function setGrantManager(\\n        uint256 _tokenId,\\n        address _newGrantManager\\n    ) external;\\n\\n    /// @notice Returns the grant manager address for the given veNFT\\n    /// @param _tokenId tokenId of the veNFT\\n    function grantManager(uint256 _tokenId) external view returns (address);\\n\\n    /// @notice Returns the vesting schedule end for the given veNFT.\\n    ///         Zero if the veNFT was not created as a grant.\\n    /// @param _tokenId tokenId of the veNFT\\n    function vestingEnd(uint256 _tokenId) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x12fc409f27c9e659dffeedb14c460d993d1cde4df6918f7ec26ec21bbe989845\",\"license\":\"MIT\"},\"contracts/libraries/SafeCastLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.24;\\n\\n/// @title SafeCast Library\\n/// @author velodrome.finance\\n/// @notice Safely convert unsigned and signed integers without overflow / underflow\\nlibrary SafeCastLibrary {\\n    error SafeCastOverflow();\\n    error SafeCastUnderflow();\\n\\n    /// @dev Safely convert uint256 to int128\\n    function toInt128(uint256 value) internal pure returns (int128) {\\n        if (value > uint128(type(int128).max)) revert SafeCastOverflow();\\n        return int128(uint128(value));\\n    }\\n\\n    /// @dev Safely convert int128 to uint256\\n    function toUint256(int128 value) internal pure returns (uint256) {\\n        if (value < 0) revert SafeCastUnderflow();\\n        return uint256(int256(value));\\n    }\\n}\\n\",\"keccak256\":\"0xfc419390f2423ffa802e9a3a11ee859b01fee9ffdb0fca855008d6b7d6b25bd6\",\"license\":\"BUSL-1.1\"},\"contracts/ve/Delegation.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.24;\\n\\nimport {VotingEscrowState} from \\\"./VotingEscrowState.sol\\\";\\nimport {NFT} from \\\"./NFT.sol\\\";\\nimport {VeERC2771Context} from \\\"./VeERC2771Context.sol\\\";\\nimport {SafeCastLibrary} from \\\"../libraries/SafeCastLibrary.sol\\\";\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport {IVotes} from \\\"../governance/IVotes.sol\\\";\\n\\nlibrary Delegation {\\n    using SafeCastLibrary for int128;\\n    using NFT for VotingEscrowState.Storage;\\n    using VeERC2771Context for VotingEscrowState.Storage;\\n\\n    struct SignatureData {\\n        uint256 delegator;\\n        uint256 delegatee;\\n        uint256 nonce;\\n        uint256 expiry;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH =\\n        keccak256(\\n            \\\"EIP712Domain(string name,string contractVersion,uint256 chainId,address verifyingContract)\\\"\\n        );\\n\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\\n    bytes32 public constant DELEGATION_TYPEHASH =\\n        keccak256(\\n            \\\"Delegation(uint256 delegator,uint256 delegatee,uint256 nonce,uint256 expiry)\\\"\\n        );\\n\\n    function delegate(\\n        VotingEscrowState.Storage storage self,\\n        uint256 delegator,\\n        uint256 delegatee\\n    ) external {\\n        if (!self._isApprovedOrOwner(self._msgSender(), delegator))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        return _delegate(self, delegator, delegatee);\\n    }\\n\\n    function delegateBySig(\\n        VotingEscrowState.Storage storage self,\\n        SignatureData calldata signatureData,\\n        string calldata contractName,\\n        string calldata contractVersion\\n    ) external {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (\\n            uint256(signatureData.s) >\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\\n        ) revert IVotingEscrow.InvalidSignatureS();\\n        bytes32 domainSeparator = keccak256(\\n            abi.encode(\\n                DOMAIN_TYPEHASH,\\n                keccak256(bytes(contractName)),\\n                keccak256(bytes(contractVersion)),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                DELEGATION_TYPEHASH,\\n                signatureData.delegator,\\n                signatureData.delegatee,\\n                signatureData.nonce,\\n                signatureData.expiry\\n            )\\n        );\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash)\\n        );\\n        address signatory = ecrecover(\\n            digest,\\n            signatureData.v,\\n            signatureData.r,\\n            signatureData.s\\n        );\\n        if (!self._isApprovedOrOwner(signatory, signatureData.delegator))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        if (signatory == address(0)) revert IVotingEscrow.InvalidSignature();\\n        if (signatureData.nonce != self.nonces[signatory]++)\\n            revert IVotingEscrow.InvalidNonce();\\n        if (block.timestamp > signatureData.expiry)\\n            revert IVotingEscrow.SignatureExpired();\\n        return\\n            _delegate(self, signatureData.delegator, signatureData.delegatee);\\n    }\\n\\n    /// @notice Record user delegation checkpoints. Used by voting system.\\n    /// @dev Skips delegation if already delegated to `delegatee`.\\n    function _delegate(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _delegator,\\n        uint256 _delegatee\\n    ) internal {\\n        IVotingEscrow.LockedBalance memory delegateLocked = self._locked[\\n            _delegator\\n        ];\\n        if (!delegateLocked.isPermanent)\\n            revert IVotingEscrow.NotPermanentLock();\\n        if (_delegatee != 0 && self._ownerOf(_delegatee) == address(0))\\n            revert IVotingEscrow.NonExistentToken();\\n        if (self.ownershipChange[_delegator] == block.number)\\n            revert IVotingEscrow.OwnershipChange();\\n        if (_delegatee == _delegator) _delegatee = 0;\\n        uint256 currentDelegate = self._delegates[_delegator];\\n        if (currentDelegate == _delegatee) return;\\n\\n        uint256 delegatedBalance = delegateLocked.amount.toUint256();\\n        _checkpointDelegator(\\n            self,\\n            _delegator,\\n            _delegatee,\\n            self._ownerOf(_delegator)\\n        );\\n        _checkpointDelegatee(self, _delegatee, delegatedBalance, true);\\n\\n        emit IVotes.DelegateChanged(\\n            self._msgSender(),\\n            currentDelegate,\\n            _delegatee\\n        );\\n    }\\n\\n    /// @notice Used by `_mint`, `_transferFrom`, `_burn` and `delegate`\\n    ///         to update delegator voting checkpoints.\\n    ///         Automatically dedelegates, then updates checkpoint.\\n    /// @dev This function depends on `_locked` and must be called prior to token state changes.\\n    ///      If you wish to dedelegate only, use `_delegate(tokenId, 0)` instead.\\n    /// @param _delegator The delegator to update checkpoints for\\n    /// @param _delegatee The new delegatee for the delegator. Cannot be equal to `_delegator` (use 0 instead).\\n    /// @param _owner The new (or current) owner for the delegator\\n    function _checkpointDelegator(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _delegator,\\n        uint256 _delegatee,\\n        address _owner\\n    ) internal {\\n        uint256 delegatedBalance = self._locked[_delegator].amount.toUint256();\\n        uint48 numCheckpoint = self.numCheckpoints[_delegator];\\n        IVotingEscrow.Checkpoint storage cpOld = numCheckpoint > 0\\n            ? self._checkpoints[_delegator][numCheckpoint - 1]\\n            : self._checkpoints[_delegator][0];\\n        // Dedelegate from delegatee if delegated\\n        _checkpointDelegatee(self, cpOld.delegatee, delegatedBalance, false);\\n        IVotingEscrow.Checkpoint storage cp = self._checkpoints[_delegator][\\n            numCheckpoint\\n        ];\\n        cp.fromTimestamp = block.timestamp;\\n        cp.delegatedBalance = cpOld.delegatedBalance;\\n        cp.delegatee = _delegatee;\\n        cp.owner = _owner;\\n\\n        if (_isCheckpointInNewBlock(self, _delegator)) {\\n            self.numCheckpoints[_delegator]++;\\n        } else {\\n            self._checkpoints[_delegator][numCheckpoint - 1] = cp;\\n            delete self._checkpoints[_delegator][numCheckpoint];\\n        }\\n\\n        self._delegates[_delegator] = _delegatee;\\n    }\\n\\n    /// @notice Update delegatee's `delegatedBalance` by `balance`.\\n    ///         Only updates if delegating to a new delegatee.\\n    /// @dev If used with `balance` == `_locked[_tokenId].amount`, then this is the same as\\n    ///      delegating or dedelegating from `_tokenId`\\n    ///      If used with `balance` < `_locked[_tokenId].amount`, then this is used to adjust\\n    ///      `delegatedBalance` when a user's balance is modified (e.g. `increaseAmount`, `merge` etc).\\n    ///      If `delegatee` is 0 (i.e. user is not delegating), then do nothing.\\n    /// @param _delegatee The delegatee's tokenId\\n    /// @param balance_ The delta in balance change\\n    /// @param _increase True if balance is increasing, false if decreasing\\n    function _checkpointDelegatee(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _delegatee,\\n        uint256 balance_,\\n        bool _increase\\n    ) internal {\\n        if (_delegatee == 0) return;\\n        uint48 numCheckpoint = self.numCheckpoints[_delegatee];\\n        IVotingEscrow.Checkpoint storage cpOld = numCheckpoint > 0\\n            ? self._checkpoints[_delegatee][numCheckpoint - 1]\\n            : self._checkpoints[_delegatee][0];\\n        IVotingEscrow.Checkpoint storage cp = self._checkpoints[_delegatee][\\n            numCheckpoint\\n        ];\\n        cp.fromTimestamp = block.timestamp;\\n        cp.owner = cpOld.owner;\\n        // do not expect balance_ > cpOld.delegatedBalance when decrementing but just in case\\n        cp.delegatedBalance = _increase\\n            ? cpOld.delegatedBalance + balance_\\n            : (\\n                balance_ < cpOld.delegatedBalance\\n                    ? cpOld.delegatedBalance - balance_\\n                    : 0\\n            );\\n        cp.delegatee = cpOld.delegatee;\\n\\n        if (_isCheckpointInNewBlock(self, _delegatee)) {\\n            self.numCheckpoints[_delegatee]++;\\n        } else {\\n            self._checkpoints[_delegatee][numCheckpoint - 1] = cp;\\n            delete self._checkpoints[_delegatee][numCheckpoint];\\n        }\\n    }\\n\\n    function _isCheckpointInNewBlock(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) internal view returns (bool) {\\n        uint48 _nCheckPoints = self.numCheckpoints[_tokenId];\\n\\n        if (\\n            _nCheckPoints > 0 &&\\n            self._checkpoints[_tokenId][_nCheckPoints - 1].fromTimestamp ==\\n            block.timestamp\\n        ) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /// @notice Retrieves historical voting balance for a token id at a given timestamp.\\n    /// @dev If a checkpoint does not exist prior to the timestamp, this will return 0.\\n    ///      The user must also own the token at the time in order to receive a voting balance.\\n    /// @param _account .\\n    /// @param _tokenId .\\n    /// @param _timestamp .\\n    /// @return Total voting balance including delegations at a given timestamp.\\n    function getPastVotes(\\n        VotingEscrowState.Storage storage self,\\n        address _account,\\n        uint256 _tokenId,\\n        uint256 _timestamp\\n    ) external view returns (uint256) {\\n        uint48 _checkIndex = getPastVotesIndex(self, _tokenId, _timestamp);\\n        IVotingEscrow.Checkpoint memory lastCheckpoint = self._checkpoints[\\n            _tokenId\\n        ][_checkIndex];\\n        // If no point exists prior to the given timestamp, return 0\\n        if (lastCheckpoint.fromTimestamp > _timestamp) return 0;\\n        // Check ownership\\n        if (_account != lastCheckpoint.owner) return 0;\\n        uint256 votes = lastCheckpoint.delegatedBalance;\\n        return\\n            lastCheckpoint.delegatee == 0\\n                ? votes +\\n                    IVotingEscrow(address(this)).balanceOfNFTAt(\\n                        _tokenId,\\n                        _timestamp\\n                    )\\n                : votes;\\n    }\\n\\n    /// @notice Binary search to get the voting checkpoint for a token id at or prior to a given timestamp.\\n    /// @dev If a checkpoint does not exist prior to the timestamp, this will return 0.\\n    /// @param _tokenId .\\n    /// @param _timestamp .\\n    /// @return The index of the checkpoint.\\n    function getPastVotesIndex(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        uint256 _timestamp\\n    ) internal view returns (uint48) {\\n        uint48 nCheckpoints = self.numCheckpoints[_tokenId];\\n        if (nCheckpoints == 0) return 0;\\n        // First check most recent balance\\n        if (\\n            self._checkpoints[_tokenId][nCheckpoints - 1].fromTimestamp <=\\n            _timestamp\\n        ) return (nCheckpoints - 1);\\n        // Next check implicit zero balance\\n        if (self._checkpoints[_tokenId][0].fromTimestamp > _timestamp) return 0;\\n\\n        uint48 lower = 0;\\n        uint48 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint48 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            IVotingEscrow.Checkpoint storage cp = self._checkpoints[_tokenId][\\n                center\\n            ];\\n            if (cp.fromTimestamp == _timestamp) {\\n                return center;\\n            } else if (cp.fromTimestamp < _timestamp) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return lower;\\n    }\\n}\\n\",\"keccak256\":\"0xece6e6f074dfc6a50335fb384d42e01d9fa168292f8dc8e3b17e6f674953cd2f\",\"license\":\"BUSL-1.1\"},\"contracts/ve/NFT.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.24;\\n\\nimport {VotingEscrowState} from \\\"./VotingEscrowState.sol\\\";\\nimport {Delegation} from \\\"./Delegation.sol\\\";\\nimport {VeERC2771Context} from \\\"./VeERC2771Context.sol\\\";\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\n\\nlibrary NFT {\\n    using Delegation for VotingEscrowState.Storage;\\n    using VeERC2771Context for VotingEscrowState.Storage;\\n\\n    function approve(\\n        VotingEscrowState.Storage storage self,\\n        address _approved,\\n        uint256 _tokenId\\n    ) external {\\n        address sender = self._msgSender();\\n        address owner = _ownerOf(self, _tokenId);\\n        // Throws if `_tokenId` is not a valid NFT\\n        if (owner == address(0)) revert IVotingEscrow.ZeroAddress();\\n        // Throws if `_approved` is the current owner\\n        if (owner == _approved) revert IVotingEscrow.SameAddress();\\n        // Check requirements\\n        bool senderIsOwner = (_ownerOf(self, _tokenId) == sender);\\n        bool senderIsApprovedForAll = (self.ownerToOperators[owner])[sender];\\n        if (!senderIsOwner && !senderIsApprovedForAll)\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        // Set the approval\\n        self.idToApprovals[_tokenId] = _approved;\\n        emit IERC721.Approval(owner, _approved, _tokenId);\\n    }\\n\\n    function setApprovalForAll(\\n        VotingEscrowState.Storage storage self,\\n        address _operator,\\n        bool _approved\\n    ) external {\\n        address sender = self._msgSender();\\n        // Throws if `_operator` is the `msg.sender`\\n        if (_operator == sender) revert IVotingEscrow.SameAddress();\\n        self.ownerToOperators[sender][_operator] = _approved;\\n        emit IERC721.ApprovalForAll(sender, _operator, _approved);\\n    }\\n\\n    function safeTransferFrom(\\n        VotingEscrowState.Storage storage self,\\n        address _from,\\n        address _to,\\n        uint256 _tokenId,\\n        bytes memory _data\\n    ) external {\\n        address sender = self._msgSender();\\n        _transferFrom(self, _from, _to, _tokenId, sender);\\n\\n        if (_isContract(_to)) {\\n            // Throws if transfer destination is a contract which does not implement 'onERC721Received'\\n            try\\n                IERC721Receiver(_to).onERC721Received(\\n                    sender,\\n                    _from,\\n                    _tokenId,\\n                    _data\\n                )\\n            returns (bytes4 response) {\\n                if (\\n                    response != IERC721Receiver(_to).onERC721Received.selector\\n                ) {\\n                    revert IVotingEscrow.ERC721ReceiverRejectedTokens();\\n                }\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert IVotingEscrow\\n                        .ERC721TransferToNonERC721ReceiverImplementer();\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function _transferFrom(\\n        VotingEscrowState.Storage storage self,\\n        address _from,\\n        address _to,\\n        uint256 _tokenId,\\n        address _sender\\n    ) internal {\\n        if (self.escrowType[_tokenId] == IVotingEscrow.EscrowType.LOCKED)\\n            revert IVotingEscrow.NotManagedOrNormalNFT();\\n        // Check requirements\\n        if (!_isApprovedOrOwner(self, _sender, _tokenId))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        // Clear approval. Throws if `_from` is not the current owner\\n        if (_ownerOf(self, _tokenId) != _from) revert IVotingEscrow.NotOwner();\\n        delete self.idToApprovals[_tokenId];\\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\\n        _removeTokenFrom(self, _from, _tokenId);\\n        // Update voting checkpoints\\n        self._checkpointDelegator(_tokenId, 0, _to);\\n        // Add NFT\\n        _addTokenTo(self, _to, _tokenId);\\n        // Set the block of ownership transfer (for Flash NFT protection)\\n        self.ownershipChange[_tokenId] = block.number;\\n        // Log the transfer\\n        emit IERC721.Transfer(_from, _to, _tokenId);\\n    }\\n\\n    function _isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /// @dev Add a NFT to a given address\\n    ///      Throws if `_tokenId` is owned by someone.\\n    function _addTokenTo(\\n        VotingEscrowState.Storage storage self,\\n        address _to,\\n        uint256 _tokenId\\n    ) internal {\\n        // Throws if `_tokenId` is owned by someone\\n        assert(_ownerOf(self, _tokenId) == address(0));\\n        // Change the owner\\n        self.idToOwner[_tokenId] = _to;\\n        // Update owner token index tracking\\n        _addTokenToOwnerList(self, _to, _tokenId);\\n        // Change count tracking\\n        self.ownerToNFTokenCount[_to] += 1;\\n    }\\n\\n    /// @dev Function to mint tokens\\n    ///      Throws if `_to` is zero address.\\n    ///      Throws if `_tokenId` is owned by someone.\\n    /// @param _to The address that will receive the minted tokens.\\n    /// @param _tokenId The token id to mint.\\n    /// @return A boolean that indicates if the operation was successful.\\n    function _mint(\\n        VotingEscrowState.Storage storage self,\\n        address _to,\\n        uint256 _tokenId\\n    ) internal returns (bool) {\\n        // Throws if `_to` is zero address\\n        assert(_to != address(0));\\n        // Add NFT. Throws if `_tokenId` is owned by someone\\n        _addTokenTo(self, _to, _tokenId);\\n        // Update voting checkpoints\\n        self._checkpointDelegator(_tokenId, 0, _to);\\n        emit IERC721.Transfer(address(0), _to, _tokenId);\\n        return true;\\n    }\\n\\n    /// @dev Add a NFT to an index mapping to a given address\\n    /// @param _to address of the receiver\\n    /// @param _tokenId uint ID Of the token to be added\\n    function _addTokenToOwnerList(\\n        VotingEscrowState.Storage storage self,\\n        address _to,\\n        uint256 _tokenId\\n    ) internal {\\n        uint256 currentCount = self.ownerToNFTokenCount[_to];\\n\\n        self.ownerToNFTokenIdList[_to][currentCount] = _tokenId;\\n        self.tokenToOwnerIndex[_tokenId] = currentCount;\\n    }\\n\\n    function _ownerOf(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) internal view returns (address) {\\n        return self.idToOwner[_tokenId];\\n    }\\n\\n    function _isApprovedOrOwner(\\n        VotingEscrowState.Storage storage self,\\n        address _spender,\\n        uint256 _tokenId\\n    ) internal view returns (bool) {\\n        address owner = _ownerOf(self, _tokenId);\\n        bool spenderIsOwner = owner == _spender;\\n        bool spenderIsApproved = _spender == self.idToApprovals[_tokenId];\\n        bool spenderIsApprovedForAll = (self.ownerToOperators[owner])[_spender];\\n        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\\n    }\\n\\n    /// @dev Must be called prior to updating `LockedBalance`\\n    function _burn(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) internal {\\n        address sender = self._msgSender();\\n        if (!_isApprovedOrOwner(self, sender, _tokenId))\\n            revert IVotingEscrow.NotApprovedOrOwner();\\n        address owner = _ownerOf(self, _tokenId);\\n\\n        // Clear approval\\n        delete self.idToApprovals[_tokenId];\\n        // Update voting checkpoints\\n        self._checkpointDelegator(_tokenId, 0, address(0));\\n        // Remove token\\n        _removeTokenFrom(self, owner, _tokenId);\\n        emit IERC721.Transfer(owner, address(0), _tokenId);\\n    }\\n\\n    /// @dev Remove a NFT from a given address\\n    ///      Throws if `_from` is not the current owner.\\n    function _removeTokenFrom(\\n        VotingEscrowState.Storage storage self,\\n        address _from,\\n        uint256 _tokenId\\n    ) internal {\\n        // Throws if `_from` is not the current owner\\n        assert(_ownerOf(self, _tokenId) == _from);\\n        // Change the owner\\n        self.idToOwner[_tokenId] = address(0);\\n        // Update owner token index tracking\\n        _removeTokenFromOwnerList(self, _from, _tokenId);\\n        // Change count tracking\\n        self.ownerToNFTokenCount[_from] -= 1;\\n    }\\n\\n    /// @dev Remove a NFT from an index mapping to a given address\\n    /// @param _from address of the sender\\n    /// @param _tokenId uint ID Of the token to be removed\\n    function _removeTokenFromOwnerList(\\n        VotingEscrowState.Storage storage self,\\n        address _from,\\n        uint256 _tokenId\\n    ) internal {\\n        // Delete\\n        uint256 currentCount = self.ownerToNFTokenCount[_from] - 1;\\n        uint256 currentIndex = self.tokenToOwnerIndex[_tokenId];\\n\\n        if (currentCount == currentIndex) {\\n            // update ownerToNFTokenIdList\\n            self.ownerToNFTokenIdList[_from][currentCount] = 0;\\n            // update tokenToOwnerIndex\\n            self.tokenToOwnerIndex[_tokenId] = 0;\\n        } else {\\n            uint256 lastTokenId = self.ownerToNFTokenIdList[_from][\\n                currentCount\\n            ];\\n\\n            // Add\\n            // update ownerToNFTokenIdList\\n            self.ownerToNFTokenIdList[_from][currentIndex] = lastTokenId;\\n            // update tokenToOwnerIndex\\n            self.tokenToOwnerIndex[lastTokenId] = currentIndex;\\n\\n            // Delete\\n            // update ownerToNFTokenIdList\\n            self.ownerToNFTokenIdList[_from][currentCount] = 0;\\n            // update tokenToOwnerIndex\\n            self.tokenToOwnerIndex[_tokenId] = 0;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe28957bd70a2e83028e318ce7ad7899c28ab7d5acd3f711f322fe2da6a083137\",\"license\":\"BUSL-1.1\"},\"contracts/ve/VeERC2771Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Based on openzeppelin-contracts/contracts/metatx/ERC2771Context.sol\\n\\npragma solidity 0.8.24;\\n\\nimport {VotingEscrowState} from \\\"./VotingEscrowState.sol\\\";\\n\\n/**\\n * @dev Context variant with ERC2771 support. Extracted to library to allow\\n *      easy application inside libraries.\\n */\\nlibrary VeERC2771Context {\\n    function isTrustedForwarder(\\n        VotingEscrowState.Storage storage self,\\n        address forwarder\\n    ) internal view returns (bool) {\\n        return forwarder == self.trustedForwarder;\\n    }\\n\\n    function _msgSender(\\n        VotingEscrowState.Storage storage self\\n    ) internal view returns (address sender) {\\n        if (msg.data.length >= 20 && isTrustedForwarder(self, msg.sender)) {\\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n        } else {\\n            return msg.sender;\\n        }\\n    }\\n\\n    function _msgData(\\n        VotingEscrowState.Storage storage self\\n    ) internal view returns (bytes calldata) {\\n        if (isTrustedForwarder(self, msg.sender)) {\\n            return msg.data[:msg.data.length - 20];\\n        } else {\\n            return msg.data;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbcd5157897425f73b6819441db0b1a58383c6e92d452d269f5987b63235aeba5\",\"license\":\"MIT\"},\"contracts/ve/VotingEscrowState.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.24;\\n\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport {VeERC2771Context} from \\\"./VeERC2771Context.sol\\\";\\nimport {IERC4906} from \\\"@openzeppelin/contracts/interfaces/IERC4906.sol\\\";\\n\\nlibrary VotingEscrowState {\\n    using VeERC2771Context for Storage;\\n\\n    struct Storage {\\n        /// @dev Address of Meta-tx Forwarder\\n        address trustedForwarder;\\n        /// @dev Address of FactoryRegistry.sol\\n        address factoryRegistry;\\n        /// @dev Address of token used to create a veNFT\\n        address token;\\n        /// @dev Address of RewardsDistributor.sol\\n        address distributor;\\n        /// @dev Address of Voter.sol\\n        address voter;\\n        /// @dev Address of Protocol Team multisig\\n        address team;\\n        /// @dev Address which can create managed NFTs\\n        address allowedManager;\\n        /// @dev Global point history at a given index (epoch -> unsigned global point)\\n        mapping(uint256 => IVotingEscrow.GlobalPoint) _pointHistory;\\n        /// @dev Mapping of interface id to bool about whether or not it's supported\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        /// @dev Current count of token\\n        uint256 tokenId;\\n        /*///////////////////////////////////////////////////////////////\\n                                MANAGED NFT\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Mapping of token id to escrow type\\n        ///      Takes advantage of the fact default value is EscrowType.NORMAL\\n        mapping(uint256 => IVotingEscrow.EscrowType) escrowType;\\n        /// @dev Mapping of token id to managed id\\n        mapping(uint256 => uint256) idToManaged;\\n        /// @dev Mapping of user token id to managed token id to weight of token id\\n        mapping(uint256 => mapping(uint256 => uint256)) weights;\\n        /// @dev Mapping of managed id to deactivated state\\n        mapping(uint256 => bool) deactivated;\\n        /// @dev Mapping from managed nft id to locked managed rewards\\n        ///      `token` denominated rewards (rebases/rewards) stored in locked\\n        ///      managed rewards contract to prevent co-mingling of assets\\n        mapping(uint256 => address) managedToLocked;\\n        /// @dev Mapping from managed nft id to free managed rewards contract\\n        ///      these rewards can be freely withdrawn by users\\n        mapping(uint256 => address) managedToFree;\\n        /*//////////////////////////////////////////////////////////////\\n                            ERC721 BALANCE/OWNER\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Mapping from NFT ID to the address that owns it.\\n        mapping(uint256 => address) idToOwner;\\n        /// @dev Mapping from owner address to count of his tokens.\\n        mapping(address => uint256) ownerToNFTokenCount;\\n        /*//////////////////////////////////////////////////////////////\\n                                ERC721 APPROVAL\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Mapping from NFT ID to approved address.\\n        mapping(uint256 => address) idToApprovals;\\n        /// @dev Mapping from owner address to mapping of operator addresses.\\n        mapping(address => mapping(address => bool)) ownerToOperators;\\n        mapping(uint256 => uint256) ownershipChange;\\n        /*//////////////////////////////////////////////////////////////\\n                            INTERNAL MINT/BURN\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Mapping from owner address to mapping of index to tokenId\\n        mapping(address => mapping(uint256 => uint256)) ownerToNFTokenIdList;\\n        /// @dev Mapping from NFT ID to index of owner\\n        mapping(uint256 => uint256) tokenToOwnerIndex;\\n        /*//////////////////////////////////////////////////////////////\\n                                    ESCROW\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Total count of epochs witnessed since contract creation\\n        uint256 epoch;\\n        /// @dev Total amount of token() deposited\\n        uint256 supply;\\n        mapping(uint256 => IVotingEscrow.LockedBalance) _locked;\\n        mapping(uint256 => IVotingEscrow.UserPoint[1000000000]) _userPointHistory;\\n        mapping(uint256 => uint256) userPointEpoch;\\n        /// @dev time -> signed slope change\\n        mapping(uint256 => int128) slopeChanges;\\n        /// @dev account -> can split\\n        mapping(address => bool) canSplit;\\n        /// @dev Aggregate permanent locked balances\\n        uint256 permanentLockBalance;\\n        /// @dev Maximum lock time of the veNFT in seconds.\\n        ///      This value SHOULD NOT be changed after deployment\\n        ///      as it affects the voting power of all existing veNFTs.\\n        ///      It is defined here and not as constant because\\n        ///      different veNFT implementations have different\\n        ///      max lock times.\\n        uint256 maxLockTime;\\n        /*///////////////////////////////////////////////////////////////\\n                                    DAO VOTING\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev A record of each accounts delegate\\n        mapping(uint256 => uint256) _delegates;\\n        /// @dev A record of delegated token checkpoints for each tokenId, by index\\n        mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint)) _checkpoints;\\n        /// @dev The number of checkpoints for each tokenId\\n        mapping(uint256 => uint48) numCheckpoints;\\n        /// @dev A record of states for signing / validating signatures\\n        mapping(address => uint256) nonces;\\n        /*///////////////////////////////////////////////////////////////\\n                                GAUGE VOTING\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Information on whether a tokenId has already voted\\n        mapping(uint256 => bool) voted;\\n        /*///////////////////////////////////////////////////////////////\\n                                TOKEN GRANT\\n        //////////////////////////////////////////////////////////////*/\\n        /// @dev Mapping from tokenId to grant manager. The grant manager can\\n        ///      revoke a grant converted to veNFT.\\n        mapping(uint256 => address) grantManager;\\n        /// @dev Mapping from tokenId to the end date of the grant vesting\\n        ///      schedule. The end date is a UNIX timestamp.\\n        mapping(uint256 => uint256) vestingEnd;\\n        // Reserved storage space in case we need to add more variables.\\n        // The convention from OpenZeppelin suggests the storage space should\\n        // add up to 50 slots. Here we want to have more slots as there are\\n        // planned upgrades of the VotingEscrow contract. If more entires are\\n        // added to the struct in the upcoming versions we need to reduce\\n        // the array size.\\n        // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n        uint256[50] __gap;\\n    }\\n\\n    function setTeam(\\n        VotingEscrowState.Storage storage self,\\n        address _team\\n    ) internal {\\n        if (self._msgSender() != self.team) revert IVotingEscrow.NotTeam();\\n        if (_team == address(0)) revert IVotingEscrow.ZeroAddress();\\n        self.team = _team;\\n    }\\n\\n    function setVoterAndDistributor(\\n        VotingEscrowState.Storage storage self,\\n        address _voter,\\n        address _distributor\\n    ) internal {\\n        if (self._msgSender() != self.voter) revert IVotingEscrow.NotVoter();\\n        self.voter = _voter;\\n        self.distributor = _distributor;\\n    }\\n\\n    function setVoting(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        bool _voted\\n    ) internal {\\n        if (self._msgSender() != self.voter) revert IVotingEscrow.NotVoter();\\n        self.voted[_tokenId] = _voted;\\n    }\\n}\\n\",\"keccak256\":\"0xaf461d9f918f782e27fcd41ad3b047e7e9cb21286bfbb2fa5a9e6886bb8e8cbf\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x61102a61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061004b5760003560e01c8063242177a014610050578063d26c172c14610072578063ef33256014610092575b600080fd5b81801561005c57600080fd5b5061007061006b366004610d2f565b6100b2565b005b81801561007e57600080fd5b5061007061008d366004610d8a565b610161565b81801561009e57600080fd5b506100706100ad366004610e70565b610287565b60006100bd846103d0565b9050806001600160a01b0316836001600160a01b0316036100f15760405163367558c360e01b815260040160405180910390fd5b6001600160a01b038181166000818152601387016020908152604080832094881680845294825291829020805460ff191687151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a350505050565b600061016c866103d0565b905061017b868686868561040b565b833b1561027f57604051630a85bd0160e11b81526001600160a01b0385169063150b7a02906101b4908490899088908890600401610ea5565b6020604051808303816000875af19250505080156101ef575060408051601f3d908101601f191682019092526101ec91810190610f17565b60015b61024c573d80801561021d576040519150601f19603f3d011682016040523d82523d6000602084013e610222565b606091505b50805160000361024457604051626b5e2960e61b815260040160405180910390fd5b805181602001fd5b6001600160e01b03198116630a85bd0160e11b1461027d5760405163279929b160e21b815260040160405180910390fd5b505b505050505050565b6000610292846103d0565b905060006102a08584610545565b90506001600160a01b0381166102c95760405163d92e233d60e01b815260040160405180910390fd5b836001600160a01b0316816001600160a01b0316036102fb5760405163367558c360e01b815260040160405180910390fd5b6000826001600160a01b03166103118786610545565b6001600160a01b03848116600090815260138a01602090815260408083208985168452909152902054911691909114915060ff16811582610350575080155b1561036e5760405163390cdd9b60e21b815260040160405180910390fd5b600085815260128801602052604080822080546001600160a01b0319166001600160a01b038a811691821790925591518893918716917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92591a450505050505050565b6000601436108015906103ec575081546001600160a01b031633145b156103ff57505036601319013560601c90565b5033919050565b919050565b60016000838152600a8701602052604090205460ff16600281111561043257610432610f48565b0361045057604051635eb32db160e11b815260040160405180910390fd5b61045b858284610566565b6104785760405163390cdd9b60e21b815260040160405180910390fd5b836001600160a01b031661048c8684610545565b6001600160a01b0316146104b3576040516330cd747160e01b815260040160405180910390fd5b6000828152601286016020526040902080546001600160a01b03191690556104dc8585846105d6565b6104e9858360008661065e565b6104f48584846108dd565b60008281526014860160205260408082204390555183916001600160a01b0380871692908816917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a45050505050565b60008181526010830160205260409020546001600160a01b03165b92915050565b6000806105738584610545565b60008481526012870160209081526040808320546001600160a01b0380861680865260138c018552838620828c1680885295529290942054949550908214939216149060ff1682806105c25750815b806105ca5750805b98975050505050505050565b816001600160a01b03166105ea8483610545565b6001600160a01b03161461060057610600610f5e565b6000818152601084016020526040902080546001600160a01b0319169055610629838383610978565b6001600160a01b03821660009081526011840160205260408120805460019290610654908490610f8a565b9091555050505050565b600083815260198501602052604081205461067b90600f0b610a45565b600085815260228701602052604081205491925065ffffffffffff90911690816106bf576000868152602188016020908152604080832083805290915290206106fa565b60008681526021880160205260408120906106db600185610f9d565b65ffffffffffff1665ffffffffffff1681526020019081526020016000205b905061070d878260030154856000610a71565b6000868152602188016020908152604080832065ffffffffffff86168452909152902042815560028281015490820155600381018690556001810180546001600160a01b0319166001600160a01b03871617905561076b8888610c9d565b156107bc5760008781526022890160205260408120805465ffffffffffff169161079483610fbc565b91906101000a81548165ffffffffffff021916908365ffffffffffff160217905550506108c4565b6000878152602189016020526040812082916107d9600187610f9d565b65ffffffffffff1665ffffffffffff168152602001908152602001600020600082015481600001556001820160009054906101000a90046001600160a01b03168160010160006101000a8154816001600160a01b0302191690836001600160a01b03160217905550600282015481600201556003820154816003015590505087602101600088815260200190815260200160002060008465ffffffffffff1665ffffffffffff1681526020019081526020016000206000808201600090556001820160006101000a8154906001600160a01b0302191690556002820160009055600382016000905550505b5050506000938452505060209283019092526040902055565b60006108e98483610545565b6001600160a01b0316146108ff576108ff610f5e565b6000818152601084016020908152604080832080546001600160a01b0319166001600160a01b03871690811790915580845260118701808452828520805460158a018652848720818852865284872088905587875260168a01865293862093909355908452909152805460019290610654908490610fe1565b6001600160a01b038216600090815260118401602052604081205461099f90600190610f8a565b60008381526016860160205260409020549091508082036109f4576001600160a01b03841660009081526015860160209081526040808320858452825280832083905585835260168801909152812055610a3e565b6001600160a01b0384166000908152601586016020908152604080832085845282528083208054858552828520819055845260168901909252808320849055908290558482528120555b5050505050565b60008082600f0b1215610a6a5760405162406f5d60e21b815260040160405180910390fd5b50600f0b90565b8215610c9757600083815260228501602052604081205465ffffffffffff169081610ab657600085815260218701602090815260408083208380529091529020610af1565b6000858152602187016020526040812090610ad2600185610f9d565b65ffffffffffff1665ffffffffffff1681526020019081526020016000205b6000868152602188016020908152604080832065ffffffffffff87168452909152902042815560018083015490820180546001600160a01b0319166001600160a01b0390921691909117905590915083610b6c5781600201548510610b57576000610b7c565b848260020154610b679190610f8a565b610b7c565b848260020154610b7c9190610fe1565b600282015560038083015490820155610b958787610c9d565b15610be65760008681526022880160205260408120805465ffffffffffff1691610bbe83610fbc565b91906101000a81548165ffffffffffff021916908365ffffffffffff1602179055505061027d565b600086815260218801602052604081208291610c03600187610f9d565b65ffffffffffff9081168252602080830193909352604091820160009081208554815560018087015481830180546001600160a01b039092166001600160a01b031992831617905560028089015481850155600398890154938901939093558d845260218f0187528584209a9094168352989094529182208281559687018054909116905590850181905593019290925550505b50505050565b600081815260228301602052604081205465ffffffffffff168015801590610cf85750600083815260218501602052604081204291610cdd600185610f9d565b65ffffffffffff168152602081019190915260400160002054145b15610d07576000915050610560565b6001915050610560565b5092915050565b80356001600160a01b038116811461040657600080fd5b600080600060608486031215610d4457600080fd5b83359250610d5460208501610d18565b915060408401358015158114610d6957600080fd5b809150509250925092565b634e487b7160e01b600052604160045260246000fd5b600080600080600060a08688031215610da257600080fd5b85359450610db260208701610d18565b9350610dc060408701610d18565b925060608601359150608086013567ffffffffffffffff80821115610de457600080fd5b818801915088601f830112610df857600080fd5b813581811115610e0a57610e0a610d74565b604051601f8201601f19908116603f01168101908382118183101715610e3257610e32610d74565b816040528281528b6020848701011115610e4b57600080fd5b8260208601602083013760006020848301015280955050505050509295509295909350565b600080600060608486031215610e8557600080fd5b83359250610e9560208501610d18565b9150604084013590509250925092565b600060018060a01b03808716835260208187166020850152856040850152608060608501528451915081608085015260005b82811015610ef35785810182015185820160a001528101610ed7565b5050600060a0828501015260a0601f19601f83011684010191505095945050505050565b600060208284031215610f2957600080fd5b81516001600160e01b031981168114610f4157600080fd5b9392505050565b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b8181038181111561056057610560610f74565b65ffffffffffff828116828216039080821115610d1157610d11610f74565b600065ffffffffffff808316818103610fd757610fd7610f74565b6001019392505050565b8082018082111561056057610560610f7456fea2646970667358221220ec96d228373a23785affcb5e92ae361bea10ab4d89d92ccb2ef63f8fce93ad1564736f6c63430008180033",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361061004b5760003560e01c8063242177a014610050578063d26c172c14610072578063ef33256014610092575b600080fd5b81801561005c57600080fd5b5061007061006b366004610d2f565b6100b2565b005b81801561007e57600080fd5b5061007061008d366004610d8a565b610161565b81801561009e57600080fd5b506100706100ad366004610e70565b610287565b60006100bd846103d0565b9050806001600160a01b0316836001600160a01b0316036100f15760405163367558c360e01b815260040160405180910390fd5b6001600160a01b038181166000818152601387016020908152604080832094881680845294825291829020805460ff191687151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a350505050565b600061016c866103d0565b905061017b868686868561040b565b833b1561027f57604051630a85bd0160e11b81526001600160a01b0385169063150b7a02906101b4908490899088908890600401610ea5565b6020604051808303816000875af19250505080156101ef575060408051601f3d908101601f191682019092526101ec91810190610f17565b60015b61024c573d80801561021d576040519150601f19603f3d011682016040523d82523d6000602084013e610222565b606091505b50805160000361024457604051626b5e2960e61b815260040160405180910390fd5b805181602001fd5b6001600160e01b03198116630a85bd0160e11b1461027d5760405163279929b160e21b815260040160405180910390fd5b505b505050505050565b6000610292846103d0565b905060006102a08584610545565b90506001600160a01b0381166102c95760405163d92e233d60e01b815260040160405180910390fd5b836001600160a01b0316816001600160a01b0316036102fb5760405163367558c360e01b815260040160405180910390fd5b6000826001600160a01b03166103118786610545565b6001600160a01b03848116600090815260138a01602090815260408083208985168452909152902054911691909114915060ff16811582610350575080155b1561036e5760405163390cdd9b60e21b815260040160405180910390fd5b600085815260128801602052604080822080546001600160a01b0319166001600160a01b038a811691821790925591518893918716917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92591a450505050505050565b6000601436108015906103ec575081546001600160a01b031633145b156103ff57505036601319013560601c90565b5033919050565b919050565b60016000838152600a8701602052604090205460ff16600281111561043257610432610f48565b0361045057604051635eb32db160e11b815260040160405180910390fd5b61045b858284610566565b6104785760405163390cdd9b60e21b815260040160405180910390fd5b836001600160a01b031661048c8684610545565b6001600160a01b0316146104b3576040516330cd747160e01b815260040160405180910390fd5b6000828152601286016020526040902080546001600160a01b03191690556104dc8585846105d6565b6104e9858360008661065e565b6104f48584846108dd565b60008281526014860160205260408082204390555183916001600160a01b0380871692908816917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a45050505050565b60008181526010830160205260409020546001600160a01b03165b92915050565b6000806105738584610545565b60008481526012870160209081526040808320546001600160a01b0380861680865260138c018552838620828c1680885295529290942054949550908214939216149060ff1682806105c25750815b806105ca5750805b98975050505050505050565b816001600160a01b03166105ea8483610545565b6001600160a01b03161461060057610600610f5e565b6000818152601084016020526040902080546001600160a01b0319169055610629838383610978565b6001600160a01b03821660009081526011840160205260408120805460019290610654908490610f8a565b9091555050505050565b600083815260198501602052604081205461067b90600f0b610a45565b600085815260228701602052604081205491925065ffffffffffff90911690816106bf576000868152602188016020908152604080832083805290915290206106fa565b60008681526021880160205260408120906106db600185610f9d565b65ffffffffffff1665ffffffffffff1681526020019081526020016000205b905061070d878260030154856000610a71565b6000868152602188016020908152604080832065ffffffffffff86168452909152902042815560028281015490820155600381018690556001810180546001600160a01b0319166001600160a01b03871617905561076b8888610c9d565b156107bc5760008781526022890160205260408120805465ffffffffffff169161079483610fbc565b91906101000a81548165ffffffffffff021916908365ffffffffffff160217905550506108c4565b6000878152602189016020526040812082916107d9600187610f9d565b65ffffffffffff1665ffffffffffff168152602001908152602001600020600082015481600001556001820160009054906101000a90046001600160a01b03168160010160006101000a8154816001600160a01b0302191690836001600160a01b03160217905550600282015481600201556003820154816003015590505087602101600088815260200190815260200160002060008465ffffffffffff1665ffffffffffff1681526020019081526020016000206000808201600090556001820160006101000a8154906001600160a01b0302191690556002820160009055600382016000905550505b5050506000938452505060209283019092526040902055565b60006108e98483610545565b6001600160a01b0316146108ff576108ff610f5e565b6000818152601084016020908152604080832080546001600160a01b0319166001600160a01b03871690811790915580845260118701808452828520805460158a018652848720818852865284872088905587875260168a01865293862093909355908452909152805460019290610654908490610fe1565b6001600160a01b038216600090815260118401602052604081205461099f90600190610f8a565b60008381526016860160205260409020549091508082036109f4576001600160a01b03841660009081526015860160209081526040808320858452825280832083905585835260168801909152812055610a3e565b6001600160a01b0384166000908152601586016020908152604080832085845282528083208054858552828520819055845260168901909252808320849055908290558482528120555b5050505050565b60008082600f0b1215610a6a5760405162406f5d60e21b815260040160405180910390fd5b50600f0b90565b8215610c9757600083815260228501602052604081205465ffffffffffff169081610ab657600085815260218701602090815260408083208380529091529020610af1565b6000858152602187016020526040812090610ad2600185610f9d565b65ffffffffffff1665ffffffffffff1681526020019081526020016000205b6000868152602188016020908152604080832065ffffffffffff87168452909152902042815560018083015490820180546001600160a01b0319166001600160a01b0390921691909117905590915083610b6c5781600201548510610b57576000610b7c565b848260020154610b679190610f8a565b610b7c565b848260020154610b7c9190610fe1565b600282015560038083015490820155610b958787610c9d565b15610be65760008681526022880160205260408120805465ffffffffffff1691610bbe83610fbc565b91906101000a81548165ffffffffffff021916908365ffffffffffff1602179055505061027d565b600086815260218801602052604081208291610c03600187610f9d565b65ffffffffffff9081168252602080830193909352604091820160009081208554815560018087015481830180546001600160a01b039092166001600160a01b031992831617905560028089015481850155600398890154938901939093558d845260218f0187528584209a9094168352989094529182208281559687018054909116905590850181905593019290925550505b50505050565b600081815260228301602052604081205465ffffffffffff168015801590610cf85750600083815260218501602052604081204291610cdd600185610f9d565b65ffffffffffff168152602081019190915260400160002054145b15610d07576000915050610560565b6001915050610560565b5092915050565b80356001600160a01b038116811461040657600080fd5b600080600060608486031215610d4457600080fd5b83359250610d5460208501610d18565b915060408401358015158114610d6957600080fd5b809150509250925092565b634e487b7160e01b600052604160045260246000fd5b600080600080600060a08688031215610da257600080fd5b85359450610db260208701610d18565b9350610dc060408701610d18565b925060608601359150608086013567ffffffffffffffff80821115610de457600080fd5b818801915088601f830112610df857600080fd5b813581811115610e0a57610e0a610d74565b604051601f8201601f19908116603f01168101908382118183101715610e3257610e32610d74565b816040528281528b6020848701011115610e4b57600080fd5b8260208601602083013760006020848301015280955050505050509295509295909350565b600080600060608486031215610e8557600080fd5b83359250610e9560208501610d18565b9150604084013590509250925092565b600060018060a01b03808716835260208187166020850152856040850152608060608501528451915081608085015260005b82811015610ef35785810182015185820160a001528101610ed7565b5050600060a0828501015260a0601f19601f83011684010191505095945050505050565b600060208284031215610f2957600080fd5b81516001600160e01b031981168114610f4157600080fd5b9392505050565b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b8181038181111561056057610560610f74565b65ffffffffffff828116828216039080821115610d1157610d11610f74565b600065ffffffffffff808316818103610fd757610fd7610f74565b6001019392505050565b8082018082111561056057610560610f7456fea2646970667358221220ec96d228373a23785affcb5e92ae361bea10ab4d89d92ccb2ef63f8fce93ad1564736f6c63430008180033",
  "devdoc": {
    "events": {
      "Approval(address,address,uint256)": {
        "details": "Emitted when `owner` enables `approved` to manage the `tokenId` token."
      },
      "ApprovalForAll(address,address,bool)": {
        "details": "Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets."
      },
      "Transfer(address,address,uint256)": {
        "details": "Emitted when `tokenId` token is transferred from `from` to `to`."
      }
    },
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}