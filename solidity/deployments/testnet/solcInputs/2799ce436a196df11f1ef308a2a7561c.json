{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC4906.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4906.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\nimport \"./IERC721.sol\";\n\n/// @title EIP-721 Metadata Update Extension\ninterface IERC4906 is IERC165, IERC721 {\n    /// @dev This event emits when the metadata of a token is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFT.\n    event MetadataUpdate(uint256 _tokenId);\n\n    /// @dev This event emits when the metadata of a range of tokens is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFTs.\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC6372.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC6372 {\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() external view returns (uint48);\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n"
    },
    "@openzeppelin/contracts/metatx/ERC2771Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.9;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Context variant with ERC2771 support.\n */\nabstract contract ERC2771Context is Context {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _trustedForwarder;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address trustedForwarder) {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == _trustedForwarder;\n    }\n\n    function _msgSender() internal view virtual override returns (address sender) {\n        if (isTrustedForwarder(msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            /// @solidity memory-safe-assembly\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        if (isTrustedForwarder(msg.sender)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return super._msgData();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/cryptography/EIP712.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\n     * 0 before setting it to a non-zero value.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Checkpoints.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Checkpoints.sol)\n// This file was procedurally generated from scripts/generate/templates/Checkpoints.js.\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SafeCast.sol\";\n\n/**\n * @dev This library defines the `History` struct, for checkpointing values as they change at different points in\n * time, and later looking up past values by block number. See {Votes} as an example.\n *\n * To create a history of checkpoints define a variable type `Checkpoints.History` in your contract, and store a new\n * checkpoint for the current transaction block using the {push} function.\n *\n * _Available since v4.5._\n */\nlibrary Checkpoints {\n    struct History {\n        Checkpoint[] _checkpoints;\n    }\n\n    struct Checkpoint {\n        uint32 _blockNumber;\n        uint224 _value;\n    }\n\n    /**\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\n     * before it is returned, or zero otherwise. Because the number returned corresponds to that at the end of the\n     * block, the requested block number must be in the past, excluding the current block.\n     */\n    function getAtBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\n        require(blockNumber < block.number, \"Checkpoints: block not yet mined\");\n        uint32 key = SafeCast.toUint32(blockNumber);\n\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\n     * before it is returned, or zero otherwise. Similar to {upperLookup} but optimized for the case when the searched\n     * checkpoint is probably \"recent\", defined as being among the last sqrt(N) checkpoints where N is the number of\n     * checkpoints.\n     */\n    function getAtProbablyRecentBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\n        require(blockNumber < block.number, \"Checkpoints: block not yet mined\");\n        uint32 key = SafeCast.toUint32(blockNumber);\n\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Pushes a value onto a History so that it is stored as the checkpoint for the current block.\n     *\n     * Returns previous value and new value.\n     */\n    function push(History storage self, uint256 value) internal returns (uint256, uint256) {\n        return _insert(self._checkpoints, SafeCast.toUint32(block.number), SafeCast.toUint224(value));\n    }\n\n    /**\n     * @dev Pushes a value onto a History, by updating the latest value using binary operation `op`. The new value will\n     * be set to `op(latest, delta)`.\n     *\n     * Returns previous value and new value.\n     */\n    function push(\n        History storage self,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) internal returns (uint256, uint256) {\n        return push(self, op(latest(self), delta));\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(History storage self) internal view returns (uint224) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(\n        History storage self\n    ) internal view returns (bool exists, uint32 _blockNumber, uint224 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._blockNumber, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(History storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            require(last._blockNumber <= key, \"Checkpoint: decreasing keys\");\n\n            // Update or push new checkpoint\n            if (last._blockNumber == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint({_blockNumber: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint({_blockNumber: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._blockNumber > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._blockNumber < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(Checkpoint[] storage self, uint256 pos) private pure returns (Checkpoint storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace224 {\n        Checkpoint224[] _checkpoints;\n    }\n\n    struct Checkpoint224 {\n        uint32 _key;\n        uint224 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace224 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     */\n    function push(Trace224 storage self, uint32 key, uint224 value) internal returns (uint224, uint224) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if there is none.\n     */\n    function lowerLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     */\n    function upperLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).\n     */\n    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace224 storage self) internal view returns (uint224) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace224 storage self) internal view returns (bool exists, uint32 _key, uint224 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint224 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace224 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint224[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint224 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            require(last._key <= key, \"Checkpoint: decreasing keys\");\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint224({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint224({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint224[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint224 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace160 {\n        Checkpoint160[] _checkpoints;\n    }\n\n    struct Checkpoint160 {\n        uint96 _key;\n        uint160 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace160 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     */\n    function push(Trace160 storage self, uint96 key, uint160 value) internal returns (uint160, uint160) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if there is none.\n     */\n    function lowerLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     */\n    function upperLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).\n     */\n    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace160 storage self) internal view returns (uint160) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace160 storage self) internal view returns (bool exists, uint96 _key, uint160 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint160 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace160 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint160[] storage self, uint96 key, uint160 value) private returns (uint160, uint160) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint160 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            require(last._key <= key, \"Checkpoint: decreasing keys\");\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint160({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint160({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint160[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint160 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSA.sol\";\nimport \"../ShortStrings.sol\";\nimport \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _name.toStringWithFallback(_nameFallback),\n            _version.toStringWithFallback(_versionFallback),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(_FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/DoubleEndedQueue.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/DoubleEndedQueue.sol)\npragma solidity ^0.8.4;\n\nimport \"../math/SafeCast.sol\";\n\n/**\n * @dev A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of\n * the sequence (called front and back). Among other access patterns, it can be used to implement efficient LIFO and\n * FIFO queues. Storage use is optimized, and all operations are O(1) constant time. This includes {clear}, given that\n * the existing queue contents are left in storage.\n *\n * The struct is called `Bytes32Deque`. Other types can be cast to and from `bytes32`. This data structure can only be\n * used in storage, and not in memory.\n * ```solidity\n * DoubleEndedQueue.Bytes32Deque queue;\n * ```\n *\n * _Available since v4.6._\n */\nlibrary DoubleEndedQueue {\n    /**\n     * @dev An operation (e.g. {front}) couldn't be completed due to the queue being empty.\n     */\n    error Empty();\n\n    /**\n     * @dev An operation (e.g. {at}) couldn't be completed due to an index being out of bounds.\n     */\n    error OutOfBounds();\n\n    /**\n     * @dev Indices are signed integers because the queue can grow in any direction. They are 128 bits so begin and end\n     * are packed in a single storage slot for efficient access. Since the items are added one at a time we can safely\n     * assume that these 128-bit indices will not overflow, and use unchecked arithmetic.\n     *\n     * Struct members have an underscore prefix indicating that they are \"private\" and should not be read or written to\n     * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\n     * lead to unexpected behavior.\n     *\n     * Indices are in the range [begin, end) which means the first item is at data[begin] and the last item is at\n     * data[end - 1].\n     */\n    struct Bytes32Deque {\n        int128 _begin;\n        int128 _end;\n        mapping(int128 => bytes32) _data;\n    }\n\n    /**\n     * @dev Inserts an item at the end of the queue.\n     */\n    function pushBack(Bytes32Deque storage deque, bytes32 value) internal {\n        int128 backIndex = deque._end;\n        deque._data[backIndex] = value;\n        unchecked {\n            deque._end = backIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Removes the item at the end of the queue and returns it.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function popBack(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 backIndex;\n        unchecked {\n            backIndex = deque._end - 1;\n        }\n        value = deque._data[backIndex];\n        delete deque._data[backIndex];\n        deque._end = backIndex;\n    }\n\n    /**\n     * @dev Inserts an item at the beginning of the queue.\n     */\n    function pushFront(Bytes32Deque storage deque, bytes32 value) internal {\n        int128 frontIndex;\n        unchecked {\n            frontIndex = deque._begin - 1;\n        }\n        deque._data[frontIndex] = value;\n        deque._begin = frontIndex;\n    }\n\n    /**\n     * @dev Removes the item at the beginning of the queue and returns it.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function popFront(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 frontIndex = deque._begin;\n        value = deque._data[frontIndex];\n        delete deque._data[frontIndex];\n        unchecked {\n            deque._begin = frontIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Returns the item at the beginning of the queue.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function front(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 frontIndex = deque._begin;\n        return deque._data[frontIndex];\n    }\n\n    /**\n     * @dev Returns the item at the end of the queue.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function back(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 backIndex;\n        unchecked {\n            backIndex = deque._end - 1;\n        }\n        return deque._data[backIndex];\n    }\n\n    /**\n     * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at\n     * `length(deque) - 1`.\n     *\n     * Reverts with `OutOfBounds` if the index is out of bounds.\n     */\n    function at(Bytes32Deque storage deque, uint256 index) internal view returns (bytes32 value) {\n        // int256(deque._begin) is a safe upcast\n        int128 idx = SafeCast.toInt128(int256(deque._begin) + SafeCast.toInt256(index));\n        if (idx >= deque._end) revert OutOfBounds();\n        return deque._data[idx];\n    }\n\n    /**\n     * @dev Resets the queue back to being empty.\n     *\n     * NOTE: The current items are left behind in storage. This does not affect the functioning of the queue, but misses\n     * out on potential gas refunds.\n     */\n    function clear(Bytes32Deque storage deque) internal {\n        deque._begin = 0;\n        deque._end = 0;\n    }\n\n    /**\n     * @dev Returns the number of items in the queue.\n     */\n    function length(Bytes32Deque storage deque) internal view returns (uint256) {\n        // The interface preserves the invariant that begin <= end so we assume this will not overflow.\n        // We also assume there are at most int256.max items in the queue.\n        unchecked {\n            return uint256(int256(deque._end) - int256(deque._begin));\n        }\n    }\n\n    /**\n     * @dev Returns true if the queue is empty.\n     */\n    function empty(Bytes32Deque storage deque) internal view returns (bool) {\n        return deque._end <= deque._begin;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Timers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Timers.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Tooling for timepoints, timers and delays\n *\n * CAUTION: This file is deprecated as of 4.9 and will be removed in the next major release.\n */\nlibrary Timers {\n    struct Timestamp {\n        uint64 _deadline;\n    }\n\n    function getDeadline(Timestamp memory timer) internal pure returns (uint64) {\n        return timer._deadline;\n    }\n\n    function setDeadline(Timestamp storage timer, uint64 timestamp) internal {\n        timer._deadline = timestamp;\n    }\n\n    function reset(Timestamp storage timer) internal {\n        timer._deadline = 0;\n    }\n\n    function isUnset(Timestamp memory timer) internal pure returns (bool) {\n        return timer._deadline == 0;\n    }\n\n    function isStarted(Timestamp memory timer) internal pure returns (bool) {\n        return timer._deadline > 0;\n    }\n\n    function isPending(Timestamp memory timer) internal view returns (bool) {\n        return timer._deadline > block.timestamp;\n    }\n\n    function isExpired(Timestamp memory timer) internal view returns (bool) {\n        return isStarted(timer) && timer._deadline <= block.timestamp;\n    }\n\n    struct BlockNumber {\n        uint64 _deadline;\n    }\n\n    function getDeadline(BlockNumber memory timer) internal pure returns (uint64) {\n        return timer._deadline;\n    }\n\n    function setDeadline(BlockNumber storage timer, uint64 timestamp) internal {\n        timer._deadline = timestamp;\n    }\n\n    function reset(BlockNumber storage timer) internal {\n        timer._deadline = 0;\n    }\n\n    function isUnset(BlockNumber memory timer) internal pure returns (bool) {\n        return timer._deadline == 0;\n    }\n\n    function isStarted(BlockNumber memory timer) internal pure returns (bool) {\n        return timer._deadline > 0;\n    }\n\n    function isPending(BlockNumber memory timer) internal view returns (bool) {\n        return timer._deadline > block.number;\n    }\n\n    function isExpired(BlockNumber memory timer) internal view returns (bool) {\n        return isStarted(timer) && timer._deadline <= block.number;\n    }\n}\n"
    },
    "contracts/AutoCompounder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {ICompoundOptimizer} from \"./interfaces/ICompoundOptimizer.sol\";\nimport {IRouter} from \"./interfaces/IRouter.sol\";\nimport {IAutoCompounder} from \"./interfaces/IAutoCompounder.sol\";\nimport {IAutoCompounderFactory} from \"./interfaces/factories/IAutoCompounderFactory.sol\";\nimport {IMezo} from \"./interfaces/IMezo.sol\";\nimport {IVoter} from \"./interfaces/IVoter.sol\";\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\nimport {IRewardsDistributor} from \"./interfaces/IRewardsDistributor.sol\";\nimport {IRouter} from \"./interfaces/IRouter.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC2771Context} from \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\n\n/// @title AutoCompounder for Managed veNFTs\n/// @author Carter Carlson (@pegahcarter)\n/// @notice Auto-Compound voting rewards earned from a Managed veNFT back into the veNFT through call incentivization\ncontract AutoCompounder is\n    IAutoCompounder,\n    ERC721Holder,\n    ERC2771Context,\n    ReentrancyGuard,\n    AccessControl\n{\n    using SafeERC20 for IERC20;\n    bytes32 public constant ALLOWED_CALLER = keccak256(\"ALLOWED_CALLER\");\n\n    address public immutable factory;\n    IRouter public immutable router;\n    IVoter public immutable voter;\n    IVotingEscrow public immutable ve;\n    IMezo public immutable mezo;\n    IRewardsDistributor public immutable distributor;\n    ICompoundOptimizer public immutable optimizer;\n\n    uint256 public tokenId;\n\n    constructor(\n        address _forwarder,\n        address _router,\n        address _voter,\n        address _optimizer,\n        address _admin\n    ) ERC2771Context(_forwarder) {\n        factory = _msgSender();\n        router = IRouter(_router);\n        voter = IVoter(_voter);\n        optimizer = ICompoundOptimizer(_optimizer);\n\n        ve = IVotingEscrow(voter.ve());\n        mezo = IMezo(ve.token());\n        distributor = IRewardsDistributor(ve.distributor());\n\n        // max approval is safe because of the immutability of ve.\n        // This approval is only ever utilized from ve.increaseAmount() calls.\n        mezo.approve(address(ve), type(uint256).max);\n\n        // Default admin can grant/revoke ALLOWED_CALLER roles\n        // See `ALLOWED_CALLER functions` section for permissions\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n        _grantRole(ALLOWED_CALLER, _admin);\n    }\n\n    function initialize(uint256 _tokenId) external {\n        if (_msgSender() != factory) revert NotFactory();\n        if (tokenId != 0) revert AlreadyInitialized();\n\n        tokenId = _tokenId;\n    }\n\n    // -------------------------------------------------\n    // Public functions\n    // -------------------------------------------------\n\n    /// @notice wrapper to claim earned bribes earned by the managed tokenId and compound\n    ///         by swapping to MEZO, rewarding the caller, and depositing into the managed veNFT\n    /// @param _bribes addresses of BribeVotingRewards contracts\n    /// @param _tokens array of array for which tokens to cleam for each BribeVotingRewards contract\n    /// @param _tokensToSwap Addresses of tokens to convert into MEZO\n    function claimBribesAndCompound(\n        address[] memory _bribes,\n        address[][] memory _tokens,\n        address[] memory _tokensToSwap\n    ) external nonReentrant {\n        voter.claimBribes(_bribes, _tokens, tokenId);\n        _swapTokensToMEZOAndCompound(_tokensToSwap);\n    }\n\n    /// @notice Similar to claimBribesAndCompound but for FeesVotingRewards contracts\n    /// @param _fees .\n    /// @param _tokens .\n    /// @param _tokensToSwap .\n    function claimFeesAndCompound(\n        address[] memory _fees,\n        address[][] memory _tokens,\n        address[] memory _tokensToSwap\n    ) external nonReentrant {\n        voter.claimFees(_fees, _tokens, tokenId);\n        _swapTokensToMEZOAndCompound(_tokensToSwap);\n    }\n\n    function _swapTokensToMEZOAndCompound(\n        address[] memory _tokensToSwap\n    ) internal {\n        for (uint256 i = 0; i < _tokensToSwap.length; i++) {\n            address token = _tokensToSwap[i];\n            if (token == address(mezo)) continue; // Do not need to swap from mezo => mezo\n            uint256 balance = IERC20(token).balanceOf(address(this));\n            if (balance == 0) continue; // only swap if there is a balance\n\n            IRouter.Route[] memory routes = optimizer\n                .getOptimalTokenToMezoRoute(token, balance);\n\n            // swap\n            _handleRouterApproval(IERC20(token), balance);\n            router.swapExactTokensForTokens(\n                balance,\n                0, // amountOutMin\n                routes,\n                address(this),\n                block.timestamp\n            );\n        }\n        _rewardAndCompound();\n    }\n\n    function _rewardAndCompound() internal {\n        address sender = _msgSender();\n        uint256 balance = mezo.balanceOf(address(this));\n        uint256 reward;\n\n        // claim rebase if possible\n        if (distributor.claimable(tokenId) > 0) {\n            distributor.claim(tokenId);\n        }\n\n        if (balance > 0) {\n            // reward callers if they are not the ALLOWED_CALLER\n            if (!hasRole(ALLOWED_CALLER, sender)) {\n                // reward the caller the minimum of:\n                // - 1% of the MEZO designated for compounding\n                // - The constant MEZO reward set by team in AutoCompounderFactory\n                uint256 compoundRewardAmount = balance / 100;\n                uint256 factoryRewardAmount = IAutoCompounderFactory(factory)\n                    .rewardAmount();\n                reward = compoundRewardAmount < factoryRewardAmount\n                    ? compoundRewardAmount\n                    : factoryRewardAmount;\n\n                if (reward > 0) {\n                    mezo.transfer(sender, reward);\n                    balance -= reward;\n                }\n            }\n\n            // Deposit the remaining balance into the nft\n            ve.increaseAmount(tokenId, balance);\n        }\n\n        emit RewardAndCompound(tokenId, sender, reward, balance);\n    }\n\n    // -------------------------------------------------\n    // ALLOWED_CALLER functions\n    // -------------------------------------------------\n\n    /// @notice Additional functionality for ALLOWED_CALLER to deposit more MEZO into the managed tokenId. This\n    ///         is effectively a bribe bonus for users that deposited into the autocompounder.\n    function increaseAmount(uint256 _value) external onlyRole(ALLOWED_CALLER) {\n        mezo.transferFrom(_msgSender(), address(this), _value);\n        ve.increaseAmount(tokenId, _value);\n    }\n\n    /// @notice Vote for Mezodrome pools with the given weights\n    /// @dev Refer to IVoter.vote()\n    function vote(\n        address[] calldata _poolVote,\n        uint256[] calldata _weights\n    ) external onlyRole(ALLOWED_CALLER) {\n        voter.vote(tokenId, _poolVote, _weights);\n    }\n\n    /// @notice Convert tokens held by this contract into MEZO using a route given by ALLOWED_CALLER and compound\n    ///         into the managed tokenId.  As there is an incentive to convert tokens held by this contract into MEZO and\n    ///         compound, this method is only needed when `from`:\n    ///             - does not have a pool with USDC, WETH, OP, and MEZO\n    ///             - does not have enough liquidity in USDC, WETH, OP, or MEZO to incentivize public calling\n    /// @dev This method does not reward the ALLOWED_CALLER for compounding\n    function swapTokenToMEZOAndCompound(\n        IRouter.Route[] calldata routes\n    ) external onlyRole(ALLOWED_CALLER) nonReentrant {\n        if (routes[routes.length - 1].to != address(mezo)) revert InvalidPath();\n        address from = routes[0].from;\n        if (from == address(mezo)) revert InvalidPath();\n\n        uint256 balance = IERC20(from).balanceOf(address(this));\n        if (balance > 0) {\n            _handleRouterApproval(IERC20(from), balance);\n            router.swapExactTokensForTokens(\n                balance,\n                0,\n                routes,\n                address(this),\n                block.timestamp\n            );\n        }\n        _rewardAndCompound();\n    }\n\n    // -------------------------------------------------\n    // Helpers\n    // -------------------------------------------------\n\n    /// @dev resets approval if needed then approves transfer of tokens to router\n    function _handleRouterApproval(IERC20 token, uint256 amount) internal {\n        uint256 allowance = token.allowance(address(this), address(router));\n        if (allowance > 0)\n            token.safeDecreaseAllowance(address(router), allowance);\n        token.safeIncreaseAllowance(address(router), amount);\n    }\n\n    // -------------------------------------------------\n    // Overrides\n    // -------------------------------------------------\n\n    function _msgData()\n        internal\n        view\n        override(ERC2771Context, Context)\n        returns (bytes calldata)\n    {\n        return ERC2771Context._msgData();\n    }\n\n    function _msgSender()\n        internal\n        view\n        override(ERC2771Context, Context)\n        returns (address)\n    {\n        return ERC2771Context._msgSender();\n    }\n}\n"
    },
    "contracts/ChainFeeSplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IVoter} from \"./interfaces/IVoter.sol\";\nimport {IEpochGovernor} from \"./interfaces/IEpochGovernor.sol\";\nimport {Splitter} from \"./Splitter.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IRewardsDistributor} from \"./interfaces/IRewardsDistributor.sol\";\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\nimport {IVoter} from \"./interfaces/IVoter.sol\";\n\n/// @title ChainFeeSplitter\n/// @notice A ChainFeeSplitter contract that changes the fee distribution between\n///         veBTC holders and Stake Gauges based on the gauge needle position.\ncontract ChainFeeSplitter is Splitter {\n    using SafeERC20 for IERC20;\n\n    /// @notice Rewards distribution among stake gauges.\n    IRewardsDistributor public immutable rewardsDistributor;\n\n    /// @notice The address of the Voter contract.\n    IVoter public immutable voter;\n\n    constructor(\n        address _voter, // the voting & distribution system\n        address _ve, // the ve(3,3) system that will be locked into\n        address _rewardsDistributor // rewards distributor\n    ) Splitter(_ve) {\n        /// The needle moves between 1 and 100. The default value is 33 to\n        /// simulate ~1/3 of fees going to the veBTC holders and ~2/3 to the\n        /// Stake Gauges.\n        needle = 33;\n        rewardsDistributor = IRewardsDistributor(_rewardsDistributor);\n        voter = IVoter(_voter);\n        activePeriod = ((block.timestamp) / WEEK) * WEEK;\n    }\n\n    /// @notice Returns the address of the epoch governor.\n    function epochGovernor() internal view override returns (address) {\n        return voter.epochGovernor();\n    }\n\n    /// @notice Transfers amount to veBTC holders. Token is BTC.\n    function transferFirstRecipient(uint256 amount) internal override {\n        token.safeTransfer(address(rewardsDistributor), amount);\n        // checkpoint token balance in rewards distributor\n        rewardsDistributor.checkpointToken();\n    }\n\n    /// @notice Transfers amount to stake gauges. Token is BTC.\n    function transferSecondRecipient(uint256 amount) internal override {\n        token.safeApprove(address(voter), amount);\n        voter.notifyRewardAmount(amount);\n    }\n}\n"
    },
    "contracts/CompoundOptimizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IRouter} from \"./interfaces/IRouter.sol\";\nimport {IPoolFactory} from \"./interfaces/factories/IPoolFactory.sol\";\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\nimport {ICompoundOptimizer} from \"./interfaces/ICompoundOptimizer.sol\";\nimport {IVoter} from \"./interfaces/IVoter.sol\";\n\n/// @notice storage for all AutoCompounders to call to calculate optimal amountOut into MEZO\n/// @author Carter Carlson (@pegahcarter)\ncontract CompoundOptimizer is ICompoundOptimizer {\n    address public immutable weth;\n    address public immutable mezo;\n    address public immutable factory;\n    IRouter public immutable router;\n\n    IRouter.Route[2][10] public routesTokenToMezo;\n\n    constructor(\n        address _usdc,\n        address _weth,\n        address _op,\n        address _mezo,\n        address _factoryV1,\n        address _factory,\n        address _router\n    ) {\n        mezo = _mezo;\n        weth = _weth;\n        factory = _factory;\n        router = IRouter(_router);\n\n        // Create routes for routesTokenToMezo\n        // from <> USDC <> MEZO\n\n        // from <stable v1> USDC <> MEZO\n        routesTokenToMezo[0][0] = IRouter.Route(\n            address(0),\n            _usdc,\n            true,\n            _factoryV1\n        );\n        // from <volatile v1> USDC <> MEZO\n        routesTokenToMezo[1][0] = IRouter.Route(\n            address(0),\n            _usdc,\n            false,\n            _factoryV1\n        );\n        // from <stable v2> USDC <> MEZO\n        routesTokenToMezo[2][0] = IRouter.Route(\n            address(0),\n            _usdc,\n            true,\n            _factory\n        );\n        // from <volatile v2> USDC <> MEZO\n        routesTokenToMezo[3][0] = IRouter.Route(\n            address(0),\n            _usdc,\n            false,\n            _factory\n        );\n\n        routesTokenToMezo[0][1] = IRouter.Route(_usdc, mezo, false, _factory);\n        routesTokenToMezo[1][1] = IRouter.Route(_usdc, _mezo, false, _factory);\n        routesTokenToMezo[2][1] = IRouter.Route(_usdc, _mezo, false, _factory);\n        routesTokenToMezo[3][1] = IRouter.Route(_usdc, _mezo, false, _factory);\n\n        // from <> WETH <> MEZO\n\n        // from <stable v1> WETH <> MEZO\n        routesTokenToMezo[4][0] = IRouter.Route(\n            address(0),\n            _weth,\n            true,\n            _factoryV1\n        );\n        // from <volatile v1> WETH <> MEZO\n        routesTokenToMezo[5][0] = IRouter.Route(\n            address(0),\n            _weth,\n            false,\n            _factoryV1\n        );\n        // from <stable v2> WETH <> MEZO\n        routesTokenToMezo[6][0] = IRouter.Route(\n            address(0),\n            _weth,\n            true,\n            _factory\n        );\n        // from <volatile v2> WETH <> MEZO\n        routesTokenToMezo[7][0] = IRouter.Route(\n            address(0),\n            _weth,\n            false,\n            _factory\n        );\n\n        routesTokenToMezo[4][1] = IRouter.Route(_weth, _mezo, false, _factory);\n        routesTokenToMezo[5][1] = IRouter.Route(_weth, _mezo, false, _factory);\n        routesTokenToMezo[6][1] = IRouter.Route(_weth, _mezo, false, _factory);\n        routesTokenToMezo[7][1] = IRouter.Route(_weth, _mezo, false, _factory);\n\n        // from <> OP <> MEZO\n\n        // from <volatile v1> OP <> MEZO\n        routesTokenToMezo[8][0] = IRouter.Route(\n            address(0),\n            _op,\n            false,\n            _factoryV1\n        );\n        // from <volatile v2> OP <> MEZO\n        routesTokenToMezo[9][0] = IRouter.Route(\n            address(0),\n            _op,\n            false,\n            _factory\n        );\n\n        routesTokenToMezo[8][1] = IRouter.Route(_op, _mezo, false, _factory);\n        routesTokenToMezo[9][1] = IRouter.Route(_op, _mezo, false, _factory);\n    }\n\n    /// @inheritdoc ICompoundOptimizer\n    function getOptimalTokenToMezoRoute(\n        address token,\n        uint256 amountIn\n    ) external view returns (IRouter.Route[] memory) {\n        // Get best route from multi-route paths\n        uint256 index;\n        uint256 optimalAmountOut;\n        IRouter.Route[] memory routes = new IRouter.Route[](2);\n        uint256[] memory amountsOut;\n\n        // loop through multi-route paths\n        for (uint256 i = 0; i < 10; i++) {\n            routes[0] = routesTokenToMezo[i][0];\n\n            // Go to next route if a trading pool does not exist\n            if (\n                IPoolFactory(routes[0].factory).getPool(\n                    token,\n                    routes[0].to,\n                    routes[0].stable\n                ) == address(0)\n            ) continue;\n\n            routes[1] = routesTokenToMezo[i][1];\n            // Set the from token as storage does not have an address set\n            routes[0].from = token;\n\n            amountsOut = router.getAmountsOut(amountIn, routes);\n            // amountOut is in the third index - 0 is amountIn and 1 is the first route output\n            uint256 amountOut = amountsOut[2];\n            if (amountOut > optimalAmountOut) {\n                // store the index and amount of the optimal amount out\n                optimalAmountOut = amountOut;\n                index = i;\n            }\n        }\n        // use the optimal route determined from the loop\n        routes[0] = routesTokenToMezo[index][0];\n        routes[1] = routesTokenToMezo[index][1];\n        routes[0].from = token;\n\n        // Get amountOut from a direct route to MEZO\n        IRouter.Route[] memory route = new IRouter.Route[](1);\n        route[0] = IRouter.Route(token, mezo, false, factory);\n        amountsOut = router.getAmountsOut(amountIn, route);\n        uint256 singleSwapAmountOut = amountsOut[1];\n\n        if (singleSwapAmountOut == 0 && optimalAmountOut == 0)\n            revert NoRouteFound();\n\n        // compare output and return the best result\n        return singleSwapAmountOut > optimalAmountOut ? route : routes;\n    }\n}\n"
    },
    "contracts/EpochGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IVotes} from \"./governance/IVotes.sol\";\n\nimport {IGovernor} from \"./governance/IGovernor.sol\";\nimport {GovernorSimple} from \"./governance/GovernorSimple.sol\";\nimport {GovernorCountingMajority} from \"./governance/GovernorCountingMajority.sol\";\nimport {GovernorSimpleVotes} from \"./governance/GovernorSimpleVotes.sol\";\n\n/**\n * @dev Epoch based governance system that allows for a three option majority (against, for, abstain).\n *      Note that hash proposals are unique per epoch, but calls to a function with different values\n *      may be allowed any number of times. It is best to use EpochGovernor with a function that accepts\n *      no values.\n */\ncontract EpochGovernor is\n    GovernorSimple,\n    GovernorCountingMajority,\n    GovernorSimpleVotes\n{\n    constructor(\n        address _forwarder,\n        IVotes _ve,\n        address _splitter\n    )\n        GovernorSimple(_forwarder, \"Epoch Governor\", _splitter)\n        GovernorSimpleVotes(_ve)\n    {}\n\n    function votingDelay() public pure override(IGovernor) returns (uint256) {\n        return (15 minutes);\n    }\n\n    function votingPeriod() public pure override(IGovernor) returns (uint256) {\n        return (1 weeks);\n    }\n}\n"
    },
    "contracts/factories/AutoCompounderFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IVoter} from \"../interfaces/IVoter.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\nimport {IRouter} from \"../interfaces/IRouter.sol\";\nimport {IAutoCompounderFactory} from \"../interfaces/factories/IAutoCompounderFactory.sol\";\nimport {AutoCompounder} from \"../AutoCompounder.sol\";\nimport {CompoundOptimizer} from \"../CompoundOptimizer.sol\";\n\ncontract AutoCompounderFactory is IAutoCompounderFactory {\n    /// @notice The amount rewarded per token a caller earns from calling AutoCompounder.claimXAndCompound()\n    uint256 public rewardAmount = 10 * 1e18;\n    uint256 internal constant MAX_REWARD_AMOUNT = 1_000 * 1e18; // 1,000 MEZO\n    uint256 internal constant MIN_REWARD_AMOUNT = 1e17; // 0.1 MEZO\n\n    address public immutable forwarder;\n    address public immutable router;\n    address public immutable voter;\n    address public immutable optimizer;\n    IVotingEscrow public immutable ve;\n\n    mapping(address => bool) public isAutoCompounder;\n\n    constructor(\n        address _forwarder,\n        address _voter,\n        address _router,\n        address _optimizer\n    ) {\n        forwarder = _forwarder;\n        voter = _voter;\n        router = _router;\n        optimizer = _optimizer;\n\n        ve = IVotingEscrow(IVoter(voter).ve());\n    }\n\n    function createAutoCompounder(\n        address _admin,\n        uint256 _tokenId\n    ) external returns (address autoCompounder) {\n        if (_tokenId == 0) revert TokenIdZero();\n        if (!ve.isApprovedOrOwner(msg.sender, _tokenId))\n            revert TokenIdNotApproved();\n        if (ve.escrowType(_tokenId) != IVotingEscrow.EscrowType.MANAGED)\n            revert TokenIdNotManaged();\n\n        // create the autocompounder contract\n        autoCompounder = address(\n            new AutoCompounder(forwarder, router, voter, optimizer, _admin)\n        );\n\n        // transfer nft to autocompounder\n        ve.safeTransferFrom(ve.ownerOf(_tokenId), autoCompounder, _tokenId);\n        AutoCompounder(autoCompounder).initialize(_tokenId);\n\n        isAutoCompounder[autoCompounder] = true;\n        emit CreateAutoCompounder(msg.sender, _admin, autoCompounder);\n    }\n\n    function setRewardAmount(uint256 _rewardAmount) external {\n        if (msg.sender != ve.team()) revert NotTeam();\n        if (_rewardAmount == rewardAmount) revert AmountSame();\n        if (\n            _rewardAmount < MIN_REWARD_AMOUNT ||\n            _rewardAmount > MAX_REWARD_AMOUNT\n        ) revert AmountOutOfAcceptableRange();\n        rewardAmount = _rewardAmount;\n        emit SetRewardAmount(_rewardAmount);\n    }\n}\n"
    },
    "contracts/factories/FactoryRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IFactoryRegistry} from \"../interfaces/factories/IFactoryRegistry.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @title Protocol Factory Registry\n/// @author Carter Carlson (@pegahcarter)\n/// @notice Protocol Factory Registry to swap and create gauges\ncontract FactoryRegistry is IFactoryRegistry, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev factory to create free and locked rewards for a managed veNFT\n    address private _managedRewardsFactory;\n\n    /// @dev The protocol will always have a usable poolFactory, votingRewardsFactory, and gaugeFactory.  The votingRewardsFactory\n    // and gaugeFactory are defined to the poolFactory which can never be removed\n    address public immutable fallbackPoolFactory;\n\n    /// @dev Array of poolFactories used to create a gauge and votingRewards\n    EnumerableSet.AddressSet private _poolFactories;\n\n    struct FactoriesToPoolFactory {\n        address votingRewardsFactory;\n        address gaugeFactory;\n    }\n    /// @dev the factories linked to the poolFactory\n    mapping(address => FactoriesToPoolFactory) private _factoriesToPoolsFactory;\n\n    constructor(\n        address _fallbackPoolFactory,\n        address _fallbackVotingRewardsFactory,\n        address _fallbackGaugeFactory,\n        address _newManagedRewardsFactory\n    ) {\n        fallbackPoolFactory = _fallbackPoolFactory;\n\n        approve(\n            _fallbackPoolFactory,\n            _fallbackVotingRewardsFactory,\n            _fallbackGaugeFactory\n        );\n        setManagedRewardsFactory(_newManagedRewardsFactory);\n    }\n\n    /// @inheritdoc IFactoryRegistry\n    function approve(\n        address poolFactory,\n        address votingRewardsFactory,\n        address gaugeFactory\n    ) public onlyOwner {\n        if (\n            poolFactory == address(0) ||\n            votingRewardsFactory == address(0) ||\n            gaugeFactory == address(0)\n        ) revert ZeroAddress();\n        if (_poolFactories.contains(poolFactory)) revert PathAlreadyApproved();\n\n        FactoriesToPoolFactory memory usedFactories = _factoriesToPoolsFactory[\n            poolFactory\n        ];\n\n        // If the poolFactory *has not* been approved before, can approve any gauge/votingRewards factory\n        // Only one check is sufficient\n        if (usedFactories.votingRewardsFactory == address(0)) {\n            _factoriesToPoolsFactory[poolFactory] = FactoriesToPoolFactory(\n                votingRewardsFactory,\n                gaugeFactory\n            );\n        } else {\n            // If the poolFactory *has* been approved before, can only approve the same used gauge/votingRewards factory to\n            //     to maintain state within Voter\n            if (\n                votingRewardsFactory != usedFactories.votingRewardsFactory ||\n                gaugeFactory != usedFactories.gaugeFactory\n            ) revert InvalidFactoriesToPoolFactory();\n        }\n\n        _poolFactories.add(poolFactory);\n        emit Approve(poolFactory, votingRewardsFactory, gaugeFactory);\n    }\n\n    /// @inheritdoc IFactoryRegistry\n    function unapprove(address poolFactory) external onlyOwner {\n        if (poolFactory == fallbackPoolFactory) revert FallbackFactory();\n        if (!_poolFactories.contains(poolFactory)) revert PathNotApproved();\n        _poolFactories.remove(poolFactory);\n        (\n            address votingRewardsFactory,\n            address gaugeFactory\n        ) = factoriesToPoolFactory(poolFactory);\n        emit Unapprove(poolFactory, votingRewardsFactory, gaugeFactory);\n    }\n\n    /// @inheritdoc IFactoryRegistry\n    function setManagedRewardsFactory(\n        address _newManagedRewardsFactory\n    ) public onlyOwner {\n        if (_newManagedRewardsFactory == _managedRewardsFactory)\n            revert SameAddress();\n        if (_newManagedRewardsFactory == address(0)) revert ZeroAddress();\n        _managedRewardsFactory = _newManagedRewardsFactory;\n        emit SetManagedRewardsFactory(_newManagedRewardsFactory);\n    }\n\n    /// @inheritdoc IFactoryRegistry\n    function managedRewardsFactory() external view returns (address) {\n        return _managedRewardsFactory;\n    }\n\n    /// @inheritdoc IFactoryRegistry\n    function factoriesToPoolFactory(\n        address poolFactory\n    ) public view returns (address votingRewardsFactory, address gaugeFactory) {\n        FactoriesToPoolFactory memory f = _factoriesToPoolsFactory[poolFactory];\n        votingRewardsFactory = f.votingRewardsFactory;\n        gaugeFactory = f.gaugeFactory;\n    }\n\n    /// @inheritdoc IFactoryRegistry\n    function poolFactories() external view returns (address[] memory) {\n        return _poolFactories.values();\n    }\n\n    /// @inheritdoc IFactoryRegistry\n    function isPoolFactoryApproved(\n        address poolFactory\n    ) external view returns (bool) {\n        return _poolFactories.contains(poolFactory);\n    }\n\n    /// @inheritdoc IFactoryRegistry\n    function poolFactoriesLength() external view returns (uint256) {\n        return _poolFactories.length();\n    }\n}\n"
    },
    "contracts/factories/GaugeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IGaugeFactory} from \"../interfaces/factories/IGaugeFactory.sol\";\nimport {Gauge} from \"../gauges/Gauge.sol\";\n\ncontract GaugeFactory is IGaugeFactory {\n    function createGauge(\n        address _forwarder,\n        address _pool,\n        address _feesVotingReward,\n        address _rewardToken,\n        bool isPool\n    ) external returns (address gauge) {\n        gauge = address(\n            new Gauge(\n                _forwarder,\n                _pool,\n                _feesVotingReward,\n                _rewardToken,\n                msg.sender,\n                isPool\n            )\n        );\n    }\n}\n"
    },
    "contracts/factories/ManagedRewardsFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IManagedRewardsFactory} from \"../interfaces/factories/IManagedRewardsFactory.sol\";\nimport {FreeManagedReward} from \"../rewards/FreeManagedReward.sol\";\nimport {LockedManagedReward} from \"../rewards/LockedManagedReward.sol\";\n\ncontract ManagedRewardsFactory is IManagedRewardsFactory {\n    /// @inheritdoc IManagedRewardsFactory\n    function createRewards(\n        address _forwarder,\n        address _voter\n    )\n        external\n        returns (address lockedManagedReward, address freeManagedReward)\n    {\n        lockedManagedReward = address(\n            new LockedManagedReward(_forwarder, _voter)\n        );\n        freeManagedReward = address(new FreeManagedReward(_forwarder, _voter));\n        emit ManagedRewardCreated(\n            _voter,\n            lockedManagedReward,\n            freeManagedReward\n        );\n    }\n}\n"
    },
    "contracts/factories/PoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IPoolFactory} from \"../interfaces/factories/IPoolFactory.sol\";\nimport {IPool} from \"../interfaces/IPool.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\ncontract PoolFactory is IPoolFactory {\n    address public immutable implementation;\n\n    bool public isPaused;\n    address public pauser;\n\n    uint256 public stableFee;\n    uint256 public volatileFee;\n    uint256 public constant MAX_FEE = 300; // 3%\n    // Override to indicate there is custom 0% fee - as a 0 value in the customFee mapping indicates\n    // that no custom fee rate has been set\n    uint256 public constant ZERO_FEE_INDICATOR = 420;\n    address public feeManager;\n\n    /// @dev used to change the name/symbol of the pool by calling emergencyCouncil\n    address public voter;\n\n    mapping(address => mapping(address => mapping(bool => address)))\n        private _getPool;\n    address[] public allPools;\n    mapping(address => bool) private _isPool; // simplified check if its a pool, given that `stable` flag might not be available in peripherals\n    mapping(address => uint256) public customFee; // override for custom fees\n\n    address internal _temp0;\n    address internal _temp1;\n    bool internal _temp;\n\n    constructor(address _implementation) {\n        implementation = _implementation;\n        voter = msg.sender;\n        pauser = msg.sender;\n        feeManager = msg.sender;\n        isPaused = false;\n        stableFee = 5; // 0.05%\n        volatileFee = 30; // 0.3%\n    }\n\n    /// @inheritdoc IPoolFactory\n    function allPoolsLength() external view returns (uint256) {\n        return allPools.length;\n    }\n\n    /// @inheritdoc IPoolFactory\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address) {\n        return\n            fee > 1\n                ? address(0)\n                : fee == 1\n                    ? _getPool[tokenA][tokenB][true]\n                    : _getPool[tokenA][tokenB][false];\n    }\n\n    /// @inheritdoc IPoolFactory\n    function getPool(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external view returns (address) {\n        return _getPool[tokenA][tokenB][stable];\n    }\n\n    /// @inheritdoc IPoolFactory\n    function isPool(address pool) external view returns (bool) {\n        return _isPool[pool];\n    }\n\n    /// @inheritdoc IPoolFactory\n    function setVoter(address _voter) external {\n        if (msg.sender != voter) revert NotVoter();\n        voter = _voter;\n        emit SetVoter(_voter);\n    }\n\n    function setPauser(address _pauser) external {\n        if (msg.sender != pauser) revert NotPauser();\n        if (_pauser == address(0)) revert ZeroAddress();\n        pauser = _pauser;\n        emit SetPauser(_pauser);\n    }\n\n    function setPauseState(bool _state) external {\n        if (msg.sender != pauser) revert NotPauser();\n        isPaused = _state;\n        emit SetPauseState(_state);\n    }\n\n    function setFeeManager(address _feeManager) external {\n        if (msg.sender != feeManager) revert NotFeeManager();\n        if (_feeManager == address(0)) revert ZeroAddress();\n        feeManager = _feeManager;\n        emit SetFeeManager(_feeManager);\n    }\n\n    /// @inheritdoc IPoolFactory\n    function setFee(bool _stable, uint256 _fee) external {\n        if (msg.sender != feeManager) revert NotFeeManager();\n        if (_fee > MAX_FEE) revert FeeTooHigh();\n        if (_fee == 0) revert ZeroFee();\n        if (_stable) {\n            stableFee = _fee;\n        } else {\n            volatileFee = _fee;\n        }\n    }\n\n    /// @inheritdoc IPoolFactory\n    function setCustomFee(address pool, uint256 fee) external {\n        if (msg.sender != feeManager) revert NotFeeManager();\n        if (fee > MAX_FEE && fee != ZERO_FEE_INDICATOR) revert FeeTooHigh();\n        if (!_isPool[pool]) revert InvalidPool();\n\n        customFee[pool] = fee;\n        emit SetCustomFee(pool, fee);\n    }\n\n    /// @inheritdoc IPoolFactory\n    function getFee(address pool, bool _stable) public view returns (uint256) {\n        uint256 fee = customFee[pool];\n        return\n            fee == ZERO_FEE_INDICATOR\n                ? 0\n                : fee != 0\n                    ? fee\n                    : _stable\n                        ? stableFee\n                        : volatileFee;\n    }\n\n    /// @inheritdoc IPoolFactory\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool) {\n        if (fee > 1) revert FeeInvalid();\n        bool stable = fee == 1;\n        return createPool(tokenA, tokenB, stable);\n    }\n\n    /// @inheritdoc IPoolFactory\n    function createPool(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) public returns (address pool) {\n        if (tokenA == tokenB) revert SameAddress();\n        (address token0, address token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        if (token0 == address(0)) revert ZeroAddress();\n        if (_getPool[token0][token1][stable] != address(0))\n            revert PoolAlreadyExists();\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1, stable)); // salt includes stable as well, 3 parameters\n        pool = Clones.cloneDeterministic(implementation, salt);\n        IPool(pool).initialize(token0, token1, stable);\n        _getPool[token0][token1][stable] = pool;\n        _getPool[token1][token0][stable] = pool; // populate mapping in the reverse direction\n        allPools.push(pool);\n        _isPool[pool] = true;\n        emit PoolCreated(token0, token1, stable, pool, allPools.length);\n    }\n}\n"
    },
    "contracts/factories/VotingRewardsFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IVotingRewardsFactory} from \"../interfaces/factories/IVotingRewardsFactory.sol\";\nimport {FeesVotingReward} from \"../rewards/FeesVotingReward.sol\";\nimport {BribeVotingReward} from \"../rewards/BribeVotingReward.sol\";\n\ncontract VotingRewardsFactory is IVotingRewardsFactory {\n    /// @inheritdoc IVotingRewardsFactory\n    function createRewards(\n        address _forwarder,\n        address[] memory _rewards\n    ) external returns (address feesVotingReward, address bribeVotingReward) {\n        feesVotingReward = address(\n            new FeesVotingReward(_forwarder, msg.sender, _rewards)\n        );\n        bribeVotingReward = address(\n            new BribeVotingReward(_forwarder, msg.sender, _rewards)\n        );\n    }\n}\n"
    },
    "contracts/forwarder/IForwarder.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n// Copied from the GSN implementation https://github.com/opengsn/gsn/tree/master/packages/contracts/src/forwarder\npragma solidity 0.8.24;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\n\n/**\n * @title The Forwarder Interface\n * @notice The contracts implementing this interface take a role of authorization, authentication and replay protection\n * for contracts that choose to trust a `Forwarder`, instead of relying on a mechanism built into the Ethereum protocol.\n *\n * @notice if the `Forwarder` contract decides that an incoming `ForwardRequest` is valid, it must append 20 bytes that\n * represent the caller to the `data` field of the request and send this new data to the target address (the `to` field)\n *\n * :warning: **Warning** :warning: The Forwarder can have a full control over a `Recipient` contract.\n * Any vulnerability in a `Forwarder` implementation can make all of its `Recipient` contracts susceptible!\n * Recipient contracts should only trust forwarders that passed through security audit,\n * otherwise they are susceptible to identity theft.\n */\ninterface IForwarder is IERC165 {\n    /**\n     * @notice A representation of a request for a `Forwarder` to send `data` on behalf of a `from` to a target (`to`).\n     */\n    struct ForwardRequest {\n        address from;\n        address to;\n        uint256 value;\n        uint256 gas;\n        uint256 nonce;\n        bytes data;\n        uint256 validUntilTime;\n    }\n\n    event DomainRegistered(bytes32 indexed domainSeparator, bytes domainValue);\n\n    event RequestTypeRegistered(bytes32 indexed typeHash, string typeStr);\n\n    /**\n     * @param from The address of a sender.\n     * @return The nonce for this address.\n     */\n    function getNonce(address from) external view returns (uint256);\n\n    /**\n     * @notice Verify the transaction is valid and can be executed.\n     * Implementations must validate the signature and the nonce of the request are correct.\n     * Does not revert and returns successfully if the input is valid.\n     * Reverts if any validation has failed. For instance, if either signature or nonce are incorrect.\n     * Reverts if `domainSeparator` or `requestTypeHash` are not registered as well.\n     */\n    function verify(\n        ForwardRequest calldata forwardRequest,\n        bytes32 domainSeparator,\n        bytes32 requestTypeHash,\n        bytes calldata suffixData,\n        bytes calldata signature\n    ) external view;\n\n    /**\n     * @notice Executes a transaction specified by the `ForwardRequest`.\n     * The transaction is first verified and then executed.\n     * The success flag and returned bytes array of the `CALL` are returned as-is.\n     *\n     * This method would revert only in case of a verification error.\n     *\n     * All the target errors are reported using the returned success flag and returned bytes array.\n     *\n     * @param forwardRequest All requested transaction parameters.\n     * @param domainSeparator The domain used when signing this request.\n     * @param requestTypeHash The request type used when signing this request.\n     * @param suffixData The ABI-encoded extension data for the current `RequestType` used when signing this request.\n     * @param signature The client signature to be validated.\n     *\n     * @return success The success flag of the underlying `CALL` to the target address.\n     * @return ret The byte array returned by the underlying `CALL` to the target address.\n     */\n    function execute(\n        ForwardRequest calldata forwardRequest,\n        bytes32 domainSeparator,\n        bytes32 requestTypeHash,\n        bytes calldata suffixData,\n        bytes calldata signature\n    ) external payable returns (bool success, bytes memory ret);\n\n    /**\n     * @notice Register a new Request typehash.\n     *\n     * @notice This is necessary for the Forwarder to be able to verify the signatures conforming to the ERC-712.\n     *\n     * @param typeName The name of the request type.\n     * @param typeSuffix Any extra data after the generic params. Must contain add at least one param.\n     * The generic ForwardRequest type is always registered by the constructor.\n     */\n    function registerRequestType(\n        string calldata typeName,\n        string calldata typeSuffix\n    ) external;\n\n    /**\n     * @notice Register a new domain separator.\n     *\n     * @notice This is necessary for the Forwarder to be able to verify the signatures conforming to the ERC-712.\n     *\n     * @notice The domain separator must have the following fields: `name`, `version`, `chainId`, `verifyingContract`.\n     * The `chainId` is the current network's `chainId`, and the `verifyingContract` is this Forwarder's address.\n     * This method accepts the domain name and version to create and register the domain separator value.\n     * @param name The domain's display name.\n     * @param version The domain/protocol version.\n     */\n    function registerDomainSeparator(\n        string calldata name,\n        string calldata version\n    ) external;\n}\n"
    },
    "contracts/forwarder/MezoForwarder.sol": {
      "content": "// solhint-disable not-rely-on-time\n// SPDX-License-Identifier: GPL-3.0-only\n// Copied from the GSN implementation https://github.com/opengsn/gsn/tree/master/packages/contracts/src/forwarder\npragma solidity 0.8.24;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport \"./IForwarder.sol\";\n\n/// @title Mezo Forwarder\n/// @notice Trusted ERC-2771 forwarder contract allowing to perform smart\n///         contract operations on behalf of another address.\ncontract MezoForwarder is IForwarder, ERC165 {\n    using ECDSA for bytes32;\n\n    address private constant DRY_RUN_ADDRESS =\n        0x0000000000000000000000000000000000000000;\n\n    string public constant GENERIC_PARAMS =\n        \"address from,address to,uint256 value,uint256 gas,uint256 nonce,bytes data,uint256 validUntilTime\";\n\n    string public constant EIP712_DOMAIN_TYPE =\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\";\n\n    mapping(bytes32 => bool) public typeHashes;\n    mapping(bytes32 => bool) public domains;\n\n    // Nonces of senders, used to prevent replay attacks\n    mapping(address => uint256) private nonces;\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    /// @inheritdoc IForwarder\n    function getNonce(address from) public view override returns (uint256) {\n        return nonces[from];\n    }\n\n    constructor() {\n        string memory requestType = string(\n            abi.encodePacked(\"ForwardRequest(\", GENERIC_PARAMS, \")\")\n        );\n        registerRequestTypeInternal(requestType);\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(IERC165, ERC165) returns (bool) {\n        return\n            interfaceId == type(IForwarder).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IForwarder\n    function verify(\n        ForwardRequest calldata req,\n        bytes32 domainSeparator,\n        bytes32 requestTypeHash,\n        bytes calldata suffixData,\n        bytes calldata sig\n    ) external view override {\n        _verifyNonce(req);\n        _verifySig(req, domainSeparator, requestTypeHash, suffixData, sig);\n    }\n\n    /// @inheritdoc IForwarder\n    function execute(\n        ForwardRequest calldata req,\n        bytes32 domainSeparator,\n        bytes32 requestTypeHash,\n        bytes calldata suffixData,\n        bytes calldata sig\n    ) external payable override returns (bool success, bytes memory ret) {\n        _verifySig(req, domainSeparator, requestTypeHash, suffixData, sig);\n        _verifyAndUpdateNonce(req);\n\n        require(\n            req.validUntilTime == 0 || req.validUntilTime > block.timestamp,\n            \"FWD: request expired\"\n        );\n\n        uint256 gasForTransfer = 0;\n        if (req.value != 0) {\n            gasForTransfer = 40000; //buffer in case we need to move eth after the transaction.\n        }\n        bytes memory callData = abi.encodePacked(req.data, req.from);\n        require(\n            (gasleft() * 63) / 64 >= req.gas + gasForTransfer,\n            \"FWD: insufficient gas\"\n        );\n        // solhint-disable-next-line avoid-low-level-calls\n        (success, ret) = req.to.call{gas: req.gas, value: req.value}(callData);\n\n        if (req.value != 0 && address(this).balance > 0) {\n            // can't fail: req.from signed (off-chain) the request, so it must be an EOA...\n            payable(req.from).transfer(address(this).balance);\n        }\n\n        return (success, ret);\n    }\n\n    function _verifyNonce(ForwardRequest calldata req) internal view {\n        require(nonces[req.from] == req.nonce, \"FWD: nonce mismatch\");\n    }\n\n    function _verifyAndUpdateNonce(ForwardRequest calldata req) internal {\n        require(nonces[req.from]++ == req.nonce, \"FWD: nonce mismatch\");\n    }\n\n    /// @inheritdoc IForwarder\n    function registerRequestType(\n        string calldata typeName,\n        string calldata typeSuffix\n    ) external override {\n        for (uint256 i = 0; i < bytes(typeName).length; i++) {\n            bytes1 c = bytes(typeName)[i];\n            require(c != \"(\" && c != \")\", \"FWD: invalid typename\");\n        }\n\n        string memory requestType = string(\n            abi.encodePacked(typeName, \"(\", GENERIC_PARAMS, \",\", typeSuffix)\n        );\n        registerRequestTypeInternal(requestType);\n    }\n\n    /// @inheritdoc IForwarder\n    function registerDomainSeparator(\n        string calldata name,\n        string calldata version\n    ) external override {\n        uint256 chainId;\n        /* solhint-disable-next-line no-inline-assembly */\n        assembly {\n            chainId := chainid()\n        }\n\n        bytes memory domainValue = abi.encode(\n            keccak256(bytes(EIP712_DOMAIN_TYPE)),\n            keccak256(bytes(name)),\n            keccak256(bytes(version)),\n            chainId,\n            address(this)\n        );\n\n        bytes32 domainHash = keccak256(domainValue);\n\n        domains[domainHash] = true;\n        emit DomainRegistered(domainHash, domainValue);\n    }\n\n    function registerRequestTypeInternal(string memory requestType) internal {\n        bytes32 requestTypehash = keccak256(bytes(requestType));\n        typeHashes[requestTypehash] = true;\n        emit RequestTypeRegistered(requestTypehash, requestType);\n    }\n\n    function _verifySig(\n        ForwardRequest calldata req,\n        bytes32 domainSeparator,\n        bytes32 requestTypeHash,\n        bytes calldata suffixData,\n        bytes calldata sig\n    ) internal view virtual {\n        require(domains[domainSeparator], \"FWD: unregistered domain sep.\");\n        require(typeHashes[requestTypeHash], \"FWD: unregistered typehash\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                keccak256(_getEncoded(req, requestTypeHash, suffixData))\n            )\n        );\n        // solhint-disable-next-line avoid-tx-origin\n        require(\n            tx.origin == DRY_RUN_ADDRESS || digest.recover(sig) == req.from,\n            \"FWD: signature mismatch\"\n        );\n    }\n\n    /**\n     * @notice Creates a byte array that is a valid ABI encoding of a request of a `RequestType` type. See `execute()`.\n     */\n    function _getEncoded(\n        ForwardRequest calldata req,\n        bytes32 requestTypeHash,\n        bytes calldata suffixData\n    ) public pure returns (bytes memory) {\n        // we use encodePacked since we append suffixData as-is, not as dynamic param.\n        // still, we must make sure all first params are encoded as abi.encode()\n        // would encode them - as 256-bit-wide params.\n        return\n            abi.encodePacked(\n                requestTypeHash,\n                uint256(uint160(req.from)),\n                uint256(uint160(req.to)),\n                req.value,\n                req.gas,\n                req.nonce,\n                keccak256(req.data),\n                req.validUntilTime,\n                suffixData\n            );\n    }\n}\n"
    },
    "contracts/gauges/Gauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IReward} from \"../interfaces/IReward.sol\";\nimport {IGauge} from \"../interfaces/IGauge.sol\";\nimport {IPool} from \"../interfaces/IPool.sol\";\nimport {IVoter} from \"../interfaces/IVoter.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC2771Context} from \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {ProtocolTimeLibrary} from \"../libraries/ProtocolTimeLibrary.sol\";\n\n/// @title Protocol Gauge\n/// @author veldorome.finance, @figs999, @pegahcarter\n/// @notice Gauge contract for distribution of emissions by address\ncontract Gauge is IGauge, ERC2771Context, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    /// @inheritdoc IGauge\n    address public immutable stakingToken;\n    /// @inheritdoc IGauge\n    address public immutable rewardToken;\n    /// @inheritdoc IGauge\n    address public immutable feesVotingReward;\n    /// @inheritdoc IGauge\n    address public immutable voter;\n    /// @inheritdoc IGauge\n    address public immutable ve;\n\n    /// @inheritdoc IGauge\n    bool public immutable isPool;\n\n    uint256 internal constant DURATION = 7 days; // rewards are released over 7 days\n    uint256 internal constant PRECISION = 10 ** 18;\n\n    /// @inheritdoc IGauge\n    uint256 public periodFinish;\n    /// @inheritdoc IGauge\n    uint256 public rewardRate;\n    /// @inheritdoc IGauge\n    uint256 public lastUpdateTime;\n    /// @inheritdoc IGauge\n    uint256 public rewardPerTokenStored;\n    /// @inheritdoc IGauge\n    uint256 public totalSupply;\n    /// @inheritdoc IGauge\n    mapping(address => uint256) public balanceOf;\n    /// @inheritdoc IGauge\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    /// @inheritdoc IGauge\n    mapping(address => uint256) public rewards;\n    /// @inheritdoc IGauge\n    mapping(uint256 => uint256) public rewardRateByEpoch;\n\n    /// @inheritdoc IGauge\n    uint256 public fees0;\n    /// @inheritdoc IGauge\n    uint256 public fees1;\n\n    constructor(\n        address _forwarder,\n        address _stakingToken,\n        address _feesVotingReward,\n        address _rewardToken,\n        address _voter,\n        bool _isPool\n    ) ERC2771Context(_forwarder) {\n        stakingToken = _stakingToken;\n        feesVotingReward = _feesVotingReward;\n        rewardToken = _rewardToken;\n        voter = _voter;\n        isPool = _isPool;\n        ve = IVoter(voter).ve();\n    }\n\n    function _claimFees()\n        internal\n        returns (uint256 claimed0, uint256 claimed1)\n    {\n        if (!isPool) {\n            return (0, 0);\n        }\n        (claimed0, claimed1) = IPool(stakingToken).claimFees();\n        if (claimed0 > 0 || claimed1 > 0) {\n            uint256 _fees0 = fees0 + claimed0;\n            uint256 _fees1 = fees1 + claimed1;\n            (address _token0, address _token1) = IPool(stakingToken).tokens();\n            if (_fees0 > DURATION) {\n                fees0 = 0;\n                IERC20(_token0).safeApprove(feesVotingReward, _fees0);\n                IReward(feesVotingReward).notifyRewardAmount(_token0, _fees0);\n            } else {\n                fees0 = _fees0;\n            }\n            if (_fees1 > DURATION) {\n                fees1 = 0;\n                IERC20(_token1).safeApprove(feesVotingReward, _fees1);\n                IReward(feesVotingReward).notifyRewardAmount(_token1, _fees1);\n            } else {\n                fees1 = _fees1;\n            }\n\n            emit ClaimFees(_msgSender(), claimed0, claimed1);\n        }\n    }\n\n    /// @inheritdoc IGauge\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored +\n            ((lastTimeRewardApplicable() - lastUpdateTime) *\n                rewardRate *\n                PRECISION) /\n            totalSupply;\n    }\n\n    /// @inheritdoc IGauge\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    /// @inheritdoc IGauge\n    function getReward(address _account) external nonReentrant {\n        address sender = _msgSender();\n        if (sender != _account && sender != voter) revert NotAuthorized();\n\n        _updateRewards(_account);\n\n        uint256 reward = rewards[_account];\n        if (reward > 0) {\n            rewards[_account] = 0;\n            IERC20(rewardToken).safeTransfer(_account, reward);\n            emit ClaimRewards(_account, reward);\n        }\n    }\n\n    /// @inheritdoc IGauge\n    function earned(address _account) public view returns (uint256) {\n        return\n            (balanceOf[_account] *\n                (rewardPerToken() - userRewardPerTokenPaid[_account])) /\n            PRECISION +\n            rewards[_account];\n    }\n\n    /// @inheritdoc IGauge\n    function deposit(uint256 _amount) external {\n        _depositFor(_amount, _msgSender());\n    }\n\n    /// @inheritdoc IGauge\n    function deposit(uint256 _amount, address _recipient) external {\n        _depositFor(_amount, _recipient);\n    }\n\n    function _depositFor(\n        uint256 _amount,\n        address _recipient\n    ) internal nonReentrant {\n        if (_amount == 0) revert ZeroAmount();\n        if (!IVoter(voter).isAlive(address(this))) revert NotAlive();\n\n        address sender = _msgSender();\n        _updateRewards(_recipient);\n\n        IERC20(stakingToken).safeTransferFrom(sender, address(this), _amount);\n        totalSupply += _amount;\n        balanceOf[_recipient] += _amount;\n\n        emit Deposit(sender, _recipient, _amount);\n    }\n\n    /// @inheritdoc IGauge\n    function withdraw(uint256 _amount) external nonReentrant {\n        address sender = _msgSender();\n\n        _updateRewards(sender);\n\n        totalSupply -= _amount;\n        balanceOf[sender] -= _amount;\n        IERC20(stakingToken).safeTransfer(sender, _amount);\n\n        emit Withdraw(sender, _amount);\n    }\n\n    function _updateRewards(address _account) internal {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        rewards[_account] = earned(_account);\n        userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n    }\n\n    /// @inheritdoc IGauge\n    function left() external view returns (uint256) {\n        if (block.timestamp >= periodFinish) return 0;\n        uint256 _remaining = periodFinish - block.timestamp;\n        return _remaining * rewardRate;\n    }\n\n    /// @inheritdoc IGauge\n    function notifyRewardAmount(uint256 _amount) external nonReentrant {\n        address sender = _msgSender();\n        if (sender != voter) revert NotVoter();\n        if (_amount == 0) revert ZeroAmount();\n        _claimFees();\n        _notifyRewardAmount(sender, _amount);\n    }\n\n    /// @inheritdoc IGauge\n    function notifyRewardWithoutClaim(uint256 _amount) external nonReentrant {\n        address sender = _msgSender();\n        if (sender != IVotingEscrow(ve).team()) revert NotTeam();\n        if (_amount == 0) revert ZeroAmount();\n        _notifyRewardAmount(sender, _amount);\n    }\n\n    function _notifyRewardAmount(address sender, uint256 _amount) internal {\n        rewardPerTokenStored = rewardPerToken();\n        uint256 timestamp = block.timestamp;\n        uint256 timeUntilNext = ProtocolTimeLibrary.epochNext(timestamp) -\n            timestamp;\n\n        if (timestamp >= periodFinish) {\n            IERC20(rewardToken).safeTransferFrom(\n                sender,\n                address(this),\n                _amount\n            );\n            rewardRate = _amount / timeUntilNext;\n        } else {\n            uint256 _remaining = periodFinish - timestamp;\n            uint256 _leftover = _remaining * rewardRate;\n            IERC20(rewardToken).safeTransferFrom(\n                sender,\n                address(this),\n                _amount\n            );\n            rewardRate = (_amount + _leftover) / timeUntilNext;\n        }\n        rewardRateByEpoch[\n            ProtocolTimeLibrary.epochStart(timestamp)\n        ] = rewardRate;\n        if (rewardRate == 0) revert ZeroRewardRate();\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint256 balance = IERC20(rewardToken).balanceOf(address(this));\n        if (rewardRate > balance / timeUntilNext) revert RewardRateTooHigh();\n\n        lastUpdateTime = timestamp;\n        periodFinish = timestamp + timeUntilNext;\n        emit NotifyReward(sender, _amount);\n    }\n}\n"
    },
    "contracts/governance/GovernorCountingMajority.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {GovernorSimple} from \"./GovernorSimple.sol\";\n\n/**\n * @dev Modified lightly from OpenZeppelin's GovernorCountingSimple to support a simple three option majority.\n *\n */\nabstract contract GovernorCountingMajority is GovernorSimple {\n    /**\n     * @dev Supported vote types. Matches Governor Bravo ordering.\n     */\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(uint256 => bool) hasVoted;\n    }\n\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    /**\n     * @dev See {IGovernor-COUNTING_MODE}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE()\n        public\n        pure\n        virtual\n        override\n        returns (string memory)\n    {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    /**\n     * @dev See {IGovernor-hasVoted}.\n     */\n    function hasVoted(\n        uint256 proposalId,\n        uint256 tokenId\n    ) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[tokenId];\n    }\n\n    /**\n     * @dev Accessor to the internal vote counts.\n     */\n    function proposalVotes(\n        uint256 proposalId\n    )\n        public\n        view\n        virtual\n        returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes)\n    {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n        return (\n            proposalVote.againstVotes,\n            proposalVote.forVotes,\n            proposalVote.abstainVotes\n        );\n    }\n\n    /**\n     * @dev Select winner of majority vote.\n     */\n    function _selectWinner(\n        uint256 proposalId\n    ) internal view override returns (ProposalState) {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n        uint256 againstVotes = proposalVote.againstVotes;\n        uint256 forVotes = proposalVote.forVotes;\n        uint256 abstainVotes = proposalVote.abstainVotes;\n        if ((againstVotes > forVotes) && (againstVotes > abstainVotes)) {\n            return ProposalState.Defeated;\n        } else if ((forVotes > againstVotes) && (forVotes > abstainVotes)) {\n            return ProposalState.Succeeded;\n        } else {\n            return ProposalState.Expired;\n        }\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).\n     */\n    function _countVote(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support,\n        uint256 weight,\n        bytes memory // params\n    ) internal virtual override {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n\n        require(\n            !proposalVote.hasVoted[tokenId],\n            \"GovernorVotingSimple: vote already cast\"\n        );\n        require(weight > 0, \"GovernorVotingSimple: zero voting weight\");\n        proposalVote.hasVoted[tokenId] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalVote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalVote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalVote.abstainVotes += weight;\n        } else {\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\n        }\n    }\n}\n"
    },
    "contracts/governance/GovernorSimple.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport {ERC165, IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {IERC6372} from \"@openzeppelin/contracts/interfaces/IERC6372.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {DoubleEndedQueue} from \"@openzeppelin/contracts/utils/structs/DoubleEndedQueue.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ERC2771Context} from \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\nimport {Timers} from \"@openzeppelin/contracts/utils/Timers.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {IGovernor} from \"./IGovernor.sol\";\nimport {ISplitter} from \"../interfaces/ISplitter.sol\";\nimport {ProtocolTimeLibrary} from \"../libraries/ProtocolTimeLibrary.sol\";\n\n/**\n * @dev Modified lightly from OpenZeppelin's Governor contract to support three option voting via callback.\n * A counting module is only required to implement _selectWinner and _countVote.\n * Adheres to IGovernor interface, with the following changes:\n * - hashProposal(...) generates a hash that allows for only one proposal per epoch\n * - state(...) returns a simple majority\n * - _selectWinner(...) returns simple majority winner from the three outcomes.\n * - execute(...) requires one of three states (Suceeded, Defeated, Expired) to execute.\n * - execute(...) sets the result based on the current epoch.\n * - cancel(...) does not exist by default (Modified from OZ's IGovernor).\n *\n * propose(...) creates a proposal for the following epoch. This proposal can only be executed during that epoch.\n */\nabstract contract GovernorSimple is\n    ERC2771Context,\n    ERC165,\n    EIP712,\n    IGovernor,\n    IERC721Receiver,\n    IERC1155Receiver\n{\n    using DoubleEndedQueue for DoubleEndedQueue.Bytes32Deque;\n    using SafeCast for uint256;\n\n    bytes32 public constant BALLOT_TYPEHASH =\n        keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n    bytes32 public constant EXTENDED_BALLOT_TYPEHASH =\n        keccak256(\n            \"ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params)\"\n        );\n\n    // solhint-disable var-name-mixedcase\n    struct ProposalCore {\n        // --- start retyped from Timers.BlockNumber at offset 0x00 ---\n        uint64 voteStart;\n        address proposer;\n        bytes4 __gap_unused0;\n        // --- start retyped from Timers.BlockNumber at offset 0x20 ---\n        uint64 voteEnd;\n        bytes24 __gap_unused1;\n        // --- Remaining fields starting at offset 0x40 ---------------\n        bool executed;\n        bool canceled;\n    }\n    // solhint-enable var-name-mixedcase\n\n    string private _name;\n    address public splitter;\n\n    mapping(uint256 => ProposalCore) private _proposals;\n\n    /// @dev Stores most recent voting result. Will be either Defeated, Succeeded or Expired.\n    ///      Any contracts that wish to use this governor must read from this to determine results.\n    ProposalState public result;\n\n    // This queue keeps track of the governor operating on itself. Calls to functions protected by the\n    // {onlyGovernance} modifier needs to be whitelisted in this queue. Whitelisting is set in {_beforeExecute},\n    // consumed by the {onlyGovernance} modifier and eventually reset in {_afterExecute}. This ensures that the\n    // execution of {onlyGovernance} protected calls can only be achieved through successful proposals.\n    DoubleEndedQueue.Bytes32Deque private _governanceCall;\n\n    /**\n     * @dev Restricts a function so it can only be executed through governance proposals. For example, governance\n     * parameter setters in {GovernorSettings} are protected using this modifier.\n     *\n     * The governance executing address may be different from the Governor's own address, for example it could be a\n     * timelock. This can be customized by modules by overriding {_executor}. The executor is only able to invoke these\n     * functions during the execution of the governor's {execute} function, and not under any other circumstances. Thus,\n     * for example, additional timelock proposers are not able to change governance parameters without going through the\n     * governance protocol (since v4.6).\n     */\n    modifier onlyGovernance() {\n        require(_msgSender() == _executor(), \"GovernorSimple: onlyGovernance\");\n        if (_executor() != address(this)) {\n            bytes32 msgDataHash = keccak256(_msgData());\n            // loop until popping the expected operation - throw if deque is empty (operation not authorized)\n            while (_governanceCall.popFront() != msgDataHash) {}\n        }\n        _;\n    }\n\n    /**\n     * @dev Sets the value for {name} and {version}, and sets up meta-tx\n     */\n    constructor(\n        address forwarder_,\n        string memory name_,\n        address splitter_\n    ) ERC2771Context(forwarder_) EIP712(name_, version()) {\n        _name = name_;\n        splitter = splitter_;\n    }\n\n    /**\n     * @dev Function to receive ETH that will be handled by the governor (disabled if executor is a third party contract)\n     */\n    receive() external payable virtual {\n        require(_executor() == address(this));\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(IERC165, ERC165) returns (bool) {\n        // In addition to the current interfaceId, also support previous version of the interfaceId that did not\n        // include the castVoteWithReasonAndParams() function as standard\n        return\n            interfaceId ==\n            (type(IGovernor).interfaceId ^\n                type(IERC6372).interfaceId ^\n                this.castVoteWithReasonAndParams.selector ^\n                this.castVoteWithReasonAndParamsBySig.selector ^\n                this.getVotesWithParams.selector) ||\n            // Previous interface for backwards compatibility\n            interfaceId ==\n            (type(IGovernor).interfaceId ^ type(IERC6372).interfaceId) ||\n            interfaceId == type(IERC1155Receiver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IGovernor-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IGovernor-version}.\n     */\n    function version() public view virtual override returns (string memory) {\n        return \"1\";\n    }\n\n    /**\n     * @dev See {IGovernor-hashProposal}.\n     *\n     * The proposal id is produced by hashing the ABI encoded `targets` array, the `values` array, the `calldatas` array\n     * and the descriptionHash (bytes32 which itself is the keccak256 hash of the description string). This proposal id\n     * can be produced from the proposal data which is part of the {ProposalCreated} event. It can even be computed in\n     * advance, before the proposal is submitted.\n     *\n     * Note that the chainId and the governor address are not part of the proposal id computation. Consequently, the\n     * same proposal (with same operation and same description) will have the same id if submitted on multiple governors\n     * across multiple networks. This also means that in order to execute the same operation twice (on the same\n     * governor) the proposer will have to change the description in order to avoid proposal id conflicts.\n     *\n     * The proposal id ignores description hash and uses the epoch start time for the following week. This ensures that only\n     * one proposal can be created per week.\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 epochStart\n    ) public pure virtual override returns (uint256) {\n        return\n            uint256(\n                keccak256(abi.encode(targets, values, calldatas, epochStart))\n            );\n    }\n\n    /**\n     * @dev See {IGovernor-state}.\n     */\n    function state(\n        uint256 proposalId\n    ) public view virtual override returns (ProposalState) {\n        ProposalCore storage proposal = _proposals[proposalId];\n\n        if (proposal.executed) {\n            return ProposalState.Executed;\n        }\n\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        }\n\n        uint256 snapshot = proposalSnapshot(proposalId);\n\n        if (snapshot == 0) {\n            revert(\"GovernorSimple: unknown proposal id\");\n        }\n\n        uint256 currentTimepoint = clock();\n\n        if (snapshot >= currentTimepoint) {\n            return ProposalState.Pending;\n        }\n\n        uint256 deadline = proposalDeadline(proposalId);\n\n        if (deadline >= currentTimepoint) {\n            return ProposalState.Active;\n        }\n\n        return _selectWinner(proposalId);\n    }\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.\n     */\n    function proposalThreshold() public view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev Select winner of majority vote.\n     */\n    function _selectWinner(\n        uint256 proposalId\n    ) internal view virtual returns (ProposalState);\n\n    /**\n     * @dev See {IGovernor-proposalSnapshot}.\n     */\n    function proposalSnapshot(\n        uint256 proposalId\n    ) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteStart;\n    }\n\n    /**\n     * @dev See {IGovernor-proposalDeadline}.\n     */\n    function proposalDeadline(\n        uint256 proposalId\n    ) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteEnd;\n    }\n\n    /**\n     * @dev Address of the proposer\n     */\n    function _proposalProposer(\n        uint256 proposalId\n    ) internal view virtual returns (address) {\n        return _proposals[proposalId].proposer;\n    }\n\n    /**\n     * @dev Get the voting weight of `tokenId`, owned by `account` at a specific `timepoint`, for a vote as described by `params`.\n     */\n    function _getVotes(\n        address account,\n        uint256 tokenId,\n        uint256 timepoint,\n        bytes memory params\n    ) internal view virtual returns (uint256);\n\n    /**\n     * @dev Register a vote for `proposalId` by `tokenId` with a given `support`, voting `weight` and voting `params`.\n     *\n     * Note: Support is generic and can represent various things depending on the voting system used.\n     */\n    function _countVote(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support,\n        uint256 weight,\n        bytes memory params\n    ) internal virtual;\n\n    /**\n     * @dev Default additional encoded parameters used by castVote methods that don't include them\n     *\n     * Note: Should be overridden by specific implementations to use an appropriate value, the\n     * meaning of the additional params, in the context of that implementation\n     */\n    function _defaultParams() internal view virtual returns (bytes memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IGovernor-propose}.\n     * description is ignored. The proposalId is created using the following epoch's start date.\n     */\n    function propose(\n        uint256 tokenId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override returns (uint256) {\n        address proposer = _msgSender();\n        uint256 currentTimepoint = clock();\n\n        require(\n            getVotes(proposer, tokenId, currentTimepoint - 1) >=\n                proposalThreshold(),\n            \"GovernorSimple: proposer votes below proposal threshold\"\n        );\n        require(targets.length == 1, \"GovernorSimple: only one target allowed\");\n        require(\n            address(targets[0]) == splitter,\n            \"GovernorSimple: only splitter allowed\"\n        );\n        require(\n            calldatas.length == 1,\n            \"GovernorSimple: only one calldata allowed\"\n        );\n        require(\n            bytes4(calldatas[0]) == ISplitter.nudge.selector,\n            \"GovernorSimple: only nudge allowed\"\n        );\n\n        bytes32 epochStart = bytes32(\n            ProtocolTimeLibrary.epochStart(block.timestamp) + (1 weeks)\n        );\n        uint256 proposalId = hashProposal(\n            targets,\n            values,\n            calldatas,\n            epochStart\n        );\n\n        require(targets.length > 0, \"GovernorSimple: empty proposal\");\n        require(\n            _proposals[proposalId].proposer == address(0),\n            \"GovernorSimple: proposal already exists\"\n        );\n\n        uint256 snapshot = currentTimepoint + votingDelay();\n        uint256 deadline = snapshot + votingPeriod();\n\n        _proposals[proposalId] = ProposalCore({\n            voteStart: snapshot.toUint64(),\n            proposer: proposer,\n            __gap_unused0: 0,\n            voteEnd: deadline.toUint64(),\n            __gap_unused1: 0,\n            executed: false,\n            canceled: false\n        });\n\n        emit ProposalCreated(\n            proposalId,\n            proposer,\n            targets,\n            values,\n            new string[](targets.length),\n            calldatas,\n            snapshot,\n            deadline,\n            Strings.toString(uint256(epochStart))\n        );\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-execute}.\n     * Executes a proposal with a start time at the beginning of this epoch.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual override returns (uint256) {\n        bytes32 epochStart = bytes32(\n            ProtocolTimeLibrary.epochStart(block.timestamp)\n        );\n        uint256 proposalId = hashProposal(\n            targets,\n            values,\n            calldatas,\n            epochStart\n        );\n\n        ProposalState status = state(proposalId);\n        require(\n            status == ProposalState.Succeeded ||\n                status == ProposalState.Defeated ||\n                status == ProposalState.Expired,\n            \"GovernorSimple: proposal not successful\"\n        );\n        _proposals[proposalId].executed = true;\n\n        emit ProposalExecuted(proposalId);\n\n        result = status;\n\n        _beforeExecute(proposalId, targets, values, calldatas, descriptionHash);\n        _execute(proposalId, targets, values, calldatas, descriptionHash);\n        _afterExecute(proposalId, targets, values, calldatas, descriptionHash);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Internal execution mechanism. Can be overridden to implement different execution mechanism\n     */\n    function _execute(\n        uint256 /* proposalId */,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        string memory errorMessage = \"Governor: call reverted without message\";\n        uint256 _length = targets.length;\n        for (uint256 i = 0; i < _length; ++i) {\n            (bool success, bytes memory returndata) = targets[i].call{\n                value: values[i]\n            }(calldatas[i]);\n            Address.verifyCallResult(success, returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Hook before execution is triggered.\n     */\n    function _beforeExecute(\n        uint256 /* proposalId */,\n        address[] memory targets,\n        uint256[] memory /* values */,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        if (_executor() != address(this)) {\n            uint256 _length = targets.length;\n            for (uint256 i = 0; i < _length; ++i) {\n                if (targets[i] == address(this)) {\n                    _governanceCall.pushBack(keccak256(calldatas[i]));\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Hook after execution is triggered.\n     */\n    function _afterExecute(\n        uint256 /* proposalId */,\n        address[] memory /* targets */,\n        uint256[] memory /* values */,\n        bytes[] memory /* calldatas */,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        if (_executor() != address(this)) {\n            if (!_governanceCall.empty()) {\n                _governanceCall.clear();\n            }\n        }\n    }\n\n    /**\n     * @dev See {IGovernor-getVotes}.\n     */\n    function getVotes(\n        address account,\n        uint256 tokenId,\n        uint256 timepoint\n    ) public view virtual override returns (uint256) {\n        return _getVotes(account, tokenId, timepoint, _defaultParams());\n    }\n\n    /**\n     * @dev See {IGovernor-getVotesWithParams}.\n     */\n    function getVotesWithParams(\n        address account,\n        uint256 tokenId,\n        uint256 timepoint,\n        bytes memory params\n    ) public view virtual override returns (uint256) {\n        return _getVotes(account, tokenId, timepoint, params);\n    }\n\n    /**\n     * @dev See {IGovernor-castVote}.\n     */\n    function castVote(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support\n    ) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, tokenId, support, \"\");\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReason}.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support,\n        string calldata reason\n    ) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, tokenId, support, reason);\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReasonAndParams}.\n     */\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, tokenId, support, reason, params);\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteBySig}.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override returns (uint256) {\n        address voter = ECDSA.recover(\n            _hashTypedDataV4(\n                keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))\n            ),\n            v,\n            r,\n            s\n        );\n        return _castVote(proposalId, voter, tokenId, support, \"\");\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReasonAndParamsBySig}.\n     */\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override returns (uint256) {\n        address voter = ECDSA.recover(\n            _hashTypedDataV4(\n                keccak256(\n                    abi.encode(\n                        EXTENDED_BALLOT_TYPEHASH,\n                        proposalId,\n                        support,\n                        keccak256(bytes(reason)),\n                        keccak256(params)\n                    )\n                )\n            ),\n            v,\n            r,\n            s\n        );\n\n        return _castVote(proposalId, voter, tokenId, support, reason, params);\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function. Uses the _defaultParams().\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint256 tokenId,\n        uint8 support,\n        string memory reason\n    ) internal virtual returns (uint256) {\n        return\n            _castVote(\n                proposalId,\n                account,\n                tokenId,\n                support,\n                reason,\n                _defaultParams()\n            );\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function.\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint256 tokenId,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual returns (uint256) {\n        ProposalCore storage proposal = _proposals[proposalId];\n        require(\n            state(proposalId) == ProposalState.Active,\n            \"GovernorSimple: vote not currently active\"\n        );\n\n        uint256 weight = _getVotes(\n            account,\n            tokenId,\n            proposal.voteStart,\n            params\n        );\n        _countVote(proposalId, tokenId, support, weight, params);\n\n        if (params.length == 0) {\n            emit VoteCast(\n                account,\n                tokenId,\n                proposalId,\n                support,\n                weight,\n                reason\n            );\n        } else {\n            emit VoteCastWithParams(\n                account,\n                tokenId,\n                proposalId,\n                support,\n                weight,\n                reason,\n                params\n            );\n        }\n\n        return weight;\n    }\n\n    /**\n     * @dev Address through which the governor executes action. Will be overloaded by module that execute actions\n     * through another contract such as a timelock.\n     */\n    function _executor() internal view virtual returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @dev Dummy quorum function to comply with IGovernor as quorum is not used.\n     */\n    function quorum(\n        uint256 blockNumber\n    ) public view override returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/governance/GovernorSimpleVotes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IERC6372} from \"@openzeppelin/contracts/interfaces/IERC6372.sol\";\nimport {IVotes} from \"./IVotes.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {GovernorSimple} from \"./GovernorSimple.sol\";\n\n/**\n * @dev Modified lightly from OpenZeppelin's GovernorVotes\n */\nabstract contract GovernorSimpleVotes is GovernorSimple {\n    IVotes public immutable token;\n\n    constructor(IVotes tokenAddress) {\n        token = IVotes(address(tokenAddress));\n    }\n\n    /**\n     * @dev Clock (as specified in EIP-6372) is set to match the token's clock. Fallback to block numbers if the token\n     * does not implement EIP-6372.\n     */\n    function clock() public view virtual override returns (uint48) {\n        try IERC6372(address(token)).clock() returns (uint48 timepoint) {\n            return timepoint;\n        } catch {\n            return SafeCast.toUint48(block.number);\n        }\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory) {\n        try IERC6372(address(token)).CLOCK_MODE() returns (\n            string memory clockmode\n        ) {\n            return clockmode;\n        } catch {\n            return \"mode=blocknumber&from=default\";\n        }\n    }\n\n    /**\n     * Read the voting weight from the token's built in snapshot mechanism (see {Governor-_getVotes}).\n     */\n    function _getVotes(\n        address account,\n        uint256 tokenId,\n        uint256 timepoint,\n        bytes memory /*params*/\n    ) internal view virtual override returns (uint256) {\n        return token.getPastVotes(account, tokenId, timepoint);\n    }\n}\n"
    },
    "contracts/governance/IGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {IERC6372} from \"@openzeppelin/contracts/interfaces/IERC6372.sol\";\n\n/**\n * @dev Taken from OpenZeppelin's IGovernor. Excludes `cancel`.\n */\nabstract contract IGovernor is IERC165, IERC6372 {\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    /**\n     * @dev Emitted when a proposal is created.\n     */\n    event ProposalCreated(\n        uint256 proposalId,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 voteStart,\n        uint256 voteEnd,\n        string description\n    );\n\n    /**\n     * @dev Emitted when a proposal is canceled.\n     */\n    event ProposalCanceled(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a proposal is executed.\n     */\n    event ProposalExecuted(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a vote is cast without params.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     */\n    event VoteCast(\n        address indexed voter,\n        uint256 indexed tokenId,\n        uint256 proposalId,\n        uint8 support,\n        uint256 weight,\n        string reason\n    );\n\n    /**\n     * @dev Emitted when a vote is cast with params.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     * `params` are additional encoded parameters. Their interpepretation also depends on the voting module used.\n     */\n    event VoteCastWithParams(\n        address indexed voter,\n        uint256 indexed tokenId,\n        uint256 proposalId,\n        uint8 support,\n        uint256 weight,\n        string reason,\n        bytes params\n    );\n\n    /**\n     * @notice module:core\n     * @dev Name of the governor instance (used in building the ERC712 domain separator).\n     */\n    function name() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Version of the governor instance (used in building the ERC712 domain separator). Default: \"1\"\n     */\n    function version() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev See {IERC6372}\n     */\n    function clock() public view virtual override returns (uint48);\n\n    /**\n     * @notice module:core\n     * @dev See EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory);\n\n    /**\n     * @notice module:voting\n     * @dev A description of the possible `support` values for {castVote} and the way these votes are counted, meant to\n     * be consumed by UIs to show correct vote options and interpret the results. The string is a URL-encoded sequence of\n     * key-value pairs that each describe one aspect, for example `support=bravo&quorum=for,abstain`.\n     *\n     * There are 2 standard keys: `support` and `quorum`.\n     *\n     * - `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in `GovernorBravo`.\n     * - `quorum=bravo` means that only For votes are counted towards quorum.\n     * - `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.\n     *\n     * If a counting module makes use of encoded `params`, it should  include this under a `params` key with a unique\n     * name that describes the behavior. For example:\n     *\n     * - `params=fractional` might refer to a scheme where votes are divided fractionally between for/against/abstain.\n     * - `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.\n     *\n     * NOTE: The string can be decoded by the standard\n     * https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams[`URLSearchParams`]\n     * JavaScript class.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Hashing function used to (re)build the proposal id from the proposal details..\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Current state of a proposal, following Compound's convention\n     */\n    function state(\n        uint256 proposalId\n    ) public view virtual returns (ProposalState);\n\n    /**\n     * @notice module:core\n     * @dev Timepoint used to retrieve user's votes and quorum. If using block number (as per Compound's Comp), the\n     * snapshot is performed at the end of this block. Hence, voting for this proposal starts at the beginning of the\n     * following block.\n     */\n    function proposalSnapshot(\n        uint256 proposalId\n    ) public view virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Timepoint at which votes close. If using block number, votes close at the end of this block, so it is\n     * possible to cast a vote during this block.\n     */\n    function proposalDeadline(\n        uint256 proposalId\n    ) public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay, between the proposal is created and the vote starts. The unit this duration is expressed in depends\n     * on the clock (see EIP-6372) this contract uses.\n     *\n     * This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a\n     * proposal starts.\n     */\n    function votingDelay() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay, between the vote start and vote ends. The unit this duration is expressed in depends on the clock\n     * (see EIP-6372) this contract uses.\n     *\n     * NOTE: The {votingDelay} can delay the start of the vote. This must be considered when setting the voting\n     * duration compared to the voting delay.\n     */\n    function votingPeriod() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Minimum number of cast voted required for a proposal to be successful.\n     *\n     * NOTE: The `timepoint` parameter corresponds to the snapshot used for counting vote. This allows to scale the\n     * quorum depending on values such as the totalSupply of a token at this timepoint (see {ERC20Votes}).\n     */\n    function quorum(uint256 timepoint) public view virtual returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `tokenId` at a specific `timepoint`.\n     *\n     * Note: this can be implemented in a number of ways, for example by reading the delegated balance from one (or\n     * multiple), {ERC20Votes} tokens.\n     */\n    function getVotes(\n        address account,\n        uint256 tokenId,\n        uint256 timepoint\n    ) public view virtual returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `tokenId` at a specific `timepoint` given additional encoded parameters.\n     */\n    function getVotesWithParams(\n        address account,\n        uint256 tokenId,\n        uint256 timepoint,\n        bytes memory params\n    ) public view virtual returns (uint256);\n\n    /**\n     * @notice module:voting\n     * @dev Returns whether `tokenId` has cast a vote on `proposalId`.\n     */\n    function hasVoted(\n        uint256 proposalId,\n        uint256 tokenId\n    ) public view virtual returns (bool);\n\n    /**\n     * @dev Create a new proposal. Vote start after a delay specified by {IGovernor-votingDelay} and lasts for a\n     * duration specified by {IGovernor-votingPeriod}.\n     *\n     * Emits a {ProposalCreated} event.\n     */\n    function propose(\n        uint256 tokenId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the\n     * deadline to be reached.\n     *\n     * Emits a {ProposalExecuted} event.\n     *\n     * Note: some module can modify the requirements for execution, for example by adding an additional timelock.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Cast a vote\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVote(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support,\n        string calldata reason\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason and additional encoded parameters\n     *\n     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.\n     */\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote using the user's cryptographic signature.\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason and additional encoded parameters using the user's cryptographic signature.\n     *\n     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.\n     */\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual returns (uint256 balance);\n}\n"
    },
    "contracts/governance/IVetoGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {IERC6372} from \"@openzeppelin/contracts/interfaces/IERC6372.sol\";\n\n/**\n * @dev Taken from OpenZeppelin's IGovernor.\n *      Includes support for veto-ing as mitigation against a 51% attack.\n */\nabstract contract IVetoGovernor is IERC165, IERC6372 {\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed,\n        Vetoed\n    }\n\n    /**\n     * @dev Emitted when a proposal is created.\n     */\n    event ProposalCreated(\n        uint256 proposalId,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 voteStart,\n        uint256 voteEnd,\n        string description\n    );\n\n    /**\n     * @dev Emitted when a proposal is canceled.\n     */\n    event ProposalCanceled(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a proposal is vetoed.\n     */\n    event ProposalVetoed(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a proposal is executed.\n     */\n    event ProposalExecuted(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a vote is cast without params.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     */\n    event VoteCast(\n        address indexed voter,\n        uint256 indexed tokenId,\n        uint256 proposalId,\n        uint8 support,\n        uint256 weight,\n        string reason\n    );\n\n    /**\n     * @dev Emitted when a vote is cast with params.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     * `params` are additional encoded parameters. Their interpepretation also depends on the voting module used.\n     */\n    event VoteCastWithParams(\n        address indexed voter,\n        uint256 indexed tokenId,\n        uint256 proposalId,\n        uint8 support,\n        uint256 weight,\n        string reason,\n        bytes params\n    );\n\n    /**\n     * @notice module:core\n     * @dev Name of the governor instance (used in building the ERC712 domain separator).\n     */\n    function name() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Version of the governor instance (used in building the ERC712 domain separator). Default: \"1\"\n     */\n    function version() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev See {IERC6372}\n     */\n    function clock() public view virtual override returns (uint48);\n\n    /**\n     * @notice module:core\n     * @dev See EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory);\n\n    /**\n     * @notice module:voting\n     * @dev A description of the possible `support` values for {castVote} and the way these votes are counted, meant to\n     * be consumed by UIs to show correct vote options and interpret the results. The string is a URL-encoded sequence of\n     * key-value pairs that each describe one aspect, for example `support=bravo&quorum=for,abstain`.\n     *\n     * There are 2 standard keys: `support` and `quorum`.\n     *\n     * - `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in `GovernorBravo`.\n     * - `quorum=bravo` means that only For votes are counted towards quorum.\n     * - `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.\n     *\n     * If a counting module makes use of encoded `params`, it should  include this under a `params` key with a unique\n     * name that describes the behavior. For example:\n     *\n     * - `params=fractional` might refer to a scheme where votes are divided fractionally between for/against/abstain.\n     * - `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.\n     *\n     * NOTE: The string can be decoded by the standard\n     * https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams[`URLSearchParams`]\n     * JavaScript class.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Hashing function used to (re)build the proposal id from the proposal details..\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash,\n        address proposer\n    ) public pure virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Current state of a proposal, following Compound's convention\n     */\n    function state(\n        uint256 proposalId\n    ) public view virtual returns (ProposalState);\n\n    /**\n     * @notice module:core\n     * @dev Timepoint used to retrieve user's votes and quorum. If using block number (as per Compound's Comp), the\n     * snapshot is performed at the end of this block. Hence, voting for this proposal starts at the beginning of the\n     * following block.\n     */\n    function proposalSnapshot(\n        uint256 proposalId\n    ) public view virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Timepoint at which votes close. If using block number, votes close at the end of this block, so it is\n     * possible to cast a vote during this block.\n     */\n    function proposalDeadline(\n        uint256 proposalId\n    ) public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay, between the proposal is created and the vote starts. The unit this duration is expressed in depends\n     * on the clock (see EIP-6372) this contract uses.\n     *\n     * This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a\n     * proposal starts.\n     */\n    function votingDelay() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay, between the vote start and vote ends. The unit this duration is expressed in depends on the clock\n     * (see EIP-6372) this contract uses.\n     *\n     * NOTE: The {votingDelay} can delay the start of the vote. This must be considered when setting the voting\n     * duration compared to the voting delay.\n     */\n    function votingPeriod() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Minimum number of cast voted required for a proposal to be successful.\n     *\n     * NOTE: The `timepoint` parameter corresponds to the snapshot used for counting vote. This allows to scale the\n     * quorum depending on values such as the totalSupply of a token at this timepoint (see {ERC20Votes}).\n     */\n    function quorum(uint256 timepoint) public view virtual returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `tokenId` at a specific `timepoint`.\n     *\n     * Note: this can be implemented in a number of ways, for example by reading the delegated balance from one (or\n     * multiple), {ERC20Votes} tokens.\n     */\n    function getVotes(\n        address account,\n        uint256 tokenId,\n        uint256 timepoint\n    ) public view virtual returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `tokenId` at a specific `timepoint` given additional encoded parameters.\n     */\n    function getVotesWithParams(\n        address account,\n        uint256 tokenId,\n        uint256 timepoint,\n        bytes memory params\n    ) public view virtual returns (uint256);\n\n    /**\n     * @notice module:voting\n     * @dev Returns whether `tokenId` has cast a vote on `proposalId`.\n     */\n    function hasVoted(\n        uint256 proposalId,\n        uint256 tokenId\n    ) public view virtual returns (bool);\n\n    /**\n     * @dev Create a new proposal. Vote start after a delay specified by {IGovernor-votingDelay} and lasts for a\n     * duration specified by {IGovernor-votingPeriod}.\n     *\n     * Emits a {ProposalCreated} event.\n     */\n    function propose(\n        uint256 tokenId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the\n     * deadline to be reached.\n     *\n     * Emits a {ProposalExecuted} event.\n     *\n     * Note: some module can modify the requirements for execution, for example by adding an additional timelock.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash,\n        address proposer\n    ) public payable virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Cancel a proposal. A proposal is cancellable by the proposer, but only while it is Pending state, i.e.\n     * before the vote starts.\n     *\n     * Emits a {ProposalCanceled} event.\n     */\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Cast a vote\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVote(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support,\n        string calldata reason\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason and additional encoded parameters\n     *\n     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.\n     */\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote using the user's cryptographic signature.\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason and additional encoded parameters using the user's cryptographic signature.\n     *\n     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.\n     */\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual returns (uint256 balance);\n}\n"
    },
    "contracts/governance/IVotes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/// Modified IVotes interface for tokenId based voting\ninterface IVotes {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(\n        address indexed delegator,\n        uint256 indexed fromDelegate,\n        uint256 indexed toDelegate\n    );\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(\n        address indexed delegate,\n        uint256 previousBalance,\n        uint256 newBalance\n    );\n\n    /**\n     * @dev Returns the amount of votes that `tokenId` had at a specific moment in the past.\n     *      If the account passed in is not the owner, returns 0.\n     */\n    function getPastVotes(\n        address account,\n        uint256 tokenId,\n        uint256 timepoint\n    ) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(\n        uint256 timepoint\n    ) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `tokenId` has chosen. Can never be equal to the delegator's `tokenId`.\n     *      Returns 0 if not delegated.\n     */\n    function delegates(uint256 tokenId) external view returns (uint256);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(uint256 delegator, uint256 delegatee) external;\n\n    /**\n     * @dev Delegates votes from `delegator` to `delegatee`. Signer must own `delegator`.\n     */\n    function delegateBySig(\n        uint256 delegator,\n        uint256 delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/governance/VetoGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (governance/Governor.sol)\n\npragma solidity 0.8.24;\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport {ERC165, IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {IERC6372} from \"@openzeppelin/contracts/interfaces/IERC6372.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {DoubleEndedQueue} from \"@openzeppelin/contracts/utils/structs/DoubleEndedQueue.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"./IVetoGovernor.sol\";\n\n/**\n * @dev Modified lightly from OpenZeppelin's Governor contract to support vetoing.\n */\nabstract contract VetoGovernor is\n    Context,\n    ERC165,\n    EIP712,\n    IVetoGovernor,\n    IERC721Receiver,\n    IERC1155Receiver\n{\n    using DoubleEndedQueue for DoubleEndedQueue.Bytes32Deque;\n    using SafeCast for uint256;\n\n    bytes32 public constant BALLOT_TYPEHASH =\n        keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n    bytes32 public constant EXTENDED_BALLOT_TYPEHASH =\n        keccak256(\n            \"ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params)\"\n        );\n\n    // solhint-disable var-name-mixedcase\n    struct ProposalCore {\n        // --- start retyped from Timers.BlockNumber at offset 0x00 ---\n        uint64 voteStart;\n        address proposer;\n        bytes4 __gap_unused0;\n        // --- start retyped from Timers.BlockNumber at offset 0x20 ---\n        uint64 voteEnd;\n        bytes24 __gap_unused1;\n        // --- Remaining fields starting at offset 0x40 ---------------\n        bool executed;\n        bool canceled;\n        bool vetoed;\n    }\n    // solhint-enable var-name-mixedcase\n\n    string private _name;\n\n    /// @custom:oz-retyped-from mapping(uint256 => Governor.ProposalCore)\n    mapping(uint256 => ProposalCore) private _proposals;\n\n    // This queue keeps track of the governor operating on itself. Calls to functions protected by the\n    // {onlyGovernance} modifier needs to be whitelisted in this queue. Whitelisting is set in {_beforeExecute},\n    // consumed by the {onlyGovernance} modifier and eventually reset in {_afterExecute}. This ensures that the\n    // execution of {onlyGovernance} protected calls can only be achieved through successful proposals.\n    DoubleEndedQueue.Bytes32Deque private _governanceCall;\n\n    /**\n     * @dev Restricts a function so it can only be executed through governance proposals. For example, governance\n     * parameter setters in {GovernorSettings} are protected using this modifier.\n     *\n     * The governance executing address may be different from the Governor's own address, for example it could be a\n     * timelock. This can be customized by modules by overriding {_executor}. The executor is only able to invoke these\n     * functions during the execution of the governor's {execute} function, and not under any other circumstances. Thus,\n     * for example, additional timelock proposers are not able to change governance parameters without going through the\n     * governance protocol (since v4.6).\n     */\n    modifier onlyGovernance() {\n        require(_msgSender() == _executor(), \"Governor: onlyGovernance\");\n        if (_executor() != address(this)) {\n            bytes32 msgDataHash = keccak256(_msgData());\n            // loop until popping the expected operation - throw if deque is empty (operation not authorized)\n            while (_governanceCall.popFront() != msgDataHash) {}\n        }\n        _;\n    }\n\n    /**\n     * @dev Sets the value for {name} and {version}\n     */\n    constructor(string memory name_) EIP712(name_, version()) {\n        _name = name_;\n    }\n\n    /**\n     * @dev Function to receive ETH that will be handled by the governor (disabled if executor is a third party contract)\n     */\n    receive() external payable virtual {\n        require(_executor() == address(this));\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(IERC165, ERC165) returns (bool) {\n        // In addition to the current interfaceId, also support previous version of the interfaceId that did not\n        // include the castVoteWithReasonAndParams() function as standard\n        return\n            interfaceId ==\n            (type(IVetoGovernor).interfaceId ^\n                type(IERC6372).interfaceId ^\n                this.cancel.selector ^\n                this.castVoteWithReasonAndParams.selector ^\n                this.castVoteWithReasonAndParamsBySig.selector ^\n                this.getVotesWithParams.selector) ||\n            // Previous interface for backwards compatibility\n            interfaceId ==\n            (type(IVetoGovernor).interfaceId ^\n                type(IERC6372).interfaceId ^\n                this.cancel.selector) ||\n            interfaceId == type(IERC1155Receiver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IVetoGovernor-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IVetoGovernor-version}.\n     */\n    function version() public view virtual override returns (string memory) {\n        return \"1\";\n    }\n\n    /**\n     * @dev See {IVetoGovernor-hashProposal}.\n     *\n     * The proposal id is produced by hashing the ABI encoded `targets` array, the `values` array, the `calldatas` array,\n     * the descriptionHash (bytes32 which itself is the keccak256 hash of the description string) and the `proposer` address.\n     * This proposal id can be produced from the proposal data which is part of the {ProposalCreated} event. It can even\n     * be computed in advance, before the proposal is submitted.\n     *\n     * Note that the chainId and the governor address are not part of the proposal id computation. Consequently, the\n     * same proposal (with same operation and same description) will have the same id if submitted on multiple governors\n     * across multiple networks. This also means that in order to execute the same operation twice (on the same\n     * governor) the proposer will have to change the description in order to avoid proposal id conflicts.\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash,\n        address proposer\n    ) public pure virtual override returns (uint256) {\n        return\n            uint256(\n                keccak256(\n                    abi.encode(\n                        targets,\n                        values,\n                        calldatas,\n                        descriptionHash,\n                        proposer\n                    )\n                )\n            );\n    }\n\n    /**\n     * @dev See {IVetoGovernor-state}.\n     */\n    function state(\n        uint256 proposalId\n    ) public view virtual override returns (ProposalState) {\n        ProposalCore storage proposal = _proposals[proposalId];\n\n        if (proposal.executed) {\n            return ProposalState.Executed;\n        }\n\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        }\n\n        if (proposal.vetoed) {\n            return ProposalState.Vetoed;\n        }\n\n        uint256 snapshot = proposalSnapshot(proposalId);\n\n        if (snapshot == 0) {\n            revert(\"Governor: unknown proposal id\");\n        }\n\n        uint256 currentTimepoint = clock();\n\n        if (snapshot >= currentTimepoint) {\n            return ProposalState.Pending;\n        }\n\n        uint256 deadline = proposalDeadline(proposalId);\n\n        if (deadline >= currentTimepoint) {\n            return ProposalState.Active;\n        }\n\n        if (_quorumReached(proposalId) && _voteSucceeded(proposalId)) {\n            return ProposalState.Succeeded;\n        } else {\n            return ProposalState.Defeated;\n        }\n    }\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.\n     */\n    function proposalThreshold() public view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev See {IVetoGovernor-proposalSnapshot}.\n     */\n    function proposalSnapshot(\n        uint256 proposalId\n    ) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteStart;\n    }\n\n    /**\n     * @dev See {IVetoGovernor-proposalDeadline}.\n     */\n    function proposalDeadline(\n        uint256 proposalId\n    ) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteEnd;\n    }\n\n    /**\n     * @dev Address of the proposer\n     */\n    function _proposalProposer(\n        uint256 proposalId\n    ) internal view virtual returns (address) {\n        return _proposals[proposalId].proposer;\n    }\n\n    /**\n     * @dev Amount of votes already cast passes the threshold limit.\n     */\n    function _quorumReached(\n        uint256 proposalId\n    ) internal view virtual returns (bool);\n\n    /**\n     * @dev Is the proposal successful or not.\n     */\n    function _voteSucceeded(\n        uint256 proposalId\n    ) internal view virtual returns (bool);\n\n    /**\n     * @dev Get the voting weight of `tokenId`, owned by `account` at a specific `timepoint`, for a vote as described by `params`.\n     */\n    function _getVotes(\n        address account,\n        uint256 tokenId,\n        uint256 timepoint,\n        bytes memory params\n    ) internal view virtual returns (uint256);\n\n    /**\n     * @dev Register a vote for `proposalId` by `tokenId` with a given `support`, voting `weight` and voting `params`.\n     *\n     * Note: Support is generic and can represent various things depending on the voting system used.\n     */\n    function _countVote(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support,\n        uint256 weight,\n        bytes memory params\n    ) internal virtual;\n\n    /**\n     * @dev Default additional encoded parameters used by castVote methods that don't include them\n     *\n     * Note: Should be overridden by specific implementations to use an appropriate value, the\n     * meaning of the additional params, in the context of that implementation\n     */\n    function _defaultParams() internal view virtual returns (bytes memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IVetoGovernor-propose}.\n     */\n    function propose(\n        uint256 tokenId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override returns (uint256) {\n        address proposer = _msgSender();\n        uint256 currentTimepoint = clock();\n\n        require(\n            getVotes(proposer, tokenId, currentTimepoint - 1) >=\n                proposalThreshold(),\n            \"Governor: proposer votes below proposal threshold\"\n        );\n\n        uint256 proposalId = hashProposal(\n            targets,\n            values,\n            calldatas,\n            keccak256(bytes(description)),\n            proposer\n        );\n\n        require(\n            targets.length == values.length,\n            \"Governor: invalid proposal length\"\n        );\n        require(\n            targets.length == calldatas.length,\n            \"Governor: invalid proposal length\"\n        );\n        require(targets.length > 0, \"Governor: empty proposal\");\n        require(\n            _proposals[proposalId].proposer == address(0),\n            \"Governor: proposal already exists\"\n        );\n\n        uint256 snapshot = currentTimepoint + votingDelay();\n        uint256 deadline = snapshot + votingPeriod();\n\n        _proposals[proposalId] = ProposalCore({\n            voteStart: snapshot.toUint64(),\n            proposer: proposer,\n            __gap_unused0: 0,\n            voteEnd: deadline.toUint64(),\n            __gap_unused1: 0,\n            executed: false,\n            canceled: false,\n            vetoed: false\n        });\n\n        emit ProposalCreated(\n            proposalId,\n            proposer,\n            targets,\n            values,\n            new string[](targets.length),\n            calldatas,\n            snapshot,\n            deadline,\n            description\n        );\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IVetoGovernor-execute}.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash,\n        address proposer\n    ) public payable virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(\n            targets,\n            values,\n            calldatas,\n            descriptionHash,\n            proposer\n        );\n\n        ProposalState status = state(proposalId);\n        require(\n            status == ProposalState.Succeeded || status == ProposalState.Queued,\n            \"Governor: proposal not successful\"\n        );\n        _proposals[proposalId].executed = true;\n\n        emit ProposalExecuted(proposalId);\n\n        _beforeExecute(proposalId, targets, values, calldatas, descriptionHash);\n        _execute(proposalId, targets, values, calldatas, descriptionHash);\n        _afterExecute(proposalId, targets, values, calldatas, descriptionHash);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IVetoGovernor-cancel}.\n     */\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual override returns (uint256) {\n        address proposer = _msgSender();\n        uint256 proposalId = hashProposal(\n            targets,\n            values,\n            calldatas,\n            descriptionHash,\n            proposer\n        );\n        require(\n            state(proposalId) == ProposalState.Pending,\n            \"Governor: too late to cancel\"\n        );\n        require(\n            proposer == _proposals[proposalId].proposer,\n            \"Governor: only proposer can cancel\"\n        );\n        return _cancel(targets, values, calldatas, descriptionHash, proposer);\n    }\n\n    /**\n     * @dev Internal execution mechanism. Can be overridden to implement different execution mechanism\n     */\n    function _execute(\n        uint256 /* proposalId */,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        string memory errorMessage = \"Governor: call reverted without message\";\n        uint256 _length = targets.length;\n        for (uint256 i = 0; i < _length; ++i) {\n            (bool success, bytes memory returndata) = targets[i].call{\n                value: values[i]\n            }(calldatas[i]);\n            Address.verifyCallResult(success, returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Hook before execution is triggered.\n     */\n    function _beforeExecute(\n        uint256 /* proposalId */,\n        address[] memory targets,\n        uint256[] memory /* values */,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        if (_executor() != address(this)) {\n            uint256 _length = targets.length;\n            for (uint256 i = 0; i < _length; ++i) {\n                if (targets[i] == address(this)) {\n                    _governanceCall.pushBack(keccak256(calldatas[i]));\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Hook after execution is triggered.\n     */\n    function _afterExecute(\n        uint256 /* proposalId */,\n        address[] memory /* targets */,\n        uint256[] memory /* values */,\n        bytes[] memory /* calldatas */,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        if (_executor() != address(this)) {\n            if (!_governanceCall.empty()) {\n                _governanceCall.clear();\n            }\n        }\n    }\n\n    /**\n     * @dev Internal veto mechanism: locks up the proposal timer, preventing it from being re-submitted. Marks it as\n     * veto to allow distinguishing it from executed and canceled proposals.\n     *\n     * Emits a {IVetoGovernor-ProposalVetoed} event.\n     */\n    function _veto(uint256 proposalId) internal returns (uint256) {\n        ProposalState status = state(proposalId);\n\n        require(\n            status != ProposalState.Vetoed &&\n                status != ProposalState.Canceled &&\n                status != ProposalState.Expired &&\n                status != ProposalState.Executed,\n            \"Governor: proposal not active\"\n        );\n        _proposals[proposalId].vetoed = true;\n\n        emit ProposalVetoed(proposalId);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Internal cancel mechanism: locks up the proposal timer, preventing it from being re-submitted. Marks it as\n     * canceled to allow distinguishing it from executed and canceled proposals.\n     *\n     * Emits a {IVetoGovernor-ProposalCanceled} event.\n     */\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash,\n        address proposer\n    ) internal virtual returns (uint256) {\n        uint256 proposalId = hashProposal(\n            targets,\n            values,\n            calldatas,\n            descriptionHash,\n            proposer\n        );\n\n        ProposalState status = state(proposalId);\n\n        require(\n            status != ProposalState.Vetoed &&\n                status != ProposalState.Canceled &&\n                status != ProposalState.Expired &&\n                status != ProposalState.Executed,\n            \"Governor: proposal not active\"\n        );\n        _proposals[proposalId].canceled = true;\n\n        emit ProposalCanceled(proposalId);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IVetoGovernor-getVotes}.\n     */\n    function getVotes(\n        address account,\n        uint256 tokenId,\n        uint256 timepoint\n    ) public view virtual override returns (uint256) {\n        return _getVotes(account, tokenId, timepoint, _defaultParams());\n    }\n\n    /**\n     * @dev See {IVetoGovernor-getVotesWithParams}.\n     */\n    function getVotesWithParams(\n        address account,\n        uint256 tokenId,\n        uint256 timepoint,\n        bytes memory params\n    ) public view virtual override returns (uint256) {\n        return _getVotes(account, tokenId, timepoint, params);\n    }\n\n    /**\n     * @dev See {IVetoGovernor-castVote}.\n     */\n    function castVote(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support\n    ) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, tokenId, support, \"\");\n    }\n\n    /**\n     * @dev See {IVetoGovernor-castVoteWithReason}.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support,\n        string calldata reason\n    ) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, tokenId, support, reason);\n    }\n\n    /**\n     * @dev See {IVetoGovernor-castVoteWithReasonAndParams}.\n     */\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, tokenId, support, reason, params);\n    }\n\n    /**\n     * @dev See {IVetoGovernor-castVoteBySig}.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override returns (uint256) {\n        address voter = ECDSA.recover(\n            _hashTypedDataV4(\n                keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))\n            ),\n            v,\n            r,\n            s\n        );\n        return _castVote(proposalId, voter, tokenId, support, \"\");\n    }\n\n    /**\n     * @dev See {IVetoGovernor-castVoteWithReasonAndParamsBySig}.\n     */\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override returns (uint256) {\n        address voter = ECDSA.recover(\n            _hashTypedDataV4(\n                keccak256(\n                    abi.encode(\n                        EXTENDED_BALLOT_TYPEHASH,\n                        proposalId,\n                        support,\n                        keccak256(bytes(reason)),\n                        keccak256(params)\n                    )\n                )\n            ),\n            v,\n            r,\n            s\n        );\n\n        return _castVote(proposalId, voter, tokenId, support, reason, params);\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IVetoGovernor-getVotes} and call the {_countVote} internal function. Uses the _defaultParams().\n     *\n     * Emits a {IVetoGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint256 tokenId,\n        uint8 support,\n        string memory reason\n    ) internal virtual returns (uint256) {\n        return\n            _castVote(\n                proposalId,\n                account,\n                tokenId,\n                support,\n                reason,\n                _defaultParams()\n            );\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IVetoGovernor-getVotes} and call the {_countVote} internal function.\n     *\n     * Emits a {IVetoGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint256 tokenId,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual returns (uint256) {\n        ProposalCore storage proposal = _proposals[proposalId];\n        require(\n            state(proposalId) == ProposalState.Active,\n            \"Governor: vote not currently active\"\n        );\n\n        uint256 weight = _getVotes(\n            account,\n            tokenId,\n            proposal.voteStart,\n            params\n        );\n        _countVote(proposalId, tokenId, support, weight, params);\n\n        if (params.length == 0) {\n            emit VoteCast(\n                account,\n                tokenId,\n                proposalId,\n                support,\n                weight,\n                reason\n            );\n        } else {\n            emit VoteCastWithParams(\n                account,\n                tokenId,\n                proposalId,\n                support,\n                weight,\n                reason,\n                params\n            );\n        }\n\n        return weight;\n    }\n\n    /**\n     * @dev Relays a transaction or function call to an arbitrary target. In cases where the governance executor\n     * is some contract other than the governor itself, like when using a timelock, this function can be invoked\n     * in a governance proposal to recover tokens or Ether that was sent to the governor contract by mistake.\n     * Note that if the executor is simply the governor itself, use of `relay` is redundant.\n     */\n    function relay(\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) external payable virtual onlyGovernance {\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        Address.verifyCallResult(\n            success,\n            returndata,\n            \"Governor: relay reverted without message\"\n        );\n    }\n\n    /**\n     * @dev Address through which the governor executes action. Will be overloaded by module that execute actions\n     * through another contract such as a timelock.\n     */\n    function _executor() internal view virtual returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "contracts/governance/VetoGovernorCountingSimple.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (governance/extensions/GovernorCountingSimple.sol)\n\npragma solidity 0.8.24;\n\nimport {VetoGovernor} from \"./VetoGovernor.sol\";\n\n/**\n * @dev OpenZeppelin's GovernorCountingSimple using VetoGovernor\n */\nabstract contract VetoGovernorCountingSimple is VetoGovernor {\n    /**\n     * @dev Supported vote types. Matches Governor Bravo ordering.\n     */\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(uint256 => bool) hasVoted;\n    }\n\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    /**\n     * @dev See {IGovernor-COUNTING_MODE}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE()\n        public\n        pure\n        virtual\n        override\n        returns (string memory)\n    {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    /**\n     * @dev See {IGovernor-hasVoted}.\n     */\n    function hasVoted(\n        uint256 proposalId,\n        uint256 tokenId\n    ) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[tokenId];\n    }\n\n    /**\n     * @dev Accessor to the internal vote counts.\n     */\n    function proposalVotes(\n        uint256 proposalId\n    )\n        public\n        view\n        virtual\n        returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes)\n    {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n        return (\n            proposalVote.againstVotes,\n            proposalVote.forVotes,\n            proposalVote.abstainVotes\n        );\n    }\n\n    /**\n     * @dev See {Governor-_quorumReached}.\n     */\n    function _quorumReached(\n        uint256 proposalId\n    ) internal view virtual override returns (bool) {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n\n        return\n            quorum(proposalSnapshot(proposalId)) <=\n            proposalVote.forVotes + proposalVote.abstainVotes;\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be strictly over the againstVotes.\n     */\n    function _voteSucceeded(\n        uint256 proposalId\n    ) internal view virtual override returns (bool) {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n\n        return proposalVote.forVotes > proposalVote.againstVotes;\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).\n     */\n    function _countVote(\n        uint256 proposalId,\n        uint256 tokenId,\n        uint8 support,\n        uint256 weight,\n        bytes memory // params\n    ) internal virtual override {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n\n        require(\n            !proposalVote.hasVoted[tokenId],\n            \"GovernorVotingSimple: vote already cast\"\n        );\n        require(weight > 0, \"GovernorVotingSimple: zero voting weight\");\n        proposalVote.hasVoted[tokenId] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalVote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalVote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalVote.abstainVotes += weight;\n        } else {\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\n        }\n    }\n}\n"
    },
    "contracts/governance/VetoGovernorVotes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (governance/extensions/GovernorVotes.sol)\n\npragma solidity 0.8.24;\n\nimport {VetoGovernor} from \"./VetoGovernor.sol\";\nimport {IERC6372} from \"@openzeppelin/contracts/interfaces/IERC6372.sol\";\nimport {IVotes} from \"./IVotes.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/**\n * @dev OpenZeppelin's GovernorVotes using VetoGovernor\n */\nabstract contract VetoGovernorVotes is VetoGovernor {\n    IVotes public immutable token;\n\n    constructor(IVotes tokenAddress) {\n        token = IVotes(address(tokenAddress));\n    }\n\n    /**\n     * @dev Clock (as specified in EIP-6372) is set to match the token's clock. Fallback to block numbers if the token\n     * does not implement EIP-6372.\n     */\n    function clock() public view virtual override returns (uint48) {\n        try IERC6372(address(token)).clock() returns (uint48 timepoint) {\n            return timepoint;\n        } catch {\n            return SafeCast.toUint48(block.number);\n        }\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory) {\n        try IERC6372(address(token)).CLOCK_MODE() returns (\n            string memory clockmode\n        ) {\n            return clockmode;\n        } catch {\n            return \"mode=blocknumber&from=default\";\n        }\n    }\n\n    /**\n     * Read the voting weight from the token's built in snapshot mechanism (see {Governor-_getVotes}).\n     */\n    function _getVotes(\n        address account,\n        uint256 tokenId,\n        uint256 timepoint,\n        bytes memory /*params*/\n    ) internal view virtual override returns (uint256) {\n        return token.getPastVotes(account, tokenId, timepoint);\n    }\n}\n"
    },
    "contracts/governance/VetoGovernorVotesQuorumFraction.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (governance/extensions/GovernorVotesQuorumFraction.sol)\n\npragma solidity 0.8.24;\n\nimport {VetoGovernorVotes} from \"./VetoGovernorVotes.sol\";\nimport {Checkpoints} from \"@openzeppelin/contracts/utils/Checkpoints.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/**\n * @dev OpenZeppelin's GovernorVotesQuorumFraction using VetoGovernor\n */\nabstract contract VetoGovernorVotesQuorumFraction is VetoGovernorVotes {\n    using SafeCast for *;\n    using Checkpoints for Checkpoints.Trace224;\n\n    uint256 private _quorumNumerator; // DEPRECATED in favor of _quorumNumeratorHistory\n\n    /// @custom:oz-retyped-from Checkpoints.History\n    Checkpoints.Trace224 private _quorumNumeratorHistory;\n\n    event QuorumNumeratorUpdated(\n        uint256 oldQuorumNumerator,\n        uint256 newQuorumNumerator\n    );\n\n    /**\n     * @dev Initialize quorum as a fraction of the token's total supply.\n     *\n     * The fraction is specified as `numerator / denominator`. By default the denominator is 100, so quorum is\n     * specified as a percent: a numerator of 10 corresponds to quorum being 10% of total supply. The denominator can be\n     * customized by overriding {quorumDenominator}.\n     */\n    constructor(uint256 quorumNumeratorValue) {\n        _updateQuorumNumerator(quorumNumeratorValue);\n    }\n\n    /**\n     * @dev Returns the current quorum numerator. See {quorumDenominator}.\n     */\n    function quorumNumerator() public view virtual returns (uint256) {\n        return\n            _quorumNumeratorHistory._checkpoints.length == 0\n                ? _quorumNumerator\n                : _quorumNumeratorHistory.latest();\n    }\n\n    /**\n     * @dev Returns the quorum numerator at a specific timepoint. See {quorumDenominator}.\n     */\n    function quorumNumerator(\n        uint256 timepoint\n    ) public view virtual returns (uint256) {\n        // If history is empty, fallback to old storage\n        uint256 length = _quorumNumeratorHistory._checkpoints.length;\n        if (length == 0) {\n            return _quorumNumerator;\n        }\n\n        // Optimistic search, check the latest checkpoint\n        Checkpoints.Checkpoint224 memory latest = _quorumNumeratorHistory\n            ._checkpoints[length - 1];\n        if (latest._key <= timepoint) {\n            return latest._value;\n        }\n\n        // Otherwise, do the binary search\n        return _quorumNumeratorHistory.upperLookupRecent(timepoint.toUint32());\n    }\n\n    /**\n     * @dev Returns the quorum denominator. Defaults to 100, but may be overridden.\n     */\n    function quorumDenominator() public view virtual returns (uint256) {\n        return 100;\n    }\n\n    /**\n     * @dev Returns the quorum for a timepoint, in terms of number of votes: `supply * numerator / denominator`.\n     */\n    function quorum(\n        uint256 timepoint\n    ) public view virtual override returns (uint256) {\n        return\n            (token.getPastTotalSupply(timepoint) * quorumNumerator(timepoint)) /\n            quorumDenominator();\n    }\n\n    /**\n     * @dev Changes the quorum numerator.\n     *\n     * Emits a {QuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - Must be called through a governance proposal.\n     * - New numerator must be smaller or equal to the denominator.\n     */\n    function updateQuorumNumerator(\n        uint256 newQuorumNumerator\n    ) external virtual onlyGovernance {\n        _updateQuorumNumerator(newQuorumNumerator);\n    }\n\n    /**\n     * @dev Changes the quorum numerator.\n     *\n     * Emits a {QuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - New numerator must be smaller or equal to the denominator.\n     */\n    function _updateQuorumNumerator(\n        uint256 newQuorumNumerator\n    ) internal virtual {\n        require(\n            newQuorumNumerator <= quorumDenominator(),\n            \"GovernorVotesQuorumFraction: quorumNumerator over quorumDenominator\"\n        );\n\n        uint256 oldQuorumNumerator = quorumNumerator();\n\n        // Make sure we keep track of the original numerator in contracts upgraded from a version without checkpoints.\n        if (\n            oldQuorumNumerator != 0 &&\n            _quorumNumeratorHistory._checkpoints.length == 0\n        ) {\n            _quorumNumeratorHistory._checkpoints.push(\n                Checkpoints.Checkpoint224({\n                    _key: 0,\n                    _value: oldQuorumNumerator.toUint224()\n                })\n            );\n        }\n\n        // Set new quorum for future proposals\n        _quorumNumeratorHistory.push(\n            clock().toUint32(),\n            newQuorumNumerator.toUint224()\n        );\n\n        emit QuorumNumeratorUpdated(oldQuorumNumerator, newQuorumNumerator);\n    }\n}\n"
    },
    "contracts/interfaces/factories/IAutoCompounderFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.24;\n\ninterface IAutoCompounderFactory {\n    event SetRewardAmount(uint256 amount);\n    event CreateAutoCompounder(\n        address created,\n        address admin,\n        address autoCompounder\n    );\n\n    error TokenIdZero();\n    error TokenIdNotApproved();\n    error TokenIdNotManaged();\n    error NotTeam();\n    error AmountSame();\n    error AmountOutOfAcceptableRange();\n\n    function rewardAmount() external returns (uint256);\n}\n"
    },
    "contracts/interfaces/factories/IFactoryRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\ninterface IFactoryRegistry {\n    error FallbackFactory();\n    error InvalidFactoriesToPoolFactory();\n    error PathAlreadyApproved();\n    error PathNotApproved();\n    error SameAddress();\n    error ZeroAddress();\n\n    event Approve(\n        address indexed poolFactory,\n        address indexed votingRewardsFactory,\n        address indexed gaugeFactory\n    );\n    event Unapprove(\n        address indexed poolFactory,\n        address indexed votingRewardsFactory,\n        address indexed gaugeFactory\n    );\n    event SetManagedRewardsFactory(address indexed _newRewardsFactory);\n\n    /// @notice Approve a set of factories used in the Protocol.\n    ///         Router.sol is able to swap any poolFactories currently approved.\n    ///         Cannot approve address(0) factories.\n    ///         Cannot aprove path that is already approved.\n    ///         Each poolFactory has one unique set and maintains state.  In the case a poolFactory is unapproved\n    ///             and then re-approved, the same set of factories must be used.  In other words, you cannot overwrite\n    ///             the factories tied to a poolFactory address.\n    ///         VotingRewardsFactories and GaugeFactories may use the same address across multiple poolFactories.\n    /// @dev Callable by onlyOwner\n    /// @param poolFactory .\n    /// @param votingRewardsFactory .\n    /// @param gaugeFactory .\n    function approve(\n        address poolFactory,\n        address votingRewardsFactory,\n        address gaugeFactory\n    ) external;\n\n    /// @notice Unapprove a set of factories used in the Protocol.\n    ///         While a poolFactory is unapproved, Router.sol cannot swap with pools made from the corresponding factory\n    ///         Can only unapprove an approved path.\n    ///         Cannot unapprove the fallback path (core v2 factories).\n    /// @dev Callable by onlyOwner\n    /// @param poolFactory .\n    function unapprove(address poolFactory) external;\n\n    /// @notice Factory to create free and locked rewards for a managed veNFT\n    function managedRewardsFactory() external view returns (address);\n\n    /// @notice Set the rewards factory address\n    /// @dev Callable by onlyOwner\n    /// @param _newManagedRewardsFactory address of new managedRewardsFactory\n    function setManagedRewardsFactory(\n        address _newManagedRewardsFactory\n    ) external;\n\n    /// @notice Get the factories correlated to a poolFactory.\n    ///         Once set, this can never be modified.\n    ///         Returns the correlated factories even after an approved poolFactory is unapproved.\n    function factoriesToPoolFactory(\n        address poolFactory\n    )\n        external\n        view\n        returns (address votingRewardsFactory, address gaugeFactory);\n\n    /// @notice Get all PoolFactories approved by the registry\n    /// @dev The same PoolFactory address cannot be used twice\n    /// @return Array of PoolFactory addresses\n    function poolFactories() external view returns (address[] memory);\n\n    /// @notice Check if a PoolFactory is approved within the factory registry.  Router uses this method to\n    ///         ensure a pool swapped from is approved.\n    /// @param poolFactory .\n    /// @return True if PoolFactory is approved, else false\n    function isPoolFactoryApproved(\n        address poolFactory\n    ) external view returns (bool);\n\n    /// @notice Get the length of the poolFactories array\n    function poolFactoriesLength() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/factories/IGaugeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\ninterface IGaugeFactory {\n    function createGauge(\n        address _forwarder,\n        address _pool,\n        address _feesVotingReward,\n        address _ve,\n        bool isPool\n    ) external returns (address);\n}\n"
    },
    "contracts/interfaces/factories/IManagedRewardsFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\ninterface IManagedRewardsFactory {\n    event ManagedRewardCreated(\n        address indexed voter,\n        address indexed lockedManagedReward,\n        address indexed freeManagedReward\n    );\n\n    /// @notice creates a LockedManagedReward and a FreeManagedReward contract for a managed veNFT\n    /// @param _forwarder Address of trusted forwarder\n    /// @param _voter Address of Voter.sol\n    /// @return lockedManagedReward Address of LockedManagedReward contract created\n    /// @return freeManagedReward   Address of FreeManagedReward contract created\n    function createRewards(\n        address _forwarder,\n        address _voter\n    ) external returns (address lockedManagedReward, address freeManagedReward);\n}\n"
    },
    "contracts/interfaces/factories/IPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\ninterface IPoolFactory {\n    event SetFeeManager(address feeManager);\n    event SetPauser(address pauser);\n    event SetPauseState(bool state);\n    event SetVoter(address voter);\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        bool indexed stable,\n        address pool,\n        uint256\n    );\n    event SetCustomFee(address indexed pool, uint256 fee);\n\n    error FeeInvalid();\n    error FeeTooHigh();\n    error InvalidPool();\n    error NotFeeManager();\n    error NotPauser();\n    error NotVoter();\n    error PoolAlreadyExists();\n    error SameAddress();\n    error ZeroFee();\n    error ZeroAddress();\n\n    /// @notice returns the number of pools created from this factory\n    function allPoolsLength() external view returns (uint256);\n\n    /// @notice Is a valid pool created by this factory.\n    /// @param .\n    function isPool(address pool) external view returns (bool);\n\n    /// @notice Return address of pool created by this factory\n    /// @param tokenA .\n    /// @param tokenB .\n    /// @param stable True if stable, false if volatile\n    function getPool(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external view returns (address);\n\n    /// @notice Support for v3-style pools which wraps around getPool(tokenA,tokenB,stable)\n    /// @dev fee is converted to stable boolean.\n    /// @param tokenA .\n    /// @param tokenB .\n    /// @param fee  1 if stable, 0 if volatile, else returns address(0)\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address);\n\n    /// @dev Only called once to set to Voter.sol - Voter does not have a function\n    ///      to call this contract method, so once set it's immutable.\n    ///      This also follows convention of setVoterAndDistributor() in VotingEscrow.sol\n    /// @param _voter .\n    function setVoter(address _voter) external;\n\n    function setPauser(address _pauser) external;\n\n    function setPauseState(bool _state) external;\n\n    function setFeeManager(address _feeManager) external;\n\n    /// @notice Set default fee for stable and volatile pools.\n    /// @dev Throws if higher than maximum fee.\n    ///      Throws if fee is zero.\n    /// @param _stable Stable or volatile pool.\n    /// @param _fee .\n    function setFee(bool _stable, uint256 _fee) external;\n\n    /// @notice Set overriding fee for a pool from the default\n    /// @dev A custom fee of zero means the default fee will be used.\n    function setCustomFee(address _pool, uint256 _fee) external;\n\n    /// @notice Returns fee for a pool, as custom fees are possible.\n    function getFee(\n        address _pool,\n        bool _stable\n    ) external view returns (uint256);\n\n    /// @notice Create a pool given two tokens and if they're stable/volatile\n    /// @dev token order does not matter\n    /// @param tokenA .\n    /// @param tokenB .\n    /// @param stable .\n    function createPool(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external returns (address pool);\n\n    /// @notice Support for v3-style pools which wraps around createPool(tokena,tokenB,stable)\n    /// @dev fee is converted to stable boolean\n    /// @dev token order does not matter\n    /// @param tokenA .\n    /// @param tokenB .\n    /// @param fee 1 if stable, 0 if volatile, else revert\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    function isPaused() external view returns (bool);\n\n    function voter() external view returns (address);\n\n    function implementation() external view returns (address);\n}\n"
    },
    "contracts/interfaces/factories/IVotingRewardsFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\ninterface IVotingRewardsFactory {\n    /// @notice creates a BribeVotingReward and a FeesVotingReward contract for a gauge\n    /// @param _forwarder            Address of trusted forwarder\n    /// @param _rewards             Addresses of pool tokens to be used as valid rewards tokens\n    /// @return feesVotingReward    Address of FeesVotingReward contract created\n    /// @return bribeVotingReward   Address of BribeVotingReward contract created\n    function createRewards(\n        address _forwarder,\n        address[] memory _rewards\n    ) external returns (address feesVotingReward, address bribeVotingReward);\n}\n"
    },
    "contracts/interfaces/IAutoCompounder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\ninterface IAutoCompounder {\n    error AlreadyInitialized();\n    error InvalidPath();\n    error NotFactory();\n    error TokenIdAlreadySet();\n\n    event RewardAndCompound(\n        uint256 _tokenId,\n        address _claimer,\n        uint256 balanceRewarded,\n        uint256 balanceCompounded\n    );\n    event SetRoute(address _from);\n    event SetTokenId(uint256 _tokenId);\n}\n"
    },
    "contracts/interfaces/ICompoundOptimizer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.24;\n\nimport {IRouter} from \"./IRouter.sol\";\n\ninterface ICompoundOptimizer {\n    error NoRouteFound();\n\n    function getOptimalTokenToMezoRoute(\n        address token,\n        uint256 amountIn\n    ) external view returns (IRouter.Route[] memory);\n}\n"
    },
    "contracts/interfaces/IEpochGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\ninterface IEpochGovernor {\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    function result() external returns (ProposalState);\n}\n"
    },
    "contracts/interfaces/IGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\ninterface IGauge {\n    error NotAlive();\n    error NotAuthorized();\n    error NotVoter();\n    error NotTeam();\n    error RewardRateTooHigh();\n    error ZeroAmount();\n    error ZeroRewardRate();\n\n    event Deposit(address indexed from, address indexed to, uint256 amount);\n    event Withdraw(address indexed from, uint256 amount);\n    event NotifyReward(address indexed from, uint256 amount);\n    event ClaimFees(address indexed from, uint256 claimed0, uint256 claimed1);\n    event ClaimRewards(address indexed from, uint256 amount);\n\n    /// @notice Address of the pool LP token which is deposited (staked) for rewards\n    function stakingToken() external view returns (address);\n\n    /// @notice Address of the token rewarded to stakers\n    function rewardToken() external view returns (address);\n\n    /// @notice Address of the FeesVotingReward contract linked to the gauge\n    function feesVotingReward() external view returns (address);\n\n    /// @notice Address of Protocol Voter\n    function voter() external view returns (address);\n\n    /// @notice Address of Protocol Voting Escrow\n    function ve() external view returns (address);\n\n    /// @notice Returns if gauge is linked to a legitimate Protocol pool\n    function isPool() external view returns (bool);\n\n    /// @notice Timestamp end of current rewards period\n    function periodFinish() external view returns (uint256);\n\n    /// @notice Current reward rate of rewardToken to distribute per second\n    function rewardRate() external view returns (uint256);\n\n    /// @notice Most recent timestamp contract has updated state\n    function lastUpdateTime() external view returns (uint256);\n\n    /// @notice Most recent stored value of rewardPerToken\n    function rewardPerTokenStored() external view returns (uint256);\n\n    /// @notice Amount of stakingToken deposited for rewards\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Get the amount of stakingToken deposited by an account\n    function balanceOf(address) external view returns (uint256);\n\n    /// @notice Cached rewardPerTokenStored for an account based on their most recent action\n    function userRewardPerTokenPaid(address) external view returns (uint256);\n\n    /// @notice Cached amount of rewardToken earned for an account\n    function rewards(address) external view returns (uint256);\n\n    /// @notice View to see the rewardRate given the timestamp of the start of the epoch\n    function rewardRateByEpoch(uint256) external view returns (uint256);\n\n    /// @notice Cached amount of fees generated from the Pool linked to the Gauge of token0\n    function fees0() external view returns (uint256);\n\n    /// @notice Cached amount of fees generated from the Pool linked to the Gauge of token1\n    function fees1() external view returns (uint256);\n\n    /// @notice Get the current reward rate per unit of stakingToken deposited\n    function rewardPerToken() external view returns (uint256 _rewardPerToken);\n\n    /// @notice Returns the last time the reward was modified or periodFinish if the reward has ended\n    function lastTimeRewardApplicable() external view returns (uint256 _time);\n\n    /// @notice Returns accrued balance to date from last claim / first deposit.\n    function earned(address _account) external view returns (uint256 _earned);\n\n    /// @notice Total amount of rewardToken to distribute for the current rewards period\n    function left() external view returns (uint256 _left);\n\n    /// @notice Retrieve rewards for an address.\n    /// @dev Throws if not called by same address or voter.\n    /// @param _account .\n    function getReward(address _account) external;\n\n    /// @notice Deposit LP tokens into gauge for msg.sender\n    /// @param _amount .\n    function deposit(uint256 _amount) external;\n\n    /// @notice Deposit LP tokens into gauge for any user\n    /// @param _amount .\n    /// @param _recipient Recipient to give balance to\n    function deposit(uint256 _amount, address _recipient) external;\n\n    /// @notice Withdraw LP tokens for user\n    /// @param _amount .\n    function withdraw(uint256 _amount) external;\n\n    /// @dev Notifies gauge of gauge rewards. Assumes gauge reward tokens is 18 decimals.\n    ///      If not 18 decimals, rewardRate may have rounding issues.\n    function notifyRewardAmount(uint256 amount) external;\n\n    /// @dev Notifies gauge of gauge rewards without distributing its fees.\n    ///      Assumes gauge reward tokens is 18 decimals.\n    ///      If not 18 decimals, rewardRate may have rounding issues.\n    function notifyRewardWithoutClaim(uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/IMezo.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IMezo is IERC20 {\n    error NotMinter();\n    error NotOwner();\n\n    function mint(address, uint256) external returns (bool);\n\n    function minter() external returns (address);\n}\n"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\ninterface IPool {\n    error DepositsNotEqual();\n    error BelowMinimumK();\n    error FactoryAlreadySet();\n    error InsufficientLiquidity();\n    error InsufficientLiquidityMinted();\n    error InsufficientLiquidityBurned();\n    error InsufficientOutputAmount();\n    error InsufficientInputAmount();\n    error IsPaused();\n    error InvalidTo();\n    error K();\n    error NotEmergencyCouncil();\n\n    event Fees(address indexed sender, uint256 amount0, uint256 amount1);\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        address indexed to,\n        uint256 amount0,\n        uint256 amount1\n    );\n    event Swap(\n        address indexed sender,\n        address indexed to,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out\n    );\n    event Sync(uint256 reserve0, uint256 reserve1);\n    event Claim(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    // Struct to capture time period observations every 30 minutes, used for local oracles\n    struct Observation {\n        uint256 timestamp;\n        uint256 reserve0Cumulative;\n        uint256 reserve1Cumulative;\n    }\n\n    /// @notice Returns the decimal (dec), reserves (r), stable (st), and tokens (t) of token0 and token1\n    function metadata()\n        external\n        view\n        returns (\n            uint256 dec0,\n            uint256 dec1,\n            uint256 r0,\n            uint256 r1,\n            bool st,\n            address t0,\n            address t1\n        );\n\n    /// @notice Claim accumulated but unclaimed fees (claimable0 and claimable1)\n    function claimFees() external returns (uint256, uint256);\n\n    /// @notice Returns [token0, token1]\n    function tokens() external view returns (address, address);\n\n    /// @notice Address of token in the pool with the lower address value\n    function token0() external view returns (address);\n\n    /// @notice Address of token in the pool with the higher address value\n    function token1() external view returns (address);\n\n    /// @notice Address of linked PoolFees.sol\n    function poolFees() external view returns (address);\n\n    /// @notice Address of PoolFactory that created this contract\n    function factory() external view returns (address);\n\n    /// @notice Capture oracle reading every 30 minutes (1800 seconds)\n    function periodSize() external view returns (uint256);\n\n    /// @notice Amount of token0 in pool\n    function reserve0() external view returns (uint256);\n\n    /// @notice Amount of token1 in pool\n    function reserve1() external view returns (uint256);\n\n    /// @notice Timestamp of last update to pool\n    function blockTimestampLast() external view returns (uint256);\n\n    /// @notice Cumulative of reserve0 factoring in time elapsed\n    function reserve0CumulativeLast() external view returns (uint256);\n\n    /// @notice Cumulative of reserve1 factoring in time elapsed\n    function reserve1CumulativeLast() external view returns (uint256);\n\n    /// @notice Accumulated fees of token0 (global)\n    function index0() external view returns (uint256);\n\n    /// @notice Accumulated fees of token1 (global)\n    function index1() external view returns (uint256);\n\n    /// @notice Get an LP's relative index0 to index0\n    function supplyIndex0(address) external view returns (uint256);\n\n    /// @notice Get an LP's relative index1 to index1\n    function supplyIndex1(address) external view returns (uint256);\n\n    /// @notice Amount of unclaimed, but claimable tokens from fees of token0 for an LP\n    function claimable0(address) external view returns (uint256);\n\n    /// @notice Amount of unclaimed, but claimable tokens from fees of token1 for an LP\n    function claimable1(address) external view returns (uint256);\n\n    /// @notice Returns the value of K in the Pool, based on its reserves.\n    function getK() external returns (uint256);\n\n    /// @notice Set pool name\n    ///         Only callable by Voter.emergencyCouncil()\n    /// @param __name String of new name\n    function setName(string calldata __name) external;\n\n    /// @notice Set pool symbol\n    ///         Only callable by Voter.emergencyCouncil()\n    /// @param __symbol String of new symbol\n    function setSymbol(string calldata __symbol) external;\n\n    /// @notice Get the number of observations recorded\n    function observationLength() external view returns (uint256);\n\n    /// @notice Get the value of the most recent observation\n    function lastObservation() external view returns (Observation memory);\n\n    /// @notice True if pool is stable, false if volatile\n    function stable() external view returns (bool);\n\n    /// @notice Produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices()\n        external\n        view\n        returns (\n            uint256 reserve0Cumulative,\n            uint256 reserve1Cumulative,\n            uint256 blockTimestamp\n        );\n\n    /// @notice Provides twap price with user configured granularity, up to the full window size\n    /// @param tokenIn .\n    /// @param amountIn .\n    /// @param granularity .\n    /// @return amountOut .\n    function quote(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 granularity\n    ) external view returns (uint256 amountOut);\n\n    /// @notice Returns a memory set of TWAP prices\n    ///         Same as calling sample(tokenIn, amountIn, points, 1)\n    /// @param tokenIn .\n    /// @param amountIn .\n    /// @param points Number of points to return\n    /// @return Array of TWAP prices\n    function prices(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 points\n    ) external view returns (uint256[] memory);\n\n    /// @notice Same as prices with with an additional window argument.\n    ///         Window = 2 means 2 * 30min (or 1 hr) between observations\n    /// @param tokenIn .\n    /// @param amountIn .\n    /// @param points .\n    /// @param window .\n    /// @return Array of TWAP prices\n    function sample(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 points,\n        uint256 window\n    ) external view returns (uint256[] memory);\n\n    /// @notice This low-level function should be called from a contract which performs important safety checks\n    /// @param amount0Out   Amount of token0 to send to `to`\n    /// @param amount1Out   Amount of token1 to send to `to`\n    /// @param to           Address to receive the swapped output\n    /// @param data         Additional calldata for flashloans\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    /// @notice This low-level function should be called from a contract which performs important safety checks\n    ///         standard uniswap v2 implementation\n    /// @param to Address to receive token0 and token1 from burning the pool token\n    /// @return amount0 Amount of token0 returned\n    /// @return amount1 Amount of token1 returned\n    function burn(\n        address to\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice This low-level function should be called by addLiquidity functions in Router.sol, which performs important safety checks\n    ///         standard uniswap v2 implementation\n    /// @param to           Address to receive the minted LP token\n    /// @return liquidity   Amount of LP token minted\n    function mint(address to) external returns (uint256 liquidity);\n\n    /// @notice Update reserves and, on the first call per block, price accumulators\n    /// @return _reserve0 .\n    /// @return _reserve1 .\n    /// @return _blockTimestampLast .\n    function getReserves()\n        external\n        view\n        returns (\n            uint256 _reserve0,\n            uint256 _reserve1,\n            uint256 _blockTimestampLast\n        );\n\n    /// @notice Get the amount of tokenOut given the amount of tokenIn\n    /// @param amountIn Amount of token in\n    /// @param tokenIn  Address of token\n    /// @return Amount out\n    function getAmountOut(\n        uint256 amountIn,\n        address tokenIn\n    ) external view returns (uint256);\n\n    /// @notice Force balances to match reserves\n    /// @param to Address to receive any skimmed rewards\n    function skim(address to) external;\n\n    /// @notice Force reserves to match balances\n    function sync() external;\n\n    /// @notice Called on pool creation by PoolFactory\n    /// @param _token0 Address of token0\n    /// @param _token1 Address of token1\n    /// @param _stable True if stable, false if volatile\n    function initialize(\n        address _token0,\n        address _token1,\n        bool _stable\n    ) external;\n}\n"
    },
    "contracts/interfaces/IPoolCallee.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\ninterface IPoolCallee {\n    function hook(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/IReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\ninterface IReward {\n    error InvalidReward();\n    error NotAuthorized();\n    error NotGauge();\n    error NotEscrowToken();\n    error NotSingleToken();\n    error NotVotingEscrow();\n    error NotWhitelisted();\n    error ZeroAmount();\n\n    event Deposit(\n        address indexed from,\n        uint256 indexed tokenId,\n        uint256 amount\n    );\n    event Withdraw(\n        address indexed from,\n        uint256 indexed tokenId,\n        uint256 amount\n    );\n    event NotifyReward(\n        address indexed from,\n        address indexed reward,\n        uint256 indexed epoch,\n        uint256 amount\n    );\n    event ClaimRewards(\n        address indexed from,\n        address indexed reward,\n        uint256 amount\n    );\n\n    /// @notice A checkpoint for marking balance\n    struct Checkpoint {\n        uint256 timestamp;\n        uint256 balanceOf;\n    }\n\n    /// @notice A checkpoint for marking supply\n    struct SupplyCheckpoint {\n        uint256 timestamp;\n        uint256 supply;\n    }\n\n    /// @notice Epoch duration constant (7 days)\n    function duration() external pure returns (uint256);\n\n    /// @notice Address of Voter.sol\n    function voter() external view returns (address);\n\n    /// @notice Address of VotingEscrow.sol\n    function ve() external view returns (address);\n\n    /// @dev Address which has permission to externally call _deposit() & _withdraw()\n    function authorized() external view returns (address);\n\n    /// @notice Total amount currently deposited via _deposit()\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Current amount deposited by tokenId\n    function balanceOf(uint256 tokenId) external view returns (uint256);\n\n    /// @notice Amount of tokens to reward depositors for a given epoch\n    /// @param token Address of token to reward\n    /// @param epochStart Startime of rewards epoch\n    /// @return Amount of token\n    function tokenRewardsPerEpoch(\n        address token,\n        uint256 epochStart\n    ) external view returns (uint256);\n\n    /// @notice Most recent timestamp a veNFT has claimed their rewards\n    /// @param  token Address of token rewarded\n    /// @param tokenId veNFT unique identifier\n    /// @return Timestamp\n    function lastEarn(\n        address token,\n        uint256 tokenId\n    ) external view returns (uint256);\n\n    /// @notice True if a token is or has been an active reward token, else false\n    function isReward(address token) external view returns (bool);\n\n    /// @notice The number of checkpoints for each tokenId deposited\n    function numCheckpoints(uint256 tokenId) external view returns (uint256);\n\n    /// @notice The total number of checkpoints\n    function supplyNumCheckpoints() external view returns (uint256);\n\n    /// @notice Deposit an amount into the rewards contract to earn future rewards associated to a veNFT\n    /// @dev Internal notation used as only callable internally by `authorized`.\n    /// @param amount   Amount deposited for the veNFT\n    /// @param tokenId  Unique identifier of the veNFT\n    function _deposit(uint256 amount, uint256 tokenId) external;\n\n    /// @notice Withdraw an amount from the rewards contract associated to a veNFT\n    /// @dev Internal notation used as only callable internally by `authorized`.\n    /// @param amount   Amount deposited for the veNFT\n    /// @param tokenId  Unique identifier of the veNFT\n    function _withdraw(uint256 amount, uint256 tokenId) external;\n\n    /// @notice Claim the rewards earned by a veNFT staker\n    /// @param tokenId  Unique identifier of the veNFT\n    /// @param tokens   Array of tokens to claim rewards of\n    function getReward(uint256 tokenId, address[] memory tokens) external;\n\n    /// @notice Add rewards for stakers to earn\n    /// @param token    Address of token to reward\n    /// @param amount   Amount of token to transfer to rewards\n    function notifyRewardAmount(address token, uint256 amount) external;\n\n    /// @notice Determine the prior balance for an account as of a block number\n    /// @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n    /// @param tokenId      The token of the NFT to check\n    /// @param timestamp    The timestamp to get the balance at\n    /// @return The balance the account had as of the given block\n    function getPriorBalanceIndex(\n        uint256 tokenId,\n        uint256 timestamp\n    ) external view returns (uint256);\n\n    /// @notice Determine the prior index of supply staked by of a timestamp\n    /// @dev Timestamp must be <= current timestamp\n    /// @param timestamp The timestamp to get the index at\n    /// @return Index of supply checkpoint\n    function getPriorSupplyIndex(\n        uint256 timestamp\n    ) external view returns (uint256);\n\n    /// @notice Get number of rewards tokens\n    function rewardsListLength() external view returns (uint256);\n\n    /// @notice Calculate how much in rewards are earned for a specific token and veNFT\n    /// @param token Address of token to fetch rewards of\n    /// @param tokenId Unique identifier of the veNFT\n    /// @return Amount of token earned in rewards\n    function earned(\n        address token,\n        uint256 tokenId\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IVotingEscrow} from \"./IVotingEscrow.sol\";\n\ninterface IRewardsDistributor {\n    event CheckpointToken(uint256 time, uint256 tokens);\n    event Claimed(\n        uint256 indexed tokenId,\n        uint256 indexed epochStart,\n        uint256 indexed epochEnd,\n        uint256 amount\n    );\n\n    error NotDepositor();\n    error NotManagedOrNormalNFT();\n    error UpdatePeriod();\n\n    /// @notice 7 days in seconds\n    function week() external pure returns (uint256);\n\n    /// @notice Timestamp of contract creation\n    function startTime() external view returns (uint256);\n\n    /// @notice Timestamp of most recent claim of tokenId\n    function timeCursorOf(uint256 tokenId) external view returns (uint256);\n\n    /// @notice The last timestamp Splitter has called checkpointToken()\n    function lastTokenTime() external view returns (uint256);\n\n    /// @notice Interface of VotingEscrow.sol\n    function ve() external view returns (IVotingEscrow);\n\n    /// @notice Address of token used for distributions\n    function token() external view returns (address);\n\n    /// @notice Address of Splitter.sol\n    ///         Authorized caller of checkpointToken()\n    function depositor() external view returns (address);\n\n    /// @notice Amount of token in contract when checkpointToken() was last called\n    function tokenLastBalance() external view returns (uint256);\n\n    /// @notice Called by Splitter to notify Distributor of rebases\n    function checkpointToken() external;\n\n    /// @notice Returns the amount of rebases claimable for a given token ID\n    /// @dev Allows claiming of rebases up to 50 epochs old\n    /// @param tokenId The token ID to check\n    /// @return The amount of rebases claimable for the given token ID\n    function claimable(uint256 tokenId) external view returns (uint256);\n\n    /// @notice Claims rebases for a given token ID\n    /// @dev Allows claiming of rebases up to 50 epochs old\n    ///      `Splitter.updatePeriod()` must be called before claiming\n    /// @param tokenId The token ID to claim for\n    /// @return The amount of rebases claimed\n    function claim(uint256 tokenId) external returns (uint256);\n\n    /// @notice Claims rebases for a list of token IDs\n    /// @dev    `Splitter.updatePeriod()` must be called before claiming\n    /// @param tokenIds The token IDs to claim for\n    /// @return Whether or not the claim succeeded\n    function claimMany(uint256[] calldata tokenIds) external returns (bool);\n\n    /// @notice Used to set splitter once on initialization\n    /// @dev Callable once by Splitter only, Splitter is immutable\n    function setDepositor(address _depositor) external;\n}\n"
    },
    "contracts/interfaces/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\ninterface IRouter {\n    struct Route {\n        address from;\n        address to;\n        bool stable;\n        address factory;\n    }\n\n    error Expired();\n    error InsufficientAmount();\n    error InsufficientAmountA();\n    error InsufficientAmountB();\n    error InsufficientAmountADesired();\n    error InsufficientAmountBDesired();\n    error InsufficientAmountAOptimal();\n    error InsufficientLiquidity();\n    error InsufficientOutputAmount();\n    error InvalidPath();\n    error InvalidRouteA();\n    error InvalidRouteB();\n    error PoolDoesNotExist();\n    error PoolFactoryDoesNotExist();\n    error SameAddresses();\n    error ZeroAddress();\n\n    /// @notice Address of FactoryRegistry.sol\n    function factoryRegistry() external view returns (address);\n\n    /// @notice Address of Protocol PoolFactory.sol\n    function defaultFactory() external view returns (address);\n\n    /// @notice Address of Voter.sol\n    function voter() external view returns (address);\n\n    /// @dev Struct containing information necessary to zap in and out of pools\n    /// @param tokenA           .\n    /// @param tokenB           .\n    /// @param stable           Stable or volatile pool\n    /// @param factory          factory of pool\n    /// @param amountOutMinA    Minimum amount expected from swap leg of zap via routesA\n    /// @param amountOutMinB    Minimum amount expected from swap leg of zap via routesB\n    /// @param amountAMin       Minimum amount of tokenA expected from liquidity leg of zap\n    /// @param amountBMin       Minimum amount of tokenB expected from liquidity leg of zap\n    struct Zap {\n        address tokenA;\n        address tokenB;\n        bool stable;\n        address factory;\n        uint256 amountOutMinA;\n        uint256 amountOutMinB;\n        uint256 amountAMin;\n        uint256 amountBMin;\n    }\n\n    /// @notice Sort two tokens by which address value is less than the other\n    /// @param tokenA   Address of token to sort\n    /// @param tokenB   Address of token to sort\n    /// @return token0  Lower address value between tokenA and tokenB\n    /// @return token1  Higher address value between tokenA and tokenB\n    function sortTokens(\n        address tokenA,\n        address tokenB\n    ) external pure returns (address token0, address token1);\n\n    /// @notice Calculate the address of a pool by its' factory.\n    ///         Used by all Router functions containing a `Route[]` or `_factory` argument.\n    ///         Reverts if _factory is not approved by the FactoryRegistry\n    /// @dev Returns a randomly generated address for a nonexistent pool\n    /// @param tokenA   Address of token to query\n    /// @param tokenB   Address of token to query\n    /// @param stable   True if pool is stable, false if volatile\n    /// @param _factory Address of factory which created the pool\n    function poolFor(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        address _factory\n    ) external view returns (address pool);\n\n    /// @notice Fetch and sort the reserves for a pool\n    /// @param tokenA       .\n    /// @param tokenB       .\n    /// @param stable       True if pool is stable, false if volatile\n    /// @param _factory     Address of PoolFactory for tokenA and tokenB\n    /// @return reserveA    Amount of reserves of the sorted token A\n    /// @return reserveB    Amount of reserves of the sorted token B\n    function getReserves(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        address _factory\n    ) external view returns (uint256 reserveA, uint256 reserveB);\n\n    /// @notice Perform chained getAmountOut calculations on any number of pools\n    function getAmountsOut(\n        uint256 amountIn,\n        Route[] memory routes\n    ) external view returns (uint256[] memory amounts);\n\n    // **** ADD LIQUIDITY ****\n\n    /// @notice Quote the amount deposited into a Pool\n    /// @param tokenA           .\n    /// @param tokenB           .\n    /// @param stable           True if pool is stable, false if volatile\n    /// @param _factory         Address of PoolFactory for tokenA and tokenB\n    /// @param amountADesired   Amount of tokenA desired to deposit\n    /// @param amountBDesired   Amount of tokenB desired to deposit\n    /// @return amountA         Amount of tokenA to actually deposit\n    /// @return amountB         Amount of tokenB to actually deposit\n    /// @return liquidity       Amount of liquidity token returned from deposit\n    function quoteAddLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        address _factory,\n        uint256 amountADesired,\n        uint256 amountBDesired\n    )\n        external\n        view\n        returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    /// @notice Quote the amount of liquidity removed from a Pool\n    /// @param tokenA       .\n    /// @param tokenB       .\n    /// @param stable       True if pool is stable, false if volatile\n    /// @param _factory     Address of PoolFactory for tokenA and tokenB\n    /// @param liquidity    Amount of liquidity to remove\n    /// @return amountA     Amount of tokenA received\n    /// @return amountB     Amount of tokenB received\n    function quoteRemoveLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        address _factory,\n        uint256 liquidity\n    ) external view returns (uint256 amountA, uint256 amountB);\n\n    /// @notice Add liquidity of two tokens to a Pool\n    /// @param tokenA           .\n    /// @param tokenB           .\n    /// @param stable           True if pool is stable, false if volatile\n    /// @param amountADesired   Amount of tokenA desired to deposit\n    /// @param amountBDesired   Amount of tokenB desired to deposit\n    /// @param amountAMin       Minimum amount of tokenA to deposit\n    /// @param amountBMin       Minimum amount of tokenB to deposit\n    /// @param to               Recipient of liquidity token\n    /// @param deadline         Deadline to receive liquidity\n    /// @return amountA         Amount of tokenA to actually deposit\n    /// @return amountB         Amount of tokenB to actually deposit\n    /// @return liquidity       Amount of liquidity token returned from deposit\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    // **** REMOVE LIQUIDITY ****\n\n    /// @notice Remove liquidity of two tokens from a Pool\n    /// @param tokenA       .\n    /// @param tokenB       .\n    /// @param stable       True if pool is stable, false if volatile\n    /// @param liquidity    Amount of liquidity to remove\n    /// @param amountAMin   Minimum amount of tokenA to receive\n    /// @param amountBMin   Minimum amount of tokenB to receive\n    /// @param to           Recipient of tokens received\n    /// @param deadline     Deadline to remove liquidity\n    /// @return amountA     Amount of tokenA received\n    /// @return amountB     Amount of tokenB received\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    // **** SWAP ****\n\n    /// @notice Swap one token for another\n    /// @param amountIn     Amount of token in\n    /// @param amountOutMin Minimum amount of desired token received\n    /// @param routes       Array of trade routes used in the swap\n    /// @param to           Recipient of the tokens received\n    /// @param deadline     Deadline to receive tokens\n    /// @return amounts     Array of amounts returned per route\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    /// @notice Swap one token for another without slippage protection\n    /// @return amounts     Array of amounts to swap  per route\n    /// @param routes       Array of trade routes used in the swap\n    /// @param to           Recipient of the tokens received\n    /// @param deadline     Deadline to receive tokens\n    function UNSAFE_swapExactTokensForTokens(\n        uint256[] memory amounts,\n        Route[] calldata routes,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n\n    /// @notice Swap one token for another supporting fee-on-transfer tokens\n    /// @param amountIn     Amount of token in\n    /// @param amountOutMin Minimum amount of desired token received\n    /// @param routes       Array of trade routes used in the swap\n    /// @param to           Recipient of the tokens received\n    /// @param deadline     Deadline to receive tokens\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint256 deadline\n    ) external;\n\n    /// @notice Zap a token A into a pool (B, C). (A can be equal to B or C).\n    ///         Supports standard ERC20 tokens only (i.e. not fee-on-transfer tokens etc).\n    ///         Slippage is required for the initial swap.\n    ///         Additional slippage may be required when adding liquidity as the\n    ///         price of the token may have changed.\n    /// @param tokenIn      Token you are zapping in from (i.e. input token).\n    /// @param amountInA    Amount of input token you wish to send down routesA\n    /// @param amountInB    Amount of input token you wish to send down routesB\n    /// @param zapInPool    Contains zap struct information. See Zap struct.\n    /// @param routesA      Route used to convert input token to tokenA\n    /// @param routesB      Route used to convert input token to tokenB\n    /// @param to           Address you wish to mint liquidity to.\n    /// @param stake        Auto-stake liquidity in corresponding gauge.\n    /// @return liquidity   Amount of LP tokens created from zapping in.\n    function zapIn(\n        address tokenIn,\n        uint256 amountInA,\n        uint256 amountInB,\n        Zap calldata zapInPool,\n        Route[] calldata routesA,\n        Route[] calldata routesB,\n        address to,\n        bool stake\n    ) external returns (uint256 liquidity);\n\n    /// @notice Zap out a pool (B, C) into A.\n    ///         Supports standard ERC20 tokens only (i.e. not fee-on-transfer tokens etc).\n    ///         Slippage is required for the removal of liquidity.\n    ///         Additional slippage may be required on the swap as the\n    ///         price of the token may have changed.\n    /// @param tokenOut     Token you are zapping out to (i.e. output token).\n    /// @param liquidity    Amount of liquidity you wish to remove.\n    /// @param zapOutPool   Contains zap struct information. See Zap struct.\n    /// @param routesA      Route used to convert tokenA into output token.\n    /// @param routesB      Route used to convert tokenB into output token.\n    function zapOut(\n        address tokenOut,\n        uint256 liquidity,\n        Zap calldata zapOutPool,\n        Route[] calldata routesA,\n        Route[] calldata routesB\n    ) external;\n\n    /// @notice Used to generate params required for zapping in.\n    ///         Zap in => remove liquidity then swap.\n    ///         Apply slippage to expected swap values to account for changes in reserves in between.\n    /// @dev Output token refers to the token you want to zap in from.\n    /// @param tokenA           .\n    /// @param tokenB           .\n    /// @param stable           .\n    /// @param _factory         .\n    /// @param amountInA        Amount of input token you wish to send down routesA\n    /// @param amountInB        Amount of input token you wish to send down routesB\n    /// @param routesA          Route used to convert input token to tokenA\n    /// @param routesB          Route used to convert input token to tokenB\n    /// @return amountOutMinA   Minimum output expected from swapping input token to tokenA.\n    /// @return amountOutMinB   Minimum output expected from swapping input token to tokenB.\n    /// @return amountAMin      Minimum amount of tokenA expected from depositing liquidity.\n    /// @return amountBMin      Minimum amount of tokenB expected from depositing liquidity.\n    function generateZapInParams(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        address _factory,\n        uint256 amountInA,\n        uint256 amountInB,\n        Route[] calldata routesA,\n        Route[] calldata routesB\n    )\n        external\n        view\n        returns (\n            uint256 amountOutMinA,\n            uint256 amountOutMinB,\n            uint256 amountAMin,\n            uint256 amountBMin\n        );\n\n    /// @notice Used to generate params required for zapping out.\n    ///         Zap out => swap then add liquidity.\n    ///         Apply slippage to expected liquidity values to account for changes in reserves in between.\n    /// @dev Output token refers to the token you want to zap out of.\n    /// @param tokenA           .\n    /// @param tokenB           .\n    /// @param stable           .\n    /// @param _factory         .\n    /// @param liquidity        Amount of liquidity being zapped out of into a given output token.\n    /// @param routesA          Route used to convert tokenA into output token.\n    /// @param routesB          Route used to convert tokenB into output token.\n    /// @return amountOutMinA   Minimum output expected from swapping tokenA into output token.\n    /// @return amountOutMinB   Minimum output expected from swapping tokenB into output token.\n    /// @return amountAMin      Minimum amount of tokenA expected from withdrawing liquidity.\n    /// @return amountBMin      Minimum amount of tokenB expected from withdrawing liquidity.\n    function generateZapOutParams(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        address _factory,\n        uint256 liquidity,\n        Route[] calldata routesA,\n        Route[] calldata routesB\n    )\n        external\n        view\n        returns (\n            uint256 amountOutMinA,\n            uint256 amountOutMinB,\n            uint256 amountAMin,\n            uint256 amountBMin\n        );\n\n    /// @notice Used by zapper to determine appropriate ratio of A to B to deposit liquidity. Assumes stable pool.\n    /// @dev Returns stable liquidity ratio of B to (A + B).\n    ///      E.g. if ratio is 0.4, it means there is more of A than there is of B.\n    ///      Therefore you should deposit more of token A than B.\n    /// @param tokenA   tokenA of stable pool you are zapping into.\n    /// @param tokenB   tokenB of stable pool you are zapping into.\n    /// @param factory  Factory that created stable pool.\n    /// @return ratio   Ratio of token0 to token1 required to deposit into zap.\n    function quoteStableLiquidityRatio(\n        address tokenA,\n        address tokenB,\n        address factory\n    ) external view returns (uint256 ratio);\n}\n"
    },
    "contracts/interfaces/ISplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\ninterface ISplitter {\n    error AlreadyNudged();\n    error NotEpochGovernor();\n\n    event Nudge(uint256 indexed _period, uint256 _oldRate, uint256 _newRate);\n\n    /// @notice Allows epoch governor to modify the fee splitter by at most 1 basis\n    ///         tick per epoch on a scale to a maximum of 100 or to a minimum of 1.\n    /// @dev Throws if not epoch governor.\n    ///      Throws if already nudged this epoch.\n    ///      Throws if nudging above maximum rate.\n    ///      Throws if nudging below minimum rate.\n    ///      This contract is coupled to EpochGovernor as it requires three option\n    ///      simple majority voting.\n    function nudge() external;\n\n    /// @notice Processes emissions and rebases. Callable once per epoch.\n    /// @return _period Start of current epoch.\n    function updatePeriod() external returns (uint256 _period);\n\n    /// @notice Timestamp of start of epoch that updatePeriod was last called in\n    function activePeriod() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IVoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\ninterface IVoter {\n    error AlreadyVotedOrDeposited();\n    error DistributeWindow();\n    error FactoryPathNotApproved();\n    error GaugeAlreadyKilled();\n    error GaugeAlreadyRevived();\n    error GaugeExists();\n    error GaugeDoesNotExist(address _pool);\n    error GaugeNotAlive(address _gauge);\n    error InactiveManagedNFT();\n    error MaximumVotingNumberTooLow();\n    error NonZeroVotes();\n    error NotAPool();\n    error NotApprovedOrOwner();\n    error NotGovernor();\n    error NotEmergencyCouncil();\n    error NotSplitter();\n    error NotWhitelistedNFT();\n    error NotWhitelistedToken();\n    error SameValue();\n    error SpecialVotingWindow();\n    error TooManyPools();\n    error UnequalLengths();\n    error ZeroBalance();\n    error ZeroAddress();\n\n    event GaugeCreated(\n        address indexed poolFactory,\n        address indexed votingRewardsFactory,\n        address indexed gaugeFactory,\n        address pool,\n        address bribeVotingReward,\n        address feeVotingReward,\n        address gauge,\n        address creator\n    );\n    event GaugeKilled(address indexed gauge);\n    event GaugeRevived(address indexed gauge);\n    event Voted(\n        address indexed voter,\n        address indexed pool,\n        uint256 indexed tokenId,\n        uint256 weight,\n        uint256 totalWeight,\n        uint256 timestamp\n    );\n    event Abstained(\n        address indexed voter,\n        address indexed pool,\n        uint256 indexed tokenId,\n        uint256 weight,\n        uint256 totalWeight,\n        uint256 timestamp\n    );\n    event NotifyReward(\n        address indexed sender,\n        address indexed reward,\n        uint256 amount\n    );\n    event DistributeReward(\n        address indexed sender,\n        address indexed gauge,\n        uint256 amount\n    );\n    event WhitelistToken(\n        address indexed whitelister,\n        address indexed token,\n        bool indexed _bool\n    );\n    event WhitelistNFT(\n        address indexed whitelister,\n        uint256 indexed tokenId,\n        bool indexed _bool\n    );\n\n    /// @notice Store trusted forwarder address to pass into factories\n    function forwarder() external view returns (address);\n\n    /// @notice The ve token that governs these contracts\n    function ve() external view returns (address);\n\n    /// @notice Factory registry for valid pool / gauge / rewards factories\n    function factoryRegistry() external view returns (address);\n\n    /// @notice Address of a splitter contract\n    function splitter() external view returns (address);\n\n    /// @notice Standard OZ IGovernor using ve for vote weights.\n    function governor() external view returns (address);\n\n    /// @notice Custom Epoch Governor using ve for vote weights.\n    function epochGovernor() external view returns (address);\n\n    /// @notice credibly neutral party similar to Curve's Emergency DAO\n    function emergencyCouncil() external view returns (address);\n\n    /// @dev Total Voting Weights\n    function totalWeight() external view returns (uint256);\n\n    /// @dev Most number of pools one voter can vote for at once\n    function maxVotingNum() external view returns (uint256);\n\n    // mappings\n    /// @dev Pool => Gauge\n    function gauges(address pool) external view returns (address);\n\n    /// @dev Gauge => Pool\n    function poolForGauge(address gauge) external view returns (address);\n\n    /// @dev Gauge => Fees Voting Reward\n    function gaugeToFees(address gauge) external view returns (address);\n\n    /// @dev Gauge => Bribes Voting Reward\n    function gaugeToBribe(address gauge) external view returns (address);\n\n    /// @dev Pool => Weights\n    function weights(address pool) external view returns (uint256);\n\n    /// @dev NFT => Pool => Votes\n    function votes(\n        uint256 tokenId,\n        address pool\n    ) external view returns (uint256);\n\n    /// @dev NFT => Total voting weight of NFT\n    function usedWeights(uint256 tokenId) external view returns (uint256);\n\n    /// @dev Nft => Timestamp of last vote (ensures single vote per epoch)\n    function lastVoted(uint256 tokenId) external view returns (uint256);\n\n    /// @dev Address => Gauge\n    function isGauge(address) external view returns (bool);\n\n    /// @dev Token => Whitelisted status\n    function isWhitelistedToken(address token) external view returns (bool);\n\n    /// @dev TokenId => Whitelisted status\n    function isWhitelistedNFT(uint256 tokenId) external view returns (bool);\n\n    /// @dev Gauge => Liveness status\n    function isAlive(address gauge) external view returns (bool);\n\n    /// @dev Gauge => Amount claimable\n    function claimable(address gauge) external view returns (uint256);\n\n    /// @notice Number of pools with a Gauge\n    function length() external view returns (uint256);\n\n    /// @notice Called by Splitter to distribute weekly emissions rewards for disbursement amongst gauges.\n    /// @dev Assumes totalWeight != 0 (Will never be zero as long as users are voting).\n    ///      Throws if not called by splitter.\n    /// @param _amount Amount of rewards to distribute.\n    function notifyRewardAmount(uint256 _amount) external;\n\n    /// @dev Utility to distribute to gauges of pools in range _start to _finish.\n    /// @param _start   Starting index of gauges to distribute to.\n    /// @param _finish  Ending index of gauges to distribute to.\n    function distribute(uint256 _start, uint256 _finish) external;\n\n    /// @dev Utility to distribute to gauges of pools in array.\n    /// @param _gauges Array of gauges to distribute to.\n    function distribute(address[] memory _gauges) external;\n\n    /// @notice Called by users to update voting balances in voting rewards contracts.\n    /// @param _tokenId Id of veNFT whose balance you wish to update.\n    function poke(uint256 _tokenId) external;\n\n    /// @notice Called by users to vote for pools. Votes distributed proportionally based on weights.\n    ///         Can only vote or deposit into a managed NFT once per epoch.\n    ///         Can only vote for gauges that have not been killed.\n    /// @dev Weights are distributed proportional to the sum of the weights in the array.\n    ///      Throws if length of _poolVote and _weights do not match.\n    /// @param _tokenId     Id of veNFT you are voting with.\n    /// @param _poolVote    Array of pools you are voting for.\n    /// @param _weights     Weights of pools.\n    function vote(\n        uint256 _tokenId,\n        address[] calldata _poolVote,\n        uint256[] calldata _weights\n    ) external;\n\n    /// @notice Called by users to reset voting state. Required if you wish to make changes to\n    ///         veNFT state (e.g. merge, split, deposit into managed etc).\n    ///         Cannot reset in the same epoch that you voted in.\n    ///         Can vote or deposit into a managed NFT again after reset.\n    /// @param _tokenId Id of veNFT you are reseting.\n    function reset(uint256 _tokenId) external;\n\n    /// @notice Called by users to deposit into a managed NFT.\n    ///         Can only vote or deposit into a managed NFT once per epoch.\n    ///         Note that NFTs deposited into a managed NFT will be re-locked\n    ///         to the maximum lock time on withdrawal.\n    /// @dev Throws if not approved or owner.\n    ///      Throws if managed NFT is inactive.\n    ///      Throws if depositing within privileged window (one hour prior to epoch flip).\n    function depositManaged(uint256 _tokenId, uint256 _mTokenId) external;\n\n    /// @notice Called by users to withdraw from a managed NFT.\n    ///         Cannot do it in the same epoch that you deposited into a managed NFT.\n    ///         Can vote or deposit into a managed NFT again after withdrawing.\n    ///         Note that the NFT withdrawn is re-locked to the maximum lock time.\n    function withdrawManaged(uint256 _tokenId) external;\n\n    /// @notice Claim emissions from gauges.\n    /// @param _gauges Array of gauges to collect emissions from.\n    function claimRewards(address[] memory _gauges) external;\n\n    /// @notice Claim bribes for a given NFT.\n    /// @dev Utility to help batch bribe claims.\n    /// @param _bribes  Array of BribeVotingReward contracts to collect from.\n    /// @param _tokens  Array of tokens that are used as bribes.\n    /// @param _tokenId Id of veNFT that you wish to claim bribes for.\n    function claimBribes(\n        address[] memory _bribes,\n        address[][] memory _tokens,\n        uint256 _tokenId\n    ) external;\n\n    /// @notice Claim fees for a given NFT.\n    /// @dev Utility to help batch fee claims.\n    /// @param _fees    Array of FeesVotingReward contracts to collect from.\n    /// @param _tokens  Array of tokens that are used as fees.\n    /// @param _tokenId Id of veNFT that you wish to claim fees for.\n    function claimFees(\n        address[] memory _fees,\n        address[][] memory _tokens,\n        uint256 _tokenId\n    ) external;\n\n    /// @notice Set new governor.\n    /// @dev Throws if not called by governor.\n    /// @param _governor .\n    function setGovernor(address _governor) external;\n\n    /// @notice Set new epoch based governor.\n    /// @dev Throws if not called by governor.\n    /// @param _epochGovernor .\n    function setEpochGovernor(address _epochGovernor) external;\n\n    /// @notice Set new emergency council.\n    /// @dev Throws if not called by emergency council.\n    /// @param _emergencyCouncil .\n    function setEmergencyCouncil(address _emergencyCouncil) external;\n\n    /// @notice Set maximum number of gauges that can be voted for.\n    /// @dev Throws if not called by governor.\n    ///      Throws if _maxVotingNum is too low.\n    ///      Throws if the values are the same.\n    /// @param _maxVotingNum .\n    function setMaxVotingNum(uint256 _maxVotingNum) external;\n\n    /// @notice Whitelist (or unwhitelist) token for use in bribes.\n    /// @dev Throws if not called by governor.\n    /// @param _token .\n    /// @param _bool .\n    function whitelistToken(address _token, bool _bool) external;\n\n    /// @notice Whitelist (or unwhitelist) token id for voting in last hour prior to epoch flip.\n    /// @dev Throws if not called by governor.\n    ///      Throws if already whitelisted.\n    /// @param _tokenId .\n    /// @param _bool .\n    function whitelistNFT(uint256 _tokenId, bool _bool) external;\n\n    /// @notice Create a new gauge (unpermissioned).\n    /// @dev Governor can create a new gauge for a pool with any address.\n    /// @param _poolFactory .\n    /// @param _pool .\n    function createGauge(\n        address _poolFactory,\n        address _pool\n    ) external returns (address);\n\n    /// @notice Kills a gauge. The gauge will not receive any new emissions and cannot be deposited into.\n    ///         Can still withdraw from gauge.\n    /// @dev Throws if not called by emergency council.\n    ///      Throws if gauge already killed.\n    /// @param _gauge .\n    function killGauge(address _gauge) external;\n\n    /// @notice Revives a killed gauge. Gauge will can receive emissions and deposits again.\n    /// @dev Throws if not called by emergency council.\n    ///      Throws if gauge is not killed.\n    /// @param _gauge .\n    function reviveGauge(address _gauge) external;\n\n    /// @dev Update claims to emissions for an array of gauges.\n    /// @param _gauges Array of gauges to update emissions for.\n    function updateFor(address[] memory _gauges) external;\n\n    /// @dev Update claims to emissions for gauges based on their pool id as stored in Voter.\n    /// @param _start   Starting index of pools.\n    /// @param _end     Ending index of pools.\n    function updateFor(uint256 _start, uint256 _end) external;\n\n    /// @dev Update claims to emissions for single gauge\n    /// @param _gauge .\n    function updateFor(address _gauge) external;\n}\n"
    },
    "contracts/interfaces/IVotingEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IERC165, IERC721, IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {IERC6372} from \"@openzeppelin/contracts/interfaces/IERC6372.sol\";\nimport {IERC4906} from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\nimport {IVotes} from \"../governance/IVotes.sol\";\n\ninterface IVotingEscrow is IVotes, IERC4906, IERC6372, IERC721Metadata {\n    struct LockedBalance {\n        int128 amount;\n        uint256 end;\n        bool isPermanent;\n    }\n\n    struct UserPoint {\n        int128 bias;\n        int128 slope; // # -dweight / dt\n        uint256 ts;\n        uint256 blk; // block\n        uint256 permanent;\n    }\n\n    struct GlobalPoint {\n        int128 bias;\n        int128 slope; // # -dweight / dt\n        uint256 ts;\n        uint256 blk; // block\n        uint256 permanentLockBalance;\n    }\n\n    /// @notice A checkpoint for recorded delegated voting weights at a certain timestamp\n    struct Checkpoint {\n        uint256 fromTimestamp;\n        address owner;\n        uint256 delegatedBalance;\n        uint256 delegatee;\n    }\n\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME\n    }\n\n    /// @dev Different types of veNFTs:\n    /// NORMAL  - typical veNFT\n    /// LOCKED  - veNFT which is locked into a MANAGED veNFT\n    /// MANAGED - veNFT which can accept the deposit of NORMAL veNFTs\n    enum EscrowType {\n        NORMAL,\n        LOCKED,\n        MANAGED\n    }\n\n    error AlreadyVoted();\n    error AmountTooBig();\n    error ERC721ReceiverRejectedTokens();\n    error ERC721TransferToNonERC721ReceiverImplementer();\n    error InvalidNonce();\n    error InvalidSignature();\n    error InvalidSignatureS();\n    error InvalidManagedNFTId();\n    error LockDurationNotInFuture();\n    error LockDurationTooLong();\n    error LockExpired();\n    error LockNotExpired();\n    error NoLockFound();\n    error NonExistentToken();\n    error NotApprovedOrOwner();\n    error NotDistributor();\n    error NotEmergencyCouncilOrGovernor();\n    error NotGovernor();\n    error NotGovernorOrManager();\n    error NotManagedNFT();\n    error NotManagedOrNormalNFT();\n    error NotLockedNFT();\n    error NotNormalNFT();\n    error NotPermanentLock();\n    error NotOwner();\n    error NotTeam();\n    error NotVoter();\n    error OwnershipChange();\n    error PermanentLock();\n    error SameAddress();\n    error SameNFT();\n    error SameState();\n    error SplitNoOwner();\n    error SplitNotAllowed();\n    error SignatureExpired();\n    error TooManyTokenIDs();\n    error ZeroAddress();\n    error ZeroAmount();\n    error ZeroBalance();\n\n    event Deposit(\n        address indexed provider,\n        uint256 indexed tokenId,\n        DepositType indexed depositType,\n        uint256 value,\n        uint256 locktime,\n        uint256 ts\n    );\n    event Withdraw(\n        address indexed provider,\n        uint256 indexed tokenId,\n        uint256 value,\n        uint256 ts\n    );\n    event LockPermanent(\n        address indexed _owner,\n        uint256 indexed _tokenId,\n        uint256 amount,\n        uint256 _ts\n    );\n    event UnlockPermanent(\n        address indexed _owner,\n        uint256 indexed _tokenId,\n        uint256 amount,\n        uint256 _ts\n    );\n    event Supply(uint256 prevSupply, uint256 supply);\n    event Merge(\n        address indexed _sender,\n        uint256 indexed _from,\n        uint256 indexed _to,\n        uint256 _amountFrom,\n        uint256 _amountTo,\n        uint256 _amountFinal,\n        uint256 _locktime,\n        uint256 _ts\n    );\n    event Split(\n        uint256 indexed _from,\n        uint256 indexed _tokenId1,\n        uint256 indexed _tokenId2,\n        address _sender,\n        uint256 _splitAmount1,\n        uint256 _splitAmount2,\n        uint256 _locktime,\n        uint256 _ts\n    );\n    event CreateManaged(\n        address indexed _to,\n        uint256 indexed _mTokenId,\n        address indexed _from,\n        address _lockedManagedReward,\n        address _freeManagedReward\n    );\n    event DepositManaged(\n        address indexed _owner,\n        uint256 indexed _tokenId,\n        uint256 indexed _mTokenId,\n        uint256 _weight,\n        uint256 _ts\n    );\n    event WithdrawManaged(\n        address indexed _owner,\n        uint256 indexed _tokenId,\n        uint256 indexed _mTokenId,\n        uint256 _weight,\n        uint256 _ts\n    );\n    event SetAllowedManager(address indexed _allowedManager);\n\n    // State variables\n    /// @notice Address of Meta-tx Forwarder\n    function forwarder() external view returns (address);\n\n    /// @notice Address of FactoryRegistry.sol\n    function factoryRegistry() external view returns (address);\n\n    /// @notice Address of token used to create a veNFT\n    function token() external view returns (address);\n\n    /// @notice Address of RewardsDistributor.sol\n    function distributor() external view returns (address);\n\n    /// @notice Address of Voter.sol\n    function voter() external view returns (address);\n\n    /// @notice Address of Protocol Team multisig\n    function team() external view returns (address);\n\n    /// @dev address which can create managed NFTs\n    function allowedManager() external view returns (address);\n\n    /// @dev Current count of token\n    function tokenId() external view returns (uint256);\n\n    /*///////////////////////////////////////////////////////////////\n                            MANAGED NFT STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping of token id to escrow type\n    ///      Takes advantage of the fact default value is EscrowType.NORMAL\n    function escrowType(uint256 tokenId) external view returns (EscrowType);\n\n    /// @dev Mapping of token id to managed id\n    function idToManaged(\n        uint256 tokenId\n    ) external view returns (uint256 managedTokenId);\n\n    /// @dev Mapping of user token id to managed token id to weight of token id\n    function weights(\n        uint256 tokenId,\n        uint256 managedTokenId\n    ) external view returns (uint256 weight);\n\n    /// @dev Mapping of managed id to deactivated state\n    function deactivated(uint256 tokenId) external view returns (bool inactive);\n\n    /// @dev Mapping from managed nft id to locked managed rewards\n    ///      `token` denominated rewards (rebases/rewards) stored in locked managed rewards contract\n    ///      to prevent co-mingling of assets\n    function managedToLocked(uint256 tokenId) external view returns (address);\n\n    /// @dev Mapping from managed nft id to free managed rewards contract\n    ///      these rewards can be freely withdrawn by users\n    function managedToFree(uint256 tokenId) external view returns (address);\n\n    /*///////////////////////////////////////////////////////////////\n                            MANAGED NFT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Create managed NFT (a permanent lock) for use within ecosystem.\n    /// @dev Throws if address already owns a managed NFT.\n    /// @return _mTokenId managed token id.\n    function createManagedLockFor(\n        address _to\n    ) external returns (uint256 _mTokenId);\n\n    /// @notice Delegates balance to managed nft\n    ///         Note that NFTs deposited into a managed NFT will be re-locked\n    ///         to the maximum lock time on withdrawal.\n    ///         Permanent locks that are deposited will automatically unlock.\n    /// @dev Managed nft will remain max-locked as long as there is at least one\n    ///      deposit or withdrawal per week.\n    ///      Throws if deposit nft is managed.\n    ///      Throws if recipient nft is not managed.\n    ///      Throws if deposit nft is already locked.\n    ///      Throws if not called by voter.\n    /// @param _tokenId tokenId of NFT being deposited\n    /// @param _mTokenId tokenId of managed NFT that will receive the deposit\n    function depositManaged(uint256 _tokenId, uint256 _mTokenId) external;\n\n    /// @notice Retrieves locked rewards and withdraws balance from managed nft.\n    ///         Note that the NFT withdrawn is re-locked to the maximum lock time.\n    /// @dev Throws if NFT not locked.\n    ///      Throws if not called by voter.\n    /// @param _tokenId tokenId of NFT being deposited.\n    function withdrawManaged(uint256 _tokenId) external;\n\n    /// @notice Permit one address to call createManagedLockFor() that is not Voter.governor()\n    function setAllowedManager(address _allowedManager) external;\n\n    /// @notice Set Managed NFT state. Inactive NFTs cannot be deposited into.\n    /// @param _mTokenId managed nft state to set\n    /// @param _state true => inactive, false => active\n    function setManagedState(uint256 _mTokenId, bool _state) external;\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function version() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function setTeam(address _team) external;\n\n    /// @inheritdoc IERC721Metadata\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from owner address to mapping of index to tokenId\n    function ownerToNFTokenIdList(\n        address _owner,\n        uint256 _index\n    ) external view returns (uint256 _tokenId);\n\n    /// @inheritdoc IERC721\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /// @inheritdoc IERC721\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721\n    function getApproved(\n        uint256 _tokenId\n    ) external view returns (address operator);\n\n    /// @inheritdoc IERC721\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n\n    /// @notice Check whether spender is owner or an approved user for a given veNFT\n    /// @param _spender .\n    /// @param _tokenId .\n    function isApprovedOrOwner(\n        address _spender,\n        uint256 _tokenId\n    ) external returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721\n    function approve(address to, uint256 tokenId) external;\n\n    /// @inheritdoc IERC721\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /// @inheritdoc IERC721\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 _interfaceID\n    ) external view returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                             ESCROW STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Total count of epochs witnessed since contract creation\n    function epoch() external view returns (uint256);\n\n    /// @notice Total amount of token() deposited\n    function supply() external view returns (uint256);\n\n    /// @notice Aggregate permanent locked balances\n    function permanentLockBalance() external view returns (uint256);\n\n    function userPointEpoch(\n        uint256 _tokenId\n    ) external view returns (uint256 _epoch);\n\n    /// @notice time -> signed slope change\n    function slopeChanges(uint256 _timestamp) external view returns (int128);\n\n    /// @notice account -> can split\n    function canSplit(address _account) external view returns (bool);\n\n    /// @notice Global point history at a given index\n    function pointHistory(\n        uint256 _loc\n    ) external view returns (GlobalPoint memory);\n\n    /// @notice Get the LockedBalance (amount, end) of a _tokenId\n    /// @param _tokenId .\n    /// @return LockedBalance of _tokenId\n    function locked(\n        uint256 _tokenId\n    ) external view returns (LockedBalance memory);\n\n    /// @notice User -> UserPoint[userEpoch]\n    function userPointHistory(\n        uint256 _tokenId,\n        uint256 _loc\n    ) external view returns (UserPoint memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ESCROW LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Record global data to checkpoint\n    function checkpoint() external;\n\n    /// @notice Deposit `_value` tokens for `_tokenId` and add to the lock\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\n    ///      cannot extend their locktime and deposit for a brand new user\n    /// @param _tokenId lock NFT\n    /// @param _value Amount to add to user's lock\n    function depositFor(uint256 _tokenId, uint256 _value) external;\n\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lockDuration`\n    /// @param _value Amount to deposit\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @return TokenId of created veNFT\n    function createLock(\n        uint256 _value,\n        uint256 _lockDuration\n    ) external returns (uint256);\n\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lockDuration`\n    /// @param _value Amount to deposit\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    /// @return TokenId of created veNFT\n    function createLockFor(\n        uint256 _value,\n        uint256 _lockDuration,\n        address _to\n    ) external returns (uint256);\n\n    /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\n    /// @param _value Amount of tokens to deposit and add to the lock\n    function increaseAmount(uint256 _tokenId, uint256 _value) external;\n\n    /// @notice Extend the unlock time for `_tokenId`\n    ///         Cannot extend lock time of permanent locks\n    /// @param _lockDuration New number of seconds until tokens unlock\n    function increaseUnlockTime(\n        uint256 _tokenId,\n        uint256 _lockDuration\n    ) external;\n\n    /// @notice Withdraw all tokens for `_tokenId`\n    /// @dev Only possible if the lock is both expired and not permanent\n    ///      This will burn the veNFT. Any rebases or rewards that are unclaimed\n    ///      will no longer be claimable. Claim all rebases and rewards prior to calling this.\n    function withdraw(uint256 _tokenId) external;\n\n    /// @notice Merges `_from` into `_to`.\n    /// @dev Cannot merge `_from` locks that are permanent or have already voted this epoch.\n    ///      Cannot merge `_to` locks that have already expired.\n    ///      This will burn the veNFT. Any rebases or rewards that are unclaimed\n    ///      will no longer be claimable. Claim all rebases and rewards prior to calling this.\n    /// @param _from VeNFT to merge from.\n    /// @param _to VeNFT to merge into.\n    function merge(uint256 _from, uint256 _to) external;\n\n    /// @notice Splits veNFT into two new veNFTS - one with oldLocked.amount - `_amount`, and the second with `_amount`\n    /// @dev    This burns the tokenId of the target veNFT\n    ///         Callable by approved or owner\n    ///         If this is called by approved, approved will not have permissions to manipulate the newly created veNFTs\n    ///         Returns the two new split veNFTs to owner\n    ///         If `from` is permanent, will automatically dedelegate.\n    ///         This will burn the veNFT. Any rebases or rewards that are unclaimed\n    ///         will no longer be claimable. Claim all rebases and rewards prior to calling this.\n    /// @param _from VeNFT to split.\n    /// @param _amount Amount to split from veNFT.\n    /// @return _tokenId1 Return tokenId of veNFT with oldLocked.amount - `_amount`.\n    /// @return _tokenId2 Return tokenId of veNFT with `_amount`.\n    function split(\n        uint256 _from,\n        uint256 _amount\n    ) external returns (uint256 _tokenId1, uint256 _tokenId2);\n\n    /// @notice Toggle split for a specific address.\n    /// @dev Toggle split for address(0) to enable or disable for all.\n    /// @param _account Address to toggle split permissions\n    /// @param _bool True to allow, false to disallow\n    function toggleSplit(address _account, bool _bool) external;\n\n    /// @notice Permanently lock a veNFT. Voting power will be equal to\n    ///         `LockedBalance.amount` with no decay. Required to delegate.\n    /// @dev Only callable by unlocked normal veNFTs.\n    /// @param _tokenId tokenId to lock.\n    function lockPermanent(uint256 _tokenId) external;\n\n    /// @notice Unlock a permanently locked veNFT. Voting power will decay.\n    ///         Will automatically dedelegate if delegated.\n    /// @dev Only callable by permanently locked veNFTs.\n    ///      Cannot unlock if already voted this epoch.\n    /// @param _tokenId tokenId to unlock.\n    function unlockPermanent(uint256 _tokenId) external;\n\n    /*///////////////////////////////////////////////////////////////\n                           GAUGE VOTING STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Get the voting power for _tokenId at the current timestamp\n    /// @dev Returns 0 if called in the same block as a transfer.\n    /// @param _tokenId .\n    /// @return Voting power\n    function balanceOfNFT(uint256 _tokenId) external view returns (uint256);\n\n    /// @notice Get the voting power for _tokenId at a given timestamp\n    /// @param _tokenId .\n    /// @param _t Timestamp to query voting power\n    /// @return Voting power\n    function balanceOfNFTAt(\n        uint256 _tokenId,\n        uint256 _t\n    ) external view returns (uint256);\n\n    /// @notice Calculate total voting power at current timestamp\n    /// @return Total voting power at current timestamp\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Calculate total voting power at a given timestamp\n    /// @param _t Timestamp to query total voting power\n    /// @return Total voting power at given timestamp\n    function totalSupplyAt(uint256 _t) external view returns (uint256);\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE VOTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice See if a queried _tokenId has actively voted\n    /// @param _tokenId .\n    /// @return True if voted, else false\n    function voted(uint256 _tokenId) external view returns (bool);\n\n    /// @notice Set the global state voter and distributor\n    /// @dev This is only called once, at setup\n    function setVoterAndDistributor(\n        address _voter,\n        address _distributor\n    ) external;\n\n    /// @notice Set `voted` for _tokenId to true or false\n    /// @dev Only callable by voter\n    /// @param _tokenId .\n    /// @param _voted .\n    function voting(uint256 _tokenId, bool _voted) external;\n\n    /*///////////////////////////////////////////////////////////////\n                            DAO VOTING STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The number of checkpoints for each tokenId\n    function numCheckpoints(uint256 tokenId) external view returns (uint48);\n\n    /// @notice A record of states for signing / validating signatures\n    function nonces(address account) external view returns (uint256);\n\n    /// @inheritdoc IVotes\n    function delegates(uint256 delegator) external view returns (uint256);\n\n    /// @notice A record of delegated token checkpoints for each account, by index\n    /// @param tokenId .\n    /// @param index .\n    /// @return Checkpoint\n    function checkpoints(\n        uint256 tokenId,\n        uint48 index\n    ) external view returns (Checkpoint memory);\n\n    /// @inheritdoc IVotes\n    function getPastVotes(\n        address account,\n        uint256 tokenId,\n        uint256 timestamp\n    ) external view returns (uint256);\n\n    /// @inheritdoc IVotes\n    function getPastTotalSupply(\n        uint256 timestamp\n    ) external view returns (uint256);\n\n    /*///////////////////////////////////////////////////////////////\n                             DAO VOTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVotes\n    function delegate(uint256 delegator, uint256 delegatee) external;\n\n    /// @inheritdoc IVotes\n    function delegateBySig(\n        uint256 delegator,\n        uint256 delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC6372 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC6372\n    function clock() external view returns (uint48);\n\n    /// @inheritdoc IERC6372\n    function CLOCK_MODE() external view returns (string memory);\n}\n"
    },
    "contracts/libraries/ProtocolTimeLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nlibrary ProtocolTimeLibrary {\n    uint256 internal constant WEEK = 7 days;\n\n    /// @dev Returns start of epoch based on current timestamp\n    function epochStart(uint256 timestamp) internal pure returns (uint256) {\n        unchecked {\n            return timestamp - (timestamp % WEEK);\n        }\n    }\n\n    /// @dev Returns start of next epoch / end of current epoch\n    function epochNext(uint256 timestamp) internal pure returns (uint256) {\n        unchecked {\n            return timestamp - (timestamp % WEEK) + WEEK;\n        }\n    }\n\n    /// @dev Returns start of voting window\n    function epochVoteStart(uint256 timestamp) internal pure returns (uint256) {\n        unchecked {\n            return timestamp - (timestamp % WEEK) + 1 hours;\n        }\n    }\n\n    /// @dev Returns end of voting window / beginning of unrestricted voting window\n    function epochVoteEnd(uint256 timestamp) internal pure returns (uint256) {\n        unchecked {\n            return timestamp - (timestamp % WEEK) + WEEK - 1 hours;\n        }\n    }\n}\n"
    },
    "contracts/libraries/SafeCastLibrary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\n/// @title SafeCast Library\n/// @author velodrome.finance\n/// @notice Safely convert unsigned and signed integers without overflow / underflow\nlibrary SafeCastLibrary {\n    error SafeCastOverflow();\n    error SafeCastUnderflow();\n\n    /// @dev Safely convert uint256 to int128\n    function toInt128(uint256 value) internal pure returns (int128) {\n        if (value > uint128(type(int128).max)) revert SafeCastOverflow();\n        return int128(uint128(value));\n    }\n\n    /// @dev Safely convert int128 to uint256\n    function toUint256(int128 value) internal pure returns (uint256) {\n        if (value < 0) revert SafeCastUnderflow();\n        return uint256(int256(value));\n    }\n}\n"
    },
    "contracts/Mezo.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.24;\n\nimport {IMezo} from \"./interfaces/IMezo.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\n\ncontract Mezo is IMezo, ERC20Permit {\n    address public minter;\n    address private owner;\n\n    constructor() ERC20(\"Mezo\", \"MEZO\") ERC20Permit(\"Mezo\") {\n        minter = msg.sender;\n        owner = msg.sender;\n    }\n\n    // No checks as its meant to be once off to set minting rights to BaseV1 Minter\n    function setMinter(address _minter) external {\n        if (msg.sender != minter) revert NotMinter();\n        minter = _minter;\n    }\n\n    function mint(address account, uint256 amount) external returns (bool) {\n        if (msg.sender != minter) revert NotMinter();\n        _mint(account, amount);\n        return true;\n    }\n}\n"
    },
    "contracts/MezoGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IVotes} from \"./governance/IVotes.sol\";\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\n\nimport {IVetoGovernor} from \"./governance/IVetoGovernor.sol\";\nimport {VetoGovernor} from \"./governance/VetoGovernor.sol\";\nimport {VetoGovernorCountingSimple} from \"./governance/VetoGovernorCountingSimple.sol\";\nimport {VetoGovernorVotes} from \"./governance/VetoGovernorVotes.sol\";\nimport {VetoGovernorVotesQuorumFraction} from \"./governance/VetoGovernorVotesQuorumFraction.sol\";\n\ncontract MezoGovernor is\n    VetoGovernor,\n    VetoGovernorCountingSimple,\n    VetoGovernorVotes,\n    VetoGovernorVotesQuorumFraction\n{\n    address public immutable ve;\n    address public vetoer;\n    address public pendingVetoer;\n    uint256 public constant MAX_PROPOSAL_NUMERATOR = 500; // max 5%\n    uint256 public constant PROPOSAL_DENOMINATOR = 10_000;\n    uint256 public proposalNumerator = 2; // start at 0.02%\n\n    error NotTeam();\n    error NotPendingVetoer();\n    error NotVetoer();\n    error ProposalNumeratorTooHigh();\n    error ZeroAddress();\n\n    constructor(\n        IVotes _ve\n    )\n        VetoGovernor(\"Mezo Governor\")\n        VetoGovernorVotes(_ve)\n        VetoGovernorVotesQuorumFraction(4) // 4%\n    {\n        ve = address(_ve);\n        vetoer = msg.sender;\n    }\n\n    function votingDelay()\n        public\n        pure\n        override(IVetoGovernor)\n        returns (uint256)\n    {\n        return (15 minutes);\n    }\n\n    function votingPeriod()\n        public\n        pure\n        override(IVetoGovernor)\n        returns (uint256)\n    {\n        return (1 weeks);\n    }\n\n    function setProposalNumerator(uint256 numerator) external {\n        if (msg.sender != IVotingEscrow(ve).team()) revert NotTeam();\n        if (numerator > MAX_PROPOSAL_NUMERATOR)\n            revert ProposalNumeratorTooHigh();\n        proposalNumerator = numerator;\n    }\n\n    function proposalThreshold()\n        public\n        view\n        override(VetoGovernor)\n        returns (uint256)\n    {\n        return\n            (token.getPastTotalSupply(block.timestamp - 1) *\n                proposalNumerator) / PROPOSAL_DENOMINATOR;\n    }\n\n    /// @dev Vetoer can be removed once the risk of a 51% attack becomes unfeasible.\n    ///      This can be done by transferring ownership of vetoer to a contract that is \"bricked\"\n    ///      i.e. a non-zero address contract that is immutable with no ability to call this function.\n    function setVetoer(address _vetoer) external {\n        if (msg.sender != vetoer) revert NotVetoer();\n        if (_vetoer == address(0)) revert ZeroAddress();\n        pendingVetoer = _vetoer;\n    }\n\n    function acceptVetoer() external {\n        if (msg.sender != pendingVetoer) revert NotPendingVetoer();\n        vetoer = pendingVetoer;\n        delete pendingVetoer;\n    }\n\n    /// @notice Support for vetoer to protect against 51% attacks\n    function veto(uint256 _proposalId) external {\n        if (msg.sender != vetoer) revert NotVetoer();\n        _veto(_proposalId);\n    }\n\n    function renounceVetoer() external {\n        if (msg.sender != vetoer) revert NotVetoer();\n        delete vetoer;\n    }\n}\n"
    },
    "contracts/Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IPool} from \"./interfaces/IPool.sol\";\nimport {IVoter} from \"./interfaces/IVoter.sol\";\nimport {IPoolCallee} from \"./interfaces/IPoolCallee.sol\";\nimport {IPoolFactory} from \"./interfaces/factories/IPoolFactory.sol\";\nimport {PoolFees} from \"./PoolFees.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title Pool\n/// @author velodrome.finance, @figs999, @pegahcarter\n/// @notice Protocol token pool, either stable or volatile\ncontract Pool is IPool, ERC20Permit, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    string private _name;\n    string private _symbol;\n    address private _voter;\n\n    /// @inheritdoc IPool\n    bool public stable;\n\n    uint256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    uint256 internal constant MINIMUM_K = 10 ** 10;\n\n    /// @inheritdoc IPool\n    address public token0;\n    /// @inheritdoc IPool\n    address public token1;\n    /// @inheritdoc IPool\n    address public poolFees;\n    /// @inheritdoc IPool\n    address public factory;\n\n    uint256 public constant PERIOD_SIZE = 1800;\n\n    Observation[] public observations;\n\n    uint256 internal decimals0;\n    uint256 internal decimals1;\n\n    /// @inheritdoc IPool\n    uint256 public reserve0;\n    /// @inheritdoc IPool\n    uint256 public reserve1;\n    /// @inheritdoc IPool\n    uint256 public blockTimestampLast;\n\n    /// @inheritdoc IPool\n    uint256 public reserve0CumulativeLast;\n    /// @inheritdoc IPool\n    uint256 public reserve1CumulativeLast;\n\n    /// @inheritdoc IPool\n    uint256 public index0 = 0;\n    /// @inheritdoc IPool\n    uint256 public index1 = 0;\n\n    /// @inheritdoc IPool\n    mapping(address => uint256) public supplyIndex0;\n    /// @inheritdoc IPool\n    mapping(address => uint256) public supplyIndex1;\n\n    /// @inheritdoc IPool\n    mapping(address => uint256) public claimable0;\n    /// @inheritdoc IPool\n    mapping(address => uint256) public claimable1;\n\n    constructor() ERC20(\"\", \"\") ERC20Permit(\"\") {}\n\n    /// @inheritdoc IPool\n    function initialize(\n        address _token0,\n        address _token1,\n        bool _stable\n    ) external {\n        if (factory != address(0)) revert FactoryAlreadySet();\n        factory = _msgSender();\n        _voter = IPoolFactory(factory).voter();\n        (token0, token1, stable) = (_token0, _token1, _stable);\n        poolFees = address(new PoolFees(_token0, _token1));\n        string memory symbol0 = ERC20(_token0).symbol();\n        string memory symbol1 = ERC20(_token1).symbol();\n        if (_stable) {\n            _name = string(\n                abi.encodePacked(\"Stable AMM - \", symbol0, \"/\", symbol1)\n            );\n            _symbol = string(abi.encodePacked(\"sAMM-\", symbol0, \"/\", symbol1));\n        } else {\n            _name = string(\n                abi.encodePacked(\"Volatile AMM - \", symbol0, \"/\", symbol1)\n            );\n            _symbol = string(abi.encodePacked(\"vAMM-\", symbol0, \"/\", symbol1));\n        }\n\n        decimals0 = 10 ** ERC20(_token0).decimals();\n        decimals1 = 10 ** ERC20(_token1).decimals();\n\n        observations.push(Observation(block.timestamp, 0, 0));\n    }\n\n    /// @inheritdoc IPool\n    function setName(string calldata __name) external {\n        if (msg.sender != IVoter(_voter).emergencyCouncil())\n            revert NotEmergencyCouncil();\n        _name = __name;\n    }\n\n    /// @inheritdoc IPool\n    function setSymbol(string calldata __symbol) external {\n        if (msg.sender != IVoter(_voter).emergencyCouncil())\n            revert NotEmergencyCouncil();\n        _symbol = __symbol;\n    }\n\n    /// @inheritdoc IPool\n    function observationLength() external view returns (uint256) {\n        return observations.length;\n    }\n\n    /// @inheritdoc IPool\n    function lastObservation() public view returns (Observation memory) {\n        return observations[observations.length - 1];\n    }\n\n    /// @inheritdoc IPool\n    function metadata()\n        external\n        view\n        returns (\n            uint256 dec0,\n            uint256 dec1,\n            uint256 r0,\n            uint256 r1,\n            bool st,\n            address t0,\n            address t1\n        )\n    {\n        return (\n            decimals0,\n            decimals1,\n            reserve0,\n            reserve1,\n            stable,\n            token0,\n            token1\n        );\n    }\n\n    /// @inheritdoc IPool\n    function tokens() external view returns (address, address) {\n        return (token0, token1);\n    }\n\n    /// @inheritdoc IPool\n    function getK() external nonReentrant returns (uint256) {\n        return _k(reserve0, reserve1);\n    }\n\n    /// @inheritdoc IPool\n    function claimFees() external returns (uint256 claimed0, uint256 claimed1) {\n        address sender = _msgSender();\n        _updateFor(sender);\n\n        claimed0 = claimable0[sender];\n        claimed1 = claimable1[sender];\n\n        if (claimed0 > 0 || claimed1 > 0) {\n            claimable0[sender] = 0;\n            claimable1[sender] = 0;\n\n            PoolFees(poolFees).claimFeesFor(sender, claimed0, claimed1);\n\n            emit Claim(sender, sender, claimed0, claimed1);\n        }\n    }\n\n    /// @dev Accrue fees on token0\n    function _update0(uint256 amount) internal {\n        // Only update on this pool if there is a fee\n        if (amount == 0) return;\n        IERC20(token0).safeTransfer(poolFees, amount); // transfer the fees out to PoolFees\n        uint256 _ratio = (amount * 1e18) / totalSupply(); // 1e18 adjustment is removed during claim\n        if (_ratio > 0) {\n            index0 += _ratio;\n        }\n        emit Fees(_msgSender(), amount, 0);\n    }\n\n    /// @dev Accrue fees on token1\n    function _update1(uint256 amount) internal {\n        // Only update on this pool if there is a fee\n        if (amount == 0) return;\n        IERC20(token1).safeTransfer(poolFees, amount);\n        uint256 _ratio = (amount * 1e18) / totalSupply();\n        if (_ratio > 0) {\n            index1 += _ratio;\n        }\n        emit Fees(_msgSender(), 0, amount);\n    }\n\n    /// @dev This function MUST be called on any balance changes, otherwise can be used to infinitely claim fees\n    ///      Fees are segregated from core funds, so fees can never put liquidity at risk.\n    function _updateFor(address recipient) internal {\n        uint256 _supplied = balanceOf(recipient); // get LP balance of `recipient`\n        if (_supplied > 0) {\n            uint256 _supplyIndex0 = supplyIndex0[recipient]; // get last adjusted index0 for recipient\n            uint256 _supplyIndex1 = supplyIndex1[recipient];\n            uint256 _index0 = index0; // get global index0 for accumulated fees\n            uint256 _index1 = index1;\n            supplyIndex0[recipient] = _index0; // update user current position to global position\n            supplyIndex1[recipient] = _index1;\n            uint256 _delta0 = _index0 - _supplyIndex0; // see if there is any difference that need to be accrued\n            uint256 _delta1 = _index1 - _supplyIndex1;\n            if (_delta0 > 0) {\n                uint256 _share = (_supplied * _delta0) / 1e18; // add accrued difference for each supplied token\n                claimable0[recipient] += _share;\n            }\n            if (_delta1 > 0) {\n                uint256 _share = (_supplied * _delta1) / 1e18;\n                claimable1[recipient] += _share;\n            }\n        } else {\n            supplyIndex0[recipient] = index0; // new users are set to the default global state\n            supplyIndex1[recipient] = index1;\n        }\n    }\n\n    /// @inheritdoc IPool\n    function getReserves()\n        public\n        view\n        returns (\n            uint256 _reserve0,\n            uint256 _reserve1,\n            uint256 _blockTimestampLast\n        )\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    /// @dev update reserves and, on the first call per block, price accumulators\n    function _update(\n        uint256 balance0,\n        uint256 balance1,\n        uint256 _reserve0,\n        uint256 _reserve1\n    ) internal {\n        uint256 blockTimestamp = block.timestamp;\n        uint256 timeElapsed = blockTimestamp - blockTimestampLast;\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            reserve0CumulativeLast += _reserve0 * timeElapsed;\n            reserve1CumulativeLast += _reserve1 * timeElapsed;\n        }\n\n        Observation memory _point = lastObservation();\n        timeElapsed = blockTimestamp - _point.timestamp; // compare the last observation with current timestamp, if greater than 30 minutes, record a new event\n        if (timeElapsed > PERIOD_SIZE) {\n            observations.push(\n                Observation(\n                    blockTimestamp,\n                    reserve0CumulativeLast,\n                    reserve1CumulativeLast\n                )\n            );\n        }\n        reserve0 = balance0;\n        reserve1 = balance1;\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    /// @inheritdoc IPool\n    function currentCumulativePrices()\n        public\n        view\n        returns (\n            uint256 reserve0Cumulative,\n            uint256 reserve1Cumulative,\n            uint256 blockTimestamp\n        )\n    {\n        blockTimestamp = block.timestamp;\n        reserve0Cumulative = reserve0CumulativeLast;\n        reserve1Cumulative = reserve1CumulativeLast;\n\n        // if time has elapsed since the last update on the pool, mock the accumulated price values\n        (\n            uint256 _reserve0,\n            uint256 _reserve1,\n            uint256 _blockTimestampLast\n        ) = getReserves();\n        if (_blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint256 timeElapsed = blockTimestamp - _blockTimestampLast;\n            reserve0Cumulative += _reserve0 * timeElapsed;\n            reserve1Cumulative += _reserve1 * timeElapsed;\n        }\n    }\n\n    /// @inheritdoc IPool\n    function quote(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 granularity\n    ) external view returns (uint256 amountOut) {\n        uint256[] memory _prices = sample(tokenIn, amountIn, granularity, 1);\n        uint256 priceAverageCumulative;\n        uint256 _length = _prices.length;\n        for (uint256 i = 0; i < _length; i++) {\n            priceAverageCumulative += _prices[i];\n        }\n        return priceAverageCumulative / granularity;\n    }\n\n    /// @inheritdoc IPool\n    function prices(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 points\n    ) external view returns (uint256[] memory) {\n        return sample(tokenIn, amountIn, points, 1);\n    }\n\n    /// @inheritdoc IPool\n    function sample(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 points,\n        uint256 window\n    ) public view returns (uint256[] memory) {\n        uint256[] memory _prices = new uint256[](points);\n\n        uint256 length = observations.length - 1;\n        uint256 i = length - (points * window);\n        uint256 nextIndex = 0;\n        uint256 index = 0;\n\n        for (; i < length; i += window) {\n            nextIndex = i + window;\n            uint256 timeElapsed = observations[nextIndex].timestamp -\n                observations[i].timestamp;\n            uint256 _reserve0 = (observations[nextIndex].reserve0Cumulative -\n                observations[i].reserve0Cumulative) / timeElapsed;\n            uint256 _reserve1 = (observations[nextIndex].reserve1Cumulative -\n                observations[i].reserve1Cumulative) / timeElapsed;\n            _prices[index] = _getAmountOut(\n                amountIn,\n                tokenIn,\n                _reserve0,\n                _reserve1\n            );\n            // index < length; length cannot overflow\n            unchecked {\n                index = index + 1;\n            }\n        }\n        return _prices;\n    }\n\n    /// @inheritdoc IPool\n    function mint(\n        address to\n    ) external nonReentrant returns (uint256 liquidity) {\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        uint256 _balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 _balance1 = IERC20(token1).balanceOf(address(this));\n        uint256 _amount0 = _balance0 - _reserve0;\n        uint256 _amount1 = _balance1 - _reserve1;\n\n        uint256 _totalSupply = totalSupply(); // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(_amount0 * _amount1) - MINIMUM_LIQUIDITY;\n            _mint(address(1), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens - cannot be address(0)\n            if (stable) {\n                if (\n                    (_amount0 * 1e18) / decimals0 !=\n                    (_amount1 * 1e18) / decimals1\n                ) revert DepositsNotEqual();\n                if (_k(_amount0, _amount1) <= MINIMUM_K) revert BelowMinimumK();\n            }\n        } else {\n            liquidity = Math.min(\n                (_amount0 * _totalSupply) / _reserve0,\n                (_amount1 * _totalSupply) / _reserve1\n            );\n        }\n        if (liquidity == 0) revert InsufficientLiquidityMinted();\n        _mint(to, liquidity);\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Mint(_msgSender(), _amount0, _amount1);\n    }\n\n    /// @inheritdoc IPool\n    function burn(\n        address to\n    ) external nonReentrant returns (uint256 amount0, uint256 amount1) {\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        (address _token0, address _token1) = (token0, token1);\n        uint256 _balance0 = IERC20(_token0).balanceOf(address(this));\n        uint256 _balance1 = IERC20(_token1).balanceOf(address(this));\n        uint256 _liquidity = balanceOf(address(this));\n\n        uint256 _totalSupply = totalSupply(); // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = (_liquidity * _balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = (_liquidity * _balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        if (amount0 == 0 || amount1 == 0) revert InsufficientLiquidityBurned();\n        _burn(address(this), _liquidity);\n        IERC20(_token0).safeTransfer(to, amount0);\n        IERC20(_token1).safeTransfer(to, amount1);\n        _balance0 = IERC20(_token0).balanceOf(address(this));\n        _balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Burn(_msgSender(), to, amount0, amount1);\n    }\n\n    /// @inheritdoc IPool\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external nonReentrant {\n        if (IPoolFactory(factory).isPaused()) revert IsPaused();\n        if (amount0Out == 0 && amount1Out == 0)\n            revert InsufficientOutputAmount();\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        if (amount0Out >= _reserve0 || amount1Out >= _reserve1)\n            revert InsufficientLiquidity();\n\n        uint256 _balance0;\n        uint256 _balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            (address _token0, address _token1) = (token0, token1);\n            if (to == _token0 || to == _token1) revert InvalidTo();\n            if (amount0Out > 0) IERC20(_token0).safeTransfer(to, amount0Out); // optimistically transfer tokens\n            if (amount1Out > 0) IERC20(_token1).safeTransfer(to, amount1Out); // optimistically transfer tokens\n            if (data.length > 0)\n                IPoolCallee(to).hook(\n                    _msgSender(),\n                    amount0Out,\n                    amount1Out,\n                    data\n                ); // callback, used for flash loans\n            _balance0 = IERC20(_token0).balanceOf(address(this));\n            _balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint256 amount0In = _balance0 > _reserve0 - amount0Out\n            ? _balance0 - (_reserve0 - amount0Out)\n            : 0;\n        uint256 amount1In = _balance1 > _reserve1 - amount1Out\n            ? _balance1 - (_reserve1 - amount1Out)\n            : 0;\n        if (amount0In == 0 && amount1In == 0) revert InsufficientInputAmount();\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            (address _token0, address _token1) = (token0, token1);\n            if (amount0In > 0)\n                _update0(\n                    (amount0In *\n                        IPoolFactory(factory).getFee(address(this), stable)) /\n                        10000\n                ); // accrue fees for token0 and move them out of pool\n            if (amount1In > 0)\n                _update1(\n                    (amount1In *\n                        IPoolFactory(factory).getFee(address(this), stable)) /\n                        10000\n                ); // accrue fees for token1 and move them out of pool\n            _balance0 = IERC20(_token0).balanceOf(address(this)); // since we removed tokens, we need to reconfirm balances, can also simply use previous balance - amountIn/ 10000, but doing balanceOf again as safety check\n            _balance1 = IERC20(_token1).balanceOf(address(this));\n            // The curve, either x3y+y3x for stable pools, or x*y for volatile pools\n            if (_k(_balance0, _balance1) < _k(_reserve0, _reserve1)) revert K();\n        }\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Swap(\n            _msgSender(),\n            to,\n            amount0In,\n            amount1In,\n            amount0Out,\n            amount1Out\n        );\n    }\n\n    /// @inheritdoc IPool\n    function skim(address to) external nonReentrant {\n        (address _token0, address _token1) = (token0, token1);\n        IERC20(_token0).safeTransfer(\n            to,\n            IERC20(_token0).balanceOf(address(this)) - (reserve0)\n        );\n        IERC20(_token1).safeTransfer(\n            to,\n            IERC20(_token1).balanceOf(address(this)) - (reserve1)\n        );\n    }\n\n    /// @inheritdoc IPool\n    function sync() external nonReentrant {\n        _update(\n            IERC20(token0).balanceOf(address(this)),\n            IERC20(token1).balanceOf(address(this)),\n            reserve0,\n            reserve1\n        );\n    }\n\n    function _f(uint256 x0, uint256 y) internal pure returns (uint256) {\n        uint256 _a = (x0 * y) / 1e18;\n        uint256 _b = ((x0 * x0) / 1e18 + (y * y) / 1e18);\n        return (_a * _b) / 1e18;\n    }\n\n    function _d(uint256 x0, uint256 y) internal pure returns (uint256) {\n        return\n            (3 * x0 * ((y * y) / 1e18)) /\n            1e18 +\n            ((((x0 * x0) / 1e18) * x0) / 1e18);\n    }\n\n    function _get_y(\n        uint256 x0,\n        uint256 xy,\n        uint256 y\n    ) internal view returns (uint256) {\n        for (uint256 i = 0; i < 255; i++) {\n            uint256 k = _f(x0, y);\n            if (k < xy) {\n                // there are two cases where dy == 0\n                // case 1: The y is converged and we find the correct answer\n                // case 2: _d(x0, y) is too large compare to (xy - k) and the rounding error\n                //         screwed us.\n                //         In this case, we need to increase y by 1\n                uint256 dy = ((xy - k) * 1e18) / _d(x0, y);\n                if (dy == 0) {\n                    if (k == xy) {\n                        // We found the correct answer. Return y\n                        return y;\n                    }\n                    if (_k(x0, y + 1) > xy) {\n                        // If _k(x0, y + 1) > xy, then we are close to the correct answer.\n                        // There's no closer answer than y + 1\n                        return y + 1;\n                    }\n                    dy = 1;\n                }\n                y = y + dy;\n            } else {\n                uint256 dy = ((k - xy) * 1e18) / _d(x0, y);\n                if (dy == 0) {\n                    if (k == xy || _f(x0, y - 1) < xy) {\n                        // Likewise, if k == xy, we found the correct answer.\n                        // If _f(x0, y - 1) < xy, then we are close to the correct answer.\n                        // There's no closer answer than \"y\"\n                        // It's worth mentioning that we need to find y where f(x0, y) >= xy\n                        // As a result, we can't return y - 1 even it's closer to the correct answer\n                        return y;\n                    }\n                    dy = 1;\n                }\n                y = y - dy;\n            }\n        }\n        revert(\"!y\");\n    }\n\n    /// @inheritdoc IPool\n    function getAmountOut(\n        uint256 amountIn,\n        address tokenIn\n    ) external view returns (uint256) {\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        amountIn -=\n            (amountIn * IPoolFactory(factory).getFee(address(this), stable)) /\n            10000; // remove fee from amount received\n        return _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\n    }\n\n    function _getAmountOut(\n        uint256 amountIn,\n        address tokenIn,\n        uint256 _reserve0,\n        uint256 _reserve1\n    ) internal view returns (uint256) {\n        if (stable) {\n            uint256 xy = _k(_reserve0, _reserve1);\n            _reserve0 = (_reserve0 * 1e18) / decimals0;\n            _reserve1 = (_reserve1 * 1e18) / decimals1;\n            (uint256 reserveA, uint256 reserveB) = tokenIn == token0\n                ? (_reserve0, _reserve1)\n                : (_reserve1, _reserve0);\n            amountIn = tokenIn == token0\n                ? (amountIn * 1e18) / decimals0\n                : (amountIn * 1e18) / decimals1;\n            uint256 y = reserveB - _get_y(amountIn + reserveA, xy, reserveB);\n            return (y * (tokenIn == token0 ? decimals1 : decimals0)) / 1e18;\n        } else {\n            (uint256 reserveA, uint256 reserveB) = tokenIn == token0\n                ? (_reserve0, _reserve1)\n                : (_reserve1, _reserve0);\n            return (amountIn * reserveB) / (reserveA + amountIn);\n        }\n    }\n\n    function _k(uint256 x, uint256 y) internal view returns (uint256) {\n        if (stable) {\n            uint256 _x = (x * 1e18) / decimals0;\n            uint256 _y = (y * 1e18) / decimals1;\n            uint256 _a = (_x * _y) / 1e18;\n            uint256 _b = ((_x * _x) / 1e18 + (_y * _y) / 1e18);\n            return (_a * _b) / 1e18; // x3y+y3x >= k\n        } else {\n            return x * y; // xy >= k\n        }\n    }\n\n    /*\n    @dev OZ inheritance overrides\n    These are needed as _name and _symbol are set privately before\n    logic is executed within the constructor to set _name and _symbol.\n    */\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    function periodSize() external view returns (uint256) {\n        return PERIOD_SIZE;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256\n    ) internal override {\n        _updateFor(from);\n        _updateFor(to);\n    }\n}\n"
    },
    "contracts/PoolFees.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @notice Contract used as 1:1 pool relationship to split out fees. Ensures curve does not need to be modified for LP shares.\ncontract PoolFees {\n    using SafeERC20 for IERC20;\n    address internal immutable pool; // The pool it is bonded to\n    address internal immutable token0; // token0 of pool, saved locally and statically for gas optimization\n    address internal immutable token1; // Token1 of pool, saved locally and statically for gas optimization\n\n    error NotPool();\n\n    constructor(address _token0, address _token1) {\n        pool = msg.sender;\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    /// @notice Allow the pool to transfer fees to users\n    function claimFeesFor(\n        address _recipient,\n        uint256 _amount0,\n        uint256 _amount1\n    ) external {\n        if (msg.sender != pool) revert NotPool();\n        if (_amount0 > 0) IERC20(token0).safeTransfer(_recipient, _amount0);\n        if (_amount1 > 0) IERC20(token1).safeTransfer(_recipient, _amount1);\n    }\n}\n"
    },
    "contracts/rewards/BribeVotingReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IVoter} from \"../interfaces/IVoter.sol\";\nimport {VotingReward} from \"./VotingReward.sol\";\n\n/// @notice Bribes pay out rewards for a given pool based on the votes that were received from the user (goes hand in hand with Voter.vote())\ncontract BribeVotingReward is VotingReward {\n    constructor(\n        address _forwarder,\n        address _voter,\n        address[] memory _rewards\n    ) VotingReward(_forwarder, _voter, _rewards) {}\n\n    /// @inheritdoc VotingReward\n    function notifyRewardAmount(\n        address token,\n        uint256 amount\n    ) external override nonReentrant {\n        address sender = _msgSender();\n\n        if (!isReward[token]) {\n            if (!IVoter(voter).isWhitelistedToken(token))\n                revert NotWhitelisted();\n            isReward[token] = true;\n            rewards.push(token);\n        }\n\n        _notifyRewardAmount(sender, token, amount);\n    }\n}\n"
    },
    "contracts/rewards/FeesVotingReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {VotingReward} from \"./VotingReward.sol\";\nimport {IVoter} from \"../interfaces/IVoter.sol\";\n\n/// @notice Bribes pay out rewards for a given pool based on the votes that were received from the user (goes hand in hand with Voter.vote())\ncontract FeesVotingReward is VotingReward {\n    constructor(\n        address _forwarder,\n        address _voter,\n        address[] memory _rewards\n    ) VotingReward(_forwarder, _voter, _rewards) {}\n\n    /// @inheritdoc VotingReward\n    function notifyRewardAmount(\n        address token,\n        uint256 amount\n    ) external override nonReentrant {\n        address sender = _msgSender();\n        if (IVoter(voter).gaugeToFees(sender) != address(this))\n            revert NotGauge();\n        if (!isReward[token]) revert InvalidReward();\n\n        _notifyRewardAmount(sender, token, amount);\n    }\n}\n"
    },
    "contracts/rewards/FreeManagedReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {ManagedReward} from \"./ManagedReward.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\nimport {IVoter} from \"../interfaces/IVoter.sol\";\n\n/// @notice Stores rewards that are free to be distributed\n/// @dev Rewards are distributed based on weight contribution to managed nft\ncontract FreeManagedReward is ManagedReward {\n    constructor(\n        address _forwarder,\n        address _voter\n    ) ManagedReward(_forwarder, _voter) {}\n\n    /// @inheritdoc ManagedReward\n    function getReward(\n        uint256 tokenId,\n        address[] memory tokens\n    ) external override nonReentrant {\n        if (!IVotingEscrow(ve).isApprovedOrOwner(_msgSender(), tokenId))\n            revert NotAuthorized();\n\n        address owner = IVotingEscrow(ve).ownerOf(tokenId);\n\n        _getReward(owner, tokenId, tokens);\n    }\n\n    /// @inheritdoc ManagedReward\n    function notifyRewardAmount(\n        address token,\n        uint256 amount\n    ) external override nonReentrant {\n        address sender = _msgSender();\n        if (!isReward[token]) {\n            if (!IVoter(voter).isWhitelistedToken(token))\n                revert NotWhitelisted();\n            isReward[token] = true;\n            rewards.push(token);\n        }\n\n        _notifyRewardAmount(sender, token, amount);\n    }\n}\n"
    },
    "contracts/rewards/LockedManagedReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {ManagedReward} from \"./ManagedReward.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\n\n/// @notice Stores rewards that are max-locked (i.e. rebases / tokens that were compounded)\n/// @dev Rewards are distributed based on weight contribution to managed nft\ncontract LockedManagedReward is ManagedReward {\n    constructor(\n        address _forwarder,\n        address _voter\n    ) ManagedReward(_forwarder, _voter) {}\n\n    /// @inheritdoc ManagedReward\n    /// @dev Called by VotingEscrow to retrieve locked rewards\n    function getReward(\n        uint256 tokenId,\n        address[] memory tokens\n    ) external override nonReentrant {\n        address sender = _msgSender();\n        if (sender != ve) revert NotVotingEscrow();\n        if (tokens.length != 1) revert NotSingleToken();\n        if (tokens[0] != IVotingEscrow(ve).token()) revert NotEscrowToken();\n\n        _getReward(sender, tokenId, tokens);\n    }\n\n    /// @inheritdoc ManagedReward\n    /// @dev Called by VotingEscrow to add rebases / compounded rewards for disbursement\n    function notifyRewardAmount(\n        address token,\n        uint256 amount\n    ) external override nonReentrant {\n        address sender = _msgSender();\n        if (sender != ve) revert NotVotingEscrow();\n        if (token != IVotingEscrow(ve).token()) revert NotEscrowToken();\n\n        _notifyRewardAmount(sender, token, amount);\n    }\n}\n"
    },
    "contracts/rewards/ManagedReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {Reward} from \"./Reward.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\nimport {IVoter} from \"../interfaces/IVoter.sol\";\n\n/// @title Base managed veNFT reward contract for distribution of rewards by token id\nabstract contract ManagedReward is Reward {\n    constructor(address _forwarder, address _voter) Reward(_forwarder, _voter) {\n        address _ve = IVoter(_voter).ve();\n        address _token = IVotingEscrow(_ve).token();\n        rewards.push(_token);\n        isReward[_token] = true;\n\n        authorized = _ve;\n    }\n\n    /// @inheritdoc Reward\n    function getReward(\n        uint256 tokenId,\n        address[] memory tokens\n    ) external virtual override {}\n\n    /// @inheritdoc Reward\n    function notifyRewardAmount(\n        address token,\n        uint256 amount\n    ) external virtual override {}\n}\n"
    },
    "contracts/rewards/Reward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IReward} from \"../interfaces/IReward.sol\";\nimport {IVoter} from \"../interfaces/IVoter.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC2771Context} from \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {ProtocolTimeLibrary} from \"../libraries/ProtocolTimeLibrary.sol\";\n\n/// @title Reward\n/// @author velodrome.finance, @figs999, @pegahcarter\n/// @notice Base reward contract for distribution of rewards\nabstract contract Reward is IReward, ERC2771Context, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 constant DURATION = 7 days;\n\n    /// @inheritdoc IReward\n    address public immutable voter;\n    /// @inheritdoc IReward\n    address public immutable ve;\n    /// @inheritdoc IReward\n    address public authorized;\n\n    /// @inheritdoc IReward\n    uint256 public totalSupply;\n    /// @inheritdoc IReward\n    mapping(uint256 => uint256) public balanceOf;\n    /// @inheritdoc IReward\n    mapping(address => mapping(uint256 => uint256)) public tokenRewardsPerEpoch;\n    /// @inheritdoc IReward\n    mapping(address => mapping(uint256 => uint256)) public lastEarn;\n\n    address[] public rewards;\n    /// @inheritdoc IReward\n    mapping(address => bool) public isReward;\n\n    /// @notice A record of balance checkpoints for each account, by index\n    mapping(uint256 => mapping(uint256 => Checkpoint)) public checkpoints;\n    /// @inheritdoc IReward\n    mapping(uint256 => uint256) public numCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping(uint256 => SupplyCheckpoint) public supplyCheckpoints;\n    /// @inheritdoc IReward\n    uint256 public supplyNumCheckpoints;\n\n    constructor(address _forwarder, address _voter) ERC2771Context(_forwarder) {\n        voter = _voter;\n        ve = IVoter(_voter).ve();\n    }\n\n    /// @inheritdoc IReward\n    function getPriorBalanceIndex(\n        uint256 tokenId,\n        uint256 timestamp\n    ) public view returns (uint256) {\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[tokenId][nCheckpoints - 1].timestamp <= timestamp) {\n            return (nCheckpoints - 1);\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[tokenId][0].timestamp > timestamp) {\n            return 0;\n        }\n\n        uint256 lower = 0;\n        uint256 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[tokenId][center];\n            if (cp.timestamp == timestamp) {\n                return center;\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    /// @inheritdoc IReward\n    function getPriorSupplyIndex(\n        uint256 timestamp\n    ) public view returns (uint256) {\n        uint256 nCheckpoints = supplyNumCheckpoints;\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (supplyCheckpoints[nCheckpoints - 1].timestamp <= timestamp) {\n            return (nCheckpoints - 1);\n        }\n\n        // Next check implicit zero balance\n        if (supplyCheckpoints[0].timestamp > timestamp) {\n            return 0;\n        }\n\n        uint256 lower = 0;\n        uint256 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            SupplyCheckpoint memory cp = supplyCheckpoints[center];\n            if (cp.timestamp == timestamp) {\n                return center;\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    function _writeCheckpoint(uint256 tokenId, uint256 balance) internal {\n        uint256 _nCheckPoints = numCheckpoints[tokenId];\n        uint256 _timestamp = block.timestamp;\n\n        if (\n            _nCheckPoints > 0 &&\n            ProtocolTimeLibrary.epochStart(\n                checkpoints[tokenId][_nCheckPoints - 1].timestamp\n            ) ==\n            ProtocolTimeLibrary.epochStart(_timestamp)\n        ) {\n            checkpoints[tokenId][_nCheckPoints - 1] = Checkpoint(\n                _timestamp,\n                balance\n            );\n        } else {\n            checkpoints[tokenId][_nCheckPoints] = Checkpoint(\n                _timestamp,\n                balance\n            );\n            numCheckpoints[tokenId] = _nCheckPoints + 1;\n        }\n    }\n\n    function _writeSupplyCheckpoint() internal {\n        uint256 _nCheckPoints = supplyNumCheckpoints;\n        uint256 _timestamp = block.timestamp;\n\n        if (\n            _nCheckPoints > 0 &&\n            ProtocolTimeLibrary.epochStart(\n                supplyCheckpoints[_nCheckPoints - 1].timestamp\n            ) ==\n            ProtocolTimeLibrary.epochStart(_timestamp)\n        ) {\n            supplyCheckpoints[_nCheckPoints - 1] = SupplyCheckpoint(\n                _timestamp,\n                totalSupply\n            );\n        } else {\n            supplyCheckpoints[_nCheckPoints] = SupplyCheckpoint(\n                _timestamp,\n                totalSupply\n            );\n            supplyNumCheckpoints = _nCheckPoints + 1;\n        }\n    }\n\n    /// @inheritdoc IReward\n    function rewardsListLength() external view returns (uint256) {\n        return rewards.length;\n    }\n\n    /// @inheritdoc IReward\n    function duration() external pure returns (uint256) {\n        return DURATION;\n    }\n\n    /// @inheritdoc IReward\n    function earned(\n        address token,\n        uint256 tokenId\n    ) public view returns (uint256) {\n        if (numCheckpoints[tokenId] == 0) {\n            return 0;\n        }\n\n        uint256 reward = 0;\n        uint256 _supply = 1;\n        uint256 _currTs = ProtocolTimeLibrary.epochStart(\n            lastEarn[token][tokenId]\n        ); // take epoch last claimed in as starting point\n        uint256 _index = getPriorBalanceIndex(tokenId, _currTs);\n        Checkpoint memory cp0 = checkpoints[tokenId][_index];\n\n        // accounts for case where lastEarn is before first checkpoint\n        _currTs = Math.max(\n            _currTs,\n            ProtocolTimeLibrary.epochStart(cp0.timestamp)\n        );\n\n        // get epochs between current epoch and first checkpoint in same epoch as last claim\n        uint256 numEpochs = (ProtocolTimeLibrary.epochStart(block.timestamp) -\n            _currTs) / DURATION;\n\n        if (numEpochs > 0) {\n            for (uint256 i = 0; i < numEpochs; i++) {\n                // get index of last checkpoint in this epoch\n                _index = getPriorBalanceIndex(tokenId, _currTs + DURATION - 1);\n                // get checkpoint in this epoch\n                cp0 = checkpoints[tokenId][_index];\n                // get supply of last checkpoint in this epoch\n                _supply = Math.max(\n                    supplyCheckpoints[\n                        getPriorSupplyIndex(_currTs + DURATION - 1)\n                    ].supply,\n                    1\n                );\n                reward +=\n                    (cp0.balanceOf * tokenRewardsPerEpoch[token][_currTs]) /\n                    _supply;\n                _currTs += DURATION;\n            }\n        }\n\n        return reward;\n    }\n\n    /// @inheritdoc IReward\n    function _deposit(uint256 amount, uint256 tokenId) external {\n        address sender = _msgSender();\n        if (sender != authorized) revert NotAuthorized();\n\n        totalSupply += amount;\n        balanceOf[tokenId] += amount;\n\n        _writeCheckpoint(tokenId, balanceOf[tokenId]);\n        _writeSupplyCheckpoint();\n\n        emit Deposit(sender, tokenId, amount);\n    }\n\n    /// @inheritdoc IReward\n    function _withdraw(uint256 amount, uint256 tokenId) external {\n        address sender = _msgSender();\n        if (sender != authorized) revert NotAuthorized();\n\n        totalSupply -= amount;\n        balanceOf[tokenId] -= amount;\n\n        _writeCheckpoint(tokenId, balanceOf[tokenId]);\n        _writeSupplyCheckpoint();\n\n        emit Withdraw(sender, tokenId, amount);\n    }\n\n    /// @inheritdoc IReward\n    function getReward(\n        uint256 tokenId,\n        address[] memory tokens\n    ) external virtual nonReentrant {}\n\n    /// @dev used with all getReward implementations\n    function _getReward(\n        address recipient,\n        uint256 tokenId,\n        address[] memory tokens\n    ) internal {\n        uint256 _length = tokens.length;\n        for (uint256 i = 0; i < _length; i++) {\n            uint256 _reward = earned(tokens[i], tokenId);\n            lastEarn[tokens[i]][tokenId] = block.timestamp;\n            if (_reward > 0) IERC20(tokens[i]).safeTransfer(recipient, _reward);\n\n            emit ClaimRewards(recipient, tokens[i], _reward);\n        }\n    }\n\n    /// @inheritdoc IReward\n    function notifyRewardAmount(\n        address token,\n        uint256 amount\n    ) external virtual nonReentrant {}\n\n    /// @dev used within all notifyRewardAmount implementations\n    function _notifyRewardAmount(\n        address sender,\n        address token,\n        uint256 amount\n    ) internal {\n        if (amount == 0) revert ZeroAmount();\n        IERC20(token).safeTransferFrom(sender, address(this), amount);\n\n        uint256 epochStart = ProtocolTimeLibrary.epochStart(block.timestamp);\n        tokenRewardsPerEpoch[token][epochStart] += amount;\n\n        emit NotifyReward(sender, token, epochStart, amount);\n    }\n}\n"
    },
    "contracts/rewards/VotingReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {Reward} from \"./Reward.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\n\n/// @title Base voting reward contract for distribution of rewards by token id\n///        on a weekly basis\nabstract contract VotingReward is Reward {\n    constructor(\n        address _forwarder,\n        address _voter,\n        address[] memory _rewards\n    ) Reward(_forwarder, _voter) {\n        uint256 _length = _rewards.length;\n        for (uint256 i; i < _length; i++) {\n            if (_rewards[i] != address(0)) {\n                isReward[_rewards[i]] = true;\n                rewards.push(_rewards[i]);\n            }\n        }\n\n        authorized = _voter;\n    }\n\n    /// @inheritdoc Reward\n    function getReward(\n        uint256 tokenId,\n        address[] memory tokens\n    ) external override nonReentrant {\n        address sender = _msgSender();\n        if (\n            !IVotingEscrow(ve).isApprovedOrOwner(sender, tokenId) &&\n            sender != voter\n        ) revert NotAuthorized();\n\n        address _owner = IVotingEscrow(ve).ownerOf(tokenId);\n        _getReward(_owner, tokenId, tokens);\n    }\n\n    /// @inheritdoc Reward\n    function notifyRewardAmount(\n        address token,\n        uint256 amount\n    ) external virtual override {}\n}\n"
    },
    "contracts/RewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.24;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IRewardsDistributor} from \"./interfaces/IRewardsDistributor.sol\";\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\nimport {ISplitter} from \"./interfaces/ISplitter.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/*\n * @title Curve Fee Distribution modified for ve(3,3) emissions\n * @author Curve Finance, andrecronje\n * @author velodrome.finance, @figs999, @pegahcarter\n * @license MIT\n */\ncontract RewardsDistributor is IRewardsDistributor {\n    using SafeERC20 for IERC20;\n\n    uint256 constant WEEK = 7 * 86400;\n\n    /// @inheritdoc IRewardsDistributor\n    uint256 public startTime;\n    /// @inheritdoc IRewardsDistributor\n    mapping(uint256 => uint256) public timeCursorOf;\n\n    /// @inheritdoc IRewardsDistributor\n    uint256 public lastTokenTime;\n    uint256[1000000000000000] public tokensPerWeek;\n\n    /// @inheritdoc IRewardsDistributor\n    IVotingEscrow public immutable ve;\n    /// @inheritdoc IRewardsDistributor\n    address public token;\n    /// @inheritdoc IRewardsDistributor\n    address public depositor;\n    /// @inheritdoc IRewardsDistributor\n    uint256 public tokenLastBalance;\n\n    constructor(address _ve) {\n        uint256 _t = (block.timestamp / WEEK) * WEEK;\n        startTime = _t;\n        lastTokenTime = _t;\n        ve = IVotingEscrow(_ve);\n        address _token = ve.token();\n        token = _token;\n        depositor = msg.sender;\n        IERC20(_token).safeApprove(_ve, type(uint256).max);\n    }\n\n    function _checkpointToken() internal {\n        uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n        uint256 toDistribute = tokenBalance - tokenLastBalance;\n        tokenLastBalance = tokenBalance;\n\n        uint256 t = lastTokenTime;\n        uint256 sinceLast = block.timestamp - t;\n        lastTokenTime = block.timestamp;\n        uint256 thisWeek = (t / WEEK) * WEEK;\n        uint256 nextWeek = 0;\n        uint256 timestamp = block.timestamp;\n\n        for (uint256 i = 0; i < 20; i++) {\n            nextWeek = thisWeek + WEEK;\n            if (timestamp < nextWeek) {\n                if (sinceLast == 0 && timestamp == t) {\n                    tokensPerWeek[thisWeek] += toDistribute;\n                } else {\n                    tokensPerWeek[thisWeek] +=\n                        (toDistribute * (timestamp - t)) /\n                        sinceLast;\n                }\n                break;\n            } else {\n                if (sinceLast == 0 && nextWeek == t) {\n                    tokensPerWeek[thisWeek] += toDistribute;\n                } else {\n                    tokensPerWeek[thisWeek] +=\n                        (toDistribute * (nextWeek - t)) /\n                        sinceLast;\n                }\n            }\n            t = nextWeek;\n            thisWeek = nextWeek;\n        }\n        emit CheckpointToken(timestamp, toDistribute);\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function checkpointToken() external {\n        if (msg.sender != depositor) {\n            revert NotDepositor();\n        }\n        _checkpointToken();\n    }\n\n    function _claim(\n        uint256 _tokenId,\n        uint256 _lastTokenTime\n    ) internal returns (uint256) {\n        (\n            uint256 toDistribute,\n            uint256 epochStart,\n            uint256 weekCursor\n        ) = _claimable(_tokenId, _lastTokenTime);\n        timeCursorOf[_tokenId] = weekCursor;\n        if (toDistribute == 0) return 0;\n\n        emit Claimed(_tokenId, epochStart, weekCursor, toDistribute);\n        return toDistribute;\n    }\n\n    function _claimable(\n        uint256 _tokenId,\n        uint256 _lastTokenTime\n    )\n        internal\n        view\n        returns (\n            uint256 toDistribute,\n            uint256 weekCursorStart,\n            uint256 weekCursor\n        )\n    {\n        uint256 _startTime = startTime;\n        weekCursor = timeCursorOf[_tokenId];\n        weekCursorStart = weekCursor;\n\n        // case where token does not exist\n        uint256 maxUserEpoch = ve.userPointEpoch(_tokenId);\n        if (maxUserEpoch == 0) return (0, weekCursorStart, weekCursor);\n\n        // case where token exists but has never been claimed\n        if (weekCursor == 0) {\n            IVotingEscrow.UserPoint memory userPoint = ve.userPointHistory(\n                _tokenId,\n                1\n            );\n            weekCursor = (userPoint.ts / WEEK) * WEEK;\n            weekCursorStart = weekCursor;\n        }\n        if (weekCursor >= _lastTokenTime)\n            return (0, weekCursorStart, weekCursor);\n        if (weekCursor < _startTime) weekCursor = _startTime;\n\n        for (uint256 i = 0; i < 50; i++) {\n            if (weekCursor >= _lastTokenTime) break;\n\n            uint256 balance = ve.balanceOfNFTAt(\n                _tokenId,\n                weekCursor + WEEK - 1\n            );\n            uint256 supply = ve.totalSupplyAt(weekCursor + WEEK - 1);\n            supply = supply == 0 ? 1 : supply;\n            toDistribute += (balance * tokensPerWeek[weekCursor]) / supply;\n            weekCursor += WEEK;\n        }\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function claimable(\n        uint256 _tokenId\n    ) external view returns (uint256 claimable_) {\n        uint256 _lastTokenTime = (lastTokenTime / WEEK) * WEEK;\n        (claimable_, , ) = _claimable(_tokenId, _lastTokenTime);\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function claim(uint256 _tokenId) external returns (uint256) {\n        if (\n            ISplitter(depositor).activePeriod() <\n            ((block.timestamp / WEEK) * WEEK)\n        ) revert UpdatePeriod();\n        if (ve.escrowType(_tokenId) == IVotingEscrow.EscrowType.LOCKED)\n            revert NotManagedOrNormalNFT();\n        uint256 _timestamp = block.timestamp;\n        uint256 _lastTokenTime = lastTokenTime;\n        _lastTokenTime = (_lastTokenTime / WEEK) * WEEK;\n        uint256 amount = _claim(_tokenId, _lastTokenTime);\n        if (amount != 0) {\n            IVotingEscrow.LockedBalance memory _locked = IVotingEscrow(ve)\n                .locked(_tokenId);\n            if (_timestamp >= _locked.end && !_locked.isPermanent) {\n                address _owner = IVotingEscrow(ve).ownerOf(_tokenId);\n                IERC20(token).safeTransfer(_owner, amount);\n            } else {\n                IVotingEscrow(ve).depositFor(_tokenId, amount);\n            }\n            tokenLastBalance -= amount;\n        }\n        return amount;\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function claimMany(uint256[] calldata _tokenIds) external returns (bool) {\n        if (\n            ISplitter(depositor).activePeriod() <\n            ((block.timestamp / WEEK) * WEEK)\n        ) revert UpdatePeriod();\n        uint256 _timestamp = block.timestamp;\n        uint256 _lastTokenTime = lastTokenTime;\n        _lastTokenTime = (_lastTokenTime / WEEK) * WEEK;\n        uint256 total = 0;\n        uint256 _length = _tokenIds.length;\n\n        for (uint256 i = 0; i < _length; i++) {\n            uint256 _tokenId = _tokenIds[i];\n            if (ve.escrowType(_tokenId) == IVotingEscrow.EscrowType.LOCKED)\n                revert NotManagedOrNormalNFT();\n            if (_tokenId == 0) break;\n            uint256 amount = _claim(_tokenId, _lastTokenTime);\n            if (amount != 0) {\n                IVotingEscrow.LockedBalance memory _locked = IVotingEscrow(ve)\n                    .locked(_tokenId);\n                if (_timestamp >= _locked.end && !_locked.isPermanent) {\n                    address _owner = IVotingEscrow(ve).ownerOf(_tokenId);\n                    IERC20(token).safeTransfer(_owner, amount);\n                } else {\n                    IVotingEscrow(ve).depositFor(_tokenId, amount);\n                }\n                total += amount;\n            }\n        }\n        if (total != 0) {\n            tokenLastBalance -= total;\n        }\n\n        return true;\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function setDepositor(address _depositor) external {\n        if (msg.sender != depositor) revert NotDepositor();\n        depositor = _depositor;\n    }\n\n    /// @inheritdoc IRewardsDistributor\n    function week() external pure returns (uint256) {\n        return WEEK;\n    }\n}\n"
    },
    "contracts/Router.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IPool} from \"./interfaces/IPool.sol\";\nimport {IPoolFactory} from \"./interfaces/factories/IPoolFactory.sol\";\nimport {IRouter} from \"./interfaces/IRouter.sol\";\nimport {IVoter} from \"./interfaces/IVoter.sol\";\nimport {IGauge} from \"./interfaces/IGauge.sol\";\nimport {IFactoryRegistry} from \"./interfaces/factories/IFactoryRegistry.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC2771Context} from \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\n/// @title Protocol Router\n/// @author velodrome.finance, @pegahcarter\n/// @notice Router allows routes through any pools created by any factory adhering to univ2 interface.\ncontract Router is IRouter, ERC2771Context {\n    using SafeERC20 for IERC20;\n\n    /// @inheritdoc IRouter\n    address public immutable factoryRegistry;\n    /// @inheritdoc IRouter\n    address public immutable defaultFactory;\n    /// @inheritdoc IRouter\n    address public immutable voter;\n\n    uint256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n\n    modifier ensure(uint256 deadline) {\n        _ensureDeadline(deadline);\n        _;\n    }\n\n    function _ensureDeadline(uint256 deadline) internal view {\n        if (deadline < block.timestamp) revert Expired();\n    }\n\n    constructor(\n        address _forwarder,\n        address _factoryRegistry,\n        address _factory,\n        address _voter\n    ) ERC2771Context(_forwarder) {\n        factoryRegistry = _factoryRegistry;\n        defaultFactory = _factory;\n        voter = _voter;\n    }\n\n    /// @inheritdoc IRouter\n    function sortTokens(\n        address tokenA,\n        address tokenB\n    ) public pure returns (address token0, address token1) {\n        if (tokenA == tokenB) revert SameAddresses();\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        if (token0 == address(0)) revert ZeroAddress();\n    }\n\n    /// @inheritdoc IRouter\n    function poolFor(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        address _factory\n    ) public view returns (address pool) {\n        address _defaultFactory = defaultFactory;\n        address factory = _factory == address(0) ? _defaultFactory : _factory;\n        if (!IFactoryRegistry(factoryRegistry).isPoolFactoryApproved(factory))\n            revert PoolFactoryDoesNotExist();\n\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1, stable));\n        pool = Clones.predictDeterministicAddress(\n            IPoolFactory(factory).implementation(),\n            salt,\n            factory\n        );\n    }\n\n    /// @dev given some amount of an asset and pool reserves, returns an equivalent amount of the other asset\n    /// @dev this only accounts for volatile pools and may return insufficient liquidity for stable pools\n    function quoteLiquidity(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        if (amountA == 0) revert InsufficientAmount();\n        if (reserveA == 0 || reserveB == 0) revert InsufficientLiquidity();\n        amountB = (amountA * reserveB) / reserveA;\n    }\n\n    /// @inheritdoc IRouter\n    function getReserves(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        address _factory\n    ) public view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IPool(\n            poolFor(tokenA, tokenB, stable, _factory)\n        ).getReserves();\n        (reserveA, reserveB) = tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    /// @inheritdoc IRouter\n    function getAmountsOut(\n        uint256 amountIn,\n        Route[] memory routes\n    ) public view returns (uint256[] memory amounts) {\n        if (routes.length < 1) revert InvalidPath();\n        amounts = new uint256[](routes.length + 1);\n        amounts[0] = amountIn;\n        uint256 _length = routes.length;\n        for (uint256 i = 0; i < _length; i++) {\n            address factory = routes[i].factory == address(0)\n                ? defaultFactory\n                : routes[i].factory;\n            address pool = poolFor(\n                routes[i].from,\n                routes[i].to,\n                routes[i].stable,\n                factory\n            );\n            if (IPoolFactory(factory).isPool(pool)) {\n                amounts[i + 1] = IPool(pool).getAmountOut(\n                    amounts[i],\n                    routes[i].from\n                );\n            }\n        }\n    }\n\n    /// @inheritdoc IRouter\n    function quoteAddLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        address _factory,\n        uint256 amountADesired,\n        uint256 amountBDesired\n    )\n        public\n        view\n        returns (uint256 amountA, uint256 amountB, uint256 liquidity)\n    {\n        address _pool = IPoolFactory(_factory).getPool(tokenA, tokenB, stable);\n        (uint256 reserveA, uint256 reserveB) = (0, 0);\n        uint256 _totalSupply = 0;\n        if (_pool != address(0)) {\n            _totalSupply = IERC20(_pool).totalSupply();\n            (reserveA, reserveB) = getReserves(\n                tokenA,\n                tokenB,\n                stable,\n                _factory\n            );\n        }\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n            liquidity = Math.sqrt(amountA * amountB) - MINIMUM_LIQUIDITY;\n        } else {\n            uint256 amountBOptimal = quoteLiquidity(\n                amountADesired,\n                reserveA,\n                reserveB\n            );\n            if (amountBOptimal <= amountBDesired) {\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n                liquidity = Math.min(\n                    (amountA * _totalSupply) / reserveA,\n                    (amountB * _totalSupply) / reserveB\n                );\n            } else {\n                uint256 amountAOptimal = quoteLiquidity(\n                    amountBDesired,\n                    reserveB,\n                    reserveA\n                );\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n                liquidity = Math.min(\n                    (amountA * _totalSupply) / reserveA,\n                    (amountB * _totalSupply) / reserveB\n                );\n            }\n        }\n    }\n\n    /// @inheritdoc IRouter\n    function quoteRemoveLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        address _factory,\n        uint256 liquidity\n    ) public view returns (uint256 amountA, uint256 amountB) {\n        address _pool = IPoolFactory(_factory).getPool(tokenA, tokenB, stable);\n\n        if (_pool == address(0)) {\n            return (0, 0);\n        }\n\n        (uint256 reserveA, uint256 reserveB) = getReserves(\n            tokenA,\n            tokenB,\n            stable,\n            _factory\n        );\n        uint256 _totalSupply = IERC20(_pool).totalSupply();\n\n        amountA = (liquidity * reserveA) / _totalSupply; // using balances ensures pro-rata distribution\n        amountB = (liquidity * reserveB) / _totalSupply; // using balances ensures pro-rata distribution\n    }\n\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) internal returns (uint256 amountA, uint256 amountB) {\n        if (amountADesired < amountAMin) revert InsufficientAmountADesired();\n        if (amountBDesired < amountBMin) revert InsufficientAmountBDesired();\n        // create the pool if it doesn't exist yet\n        address _pool = IPoolFactory(defaultFactory).getPool(\n            tokenA,\n            tokenB,\n            stable\n        );\n        if (_pool == address(0)) {\n            _pool = IPoolFactory(defaultFactory).createPool(\n                tokenA,\n                tokenB,\n                stable\n            );\n        }\n        (uint256 reserveA, uint256 reserveB) = getReserves(\n            tokenA,\n            tokenB,\n            stable,\n            defaultFactory\n        );\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint256 amountBOptimal = quoteLiquidity(\n                amountADesired,\n                reserveA,\n                reserveB\n            );\n            if (amountBOptimal <= amountBDesired) {\n                if (amountBOptimal < amountBMin) revert InsufficientAmountB();\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal = quoteLiquidity(\n                    amountBDesired,\n                    reserveB,\n                    reserveA\n                );\n                assert(amountAOptimal <= amountADesired);\n                if (amountAOptimal < amountAMin) revert InsufficientAmountA();\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    /// @inheritdoc IRouter\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        public\n        ensure(deadline)\n        returns (uint256 amountA, uint256 amountB, uint256 liquidity)\n    {\n        (amountA, amountB) = _addLiquidity(\n            tokenA,\n            tokenB,\n            stable,\n            amountADesired,\n            amountBDesired,\n            amountAMin,\n            amountBMin\n        );\n        address pool = poolFor(tokenA, tokenB, stable, defaultFactory);\n        _safeTransferFrom(tokenA, _msgSender(), pool, amountA);\n        _safeTransferFrom(tokenB, _msgSender(), pool, amountB);\n        liquidity = IPool(pool).mint(to);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n\n    /// @inheritdoc IRouter\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) public ensure(deadline) returns (uint256 amountA, uint256 amountB) {\n        address pool = poolFor(tokenA, tokenB, stable, defaultFactory);\n        IERC20(pool).safeTransferFrom(_msgSender(), pool, liquidity);\n        (uint256 amount0, uint256 amount1) = IPool(pool).burn(to);\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0\n            ? (amount0, amount1)\n            : (amount1, amount0);\n        if (amountA < amountAMin) revert InsufficientAmountA();\n        if (amountB < amountBMin) revert InsufficientAmountB();\n    }\n\n    // **** SWAP ****\n    /// @dev requires the initial amount to have already been sent to the first pool\n    function _swap(\n        uint256[] memory amounts,\n        Route[] memory routes,\n        address _to\n    ) internal virtual {\n        uint256 _length = routes.length;\n        for (uint256 i = 0; i < _length; i++) {\n            (address token0, ) = sortTokens(routes[i].from, routes[i].to);\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out) = routes[i].from == token0\n                ? (uint256(0), amountOut)\n                : (amountOut, uint256(0));\n            address to = i < routes.length - 1\n                ? poolFor(\n                    routes[i + 1].from,\n                    routes[i + 1].to,\n                    routes[i + 1].stable,\n                    routes[i + 1].factory\n                )\n                : _to;\n            IPool(\n                poolFor(\n                    routes[i].from,\n                    routes[i].to,\n                    routes[i].stable,\n                    routes[i].factory\n                )\n            ).swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\n        amounts = getAmountsOut(amountIn, routes);\n        if (amounts[amounts.length - 1] < amountOutMin)\n            revert InsufficientOutputAmount();\n        _safeTransferFrom(\n            routes[0].from,\n            _msgSender(),\n            poolFor(\n                routes[0].from,\n                routes[0].to,\n                routes[0].stable,\n                routes[0].factory\n            ),\n            amounts[0]\n        );\n        _swap(amounts, routes, to);\n    }\n\n    function UNSAFE_swapExactTokensForTokens(\n        uint256[] memory amounts,\n        Route[] calldata routes,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256[] memory) {\n        _safeTransferFrom(\n            routes[0].from,\n            _msgSender(),\n            poolFor(\n                routes[0].from,\n                routes[0].to,\n                routes[0].stable,\n                routes[0].factory\n            ),\n            amounts[0]\n        );\n        _swap(amounts, routes, to);\n        return amounts;\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    /// @dev requires the initial amount to have already been sent to the first pool\n    function _swapSupportingFeeOnTransferTokens(\n        Route[] memory routes,\n        address _to\n    ) internal virtual {\n        uint256 _length = routes.length;\n        for (uint256 i; i < _length; i++) {\n            (address token0, ) = sortTokens(routes[i].from, routes[i].to);\n            address pool = poolFor(\n                routes[i].from,\n                routes[i].to,\n                routes[i].stable,\n                routes[i].factory\n            );\n            uint256 amountInput;\n            uint256 amountOutput;\n            {\n                // stack too deep\n                (uint256 reserveA, ) = getReserves(\n                    routes[i].from,\n                    routes[i].to,\n                    routes[i].stable,\n                    routes[i].factory\n                ); // getReserves sorts it for us i.e. reserveA is always for from\n                amountInput = IERC20(routes[i].from).balanceOf(pool) - reserveA;\n            }\n            amountOutput = IPool(pool).getAmountOut(\n                amountInput,\n                routes[i].from\n            );\n            (uint256 amount0Out, uint256 amount1Out) = routes[i].from == token0\n                ? (uint256(0), amountOutput)\n                : (amountOutput, uint256(0));\n            address to = i < routes.length - 1\n                ? poolFor(\n                    routes[i + 1].from,\n                    routes[i + 1].to,\n                    routes[i + 1].stable,\n                    routes[i + 1].factory\n                )\n                : _to;\n            IPool(pool).swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    /// @inheritdoc IRouter\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) {\n        _safeTransferFrom(\n            routes[0].from,\n            _msgSender(),\n            poolFor(\n                routes[0].from,\n                routes[0].to,\n                routes[0].stable,\n                routes[0].factory\n            ),\n            amountIn\n        );\n        uint256 _length = routes.length - 1;\n        uint256 balanceBefore = IERC20(routes[_length].to).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(routes, to);\n        if (\n            IERC20(routes[_length].to).balanceOf(to) - balanceBefore <\n            amountOutMin\n        ) revert InsufficientOutputAmount();\n    }\n\n    /// @inheritdoc IRouter\n    function zapIn(\n        address tokenIn,\n        uint256 amountInA,\n        uint256 amountInB,\n        Zap calldata zapInPool,\n        Route[] calldata routesA,\n        Route[] calldata routesB,\n        address to,\n        bool stake\n    ) external returns (uint256 liquidity) {\n        uint256 amountIn = amountInA + amountInB;\n\n        _safeTransferFrom(tokenIn, _msgSender(), address(this), amountIn);\n        _zapSwap(tokenIn, amountInA, amountInB, zapInPool, routesA, routesB);\n        _zapInLiquidity(zapInPool);\n        address pool = poolFor(\n            zapInPool.tokenA,\n            zapInPool.tokenB,\n            zapInPool.stable,\n            zapInPool.factory\n        );\n\n        if (stake) {\n            liquidity = IPool(pool).mint(address(this));\n            address gauge = IVoter(voter).gauges(pool);\n            IERC20(pool).safeApprove(address(gauge), liquidity);\n            IGauge(gauge).deposit(liquidity, to);\n            IERC20(pool).safeApprove(address(gauge), 0);\n        } else {\n            liquidity = IPool(pool).mint(to);\n        }\n\n        _returnAssets(tokenIn);\n        _returnAssets(zapInPool.tokenA);\n        _returnAssets(zapInPool.tokenB);\n    }\n\n    /// @dev Handles swap leg of zap in (i.e. convert tokenIn into tokenA and tokenB).\n    function _zapSwap(\n        address tokenIn,\n        uint256 amountInA,\n        uint256 amountInB,\n        Zap calldata zapInPool,\n        Route[] calldata routesA,\n        Route[] calldata routesB\n    ) internal {\n        address tokenA = zapInPool.tokenA;\n        address tokenB = zapInPool.tokenB;\n        bool stable = zapInPool.stable;\n        address factory = zapInPool.factory;\n        address pool = poolFor(tokenA, tokenB, stable, factory);\n\n        {\n            (uint256 reserve0, uint256 reserve1, ) = IPool(pool).getReserves();\n            if (reserve0 <= MINIMUM_LIQUIDITY || reserve1 <= MINIMUM_LIQUIDITY)\n                revert PoolDoesNotExist();\n        }\n\n        if (tokenIn != tokenA) {\n            if (routesA[routesA.length - 1].to != tokenA)\n                revert InvalidRouteA();\n            _internalSwap(tokenIn, amountInA, zapInPool.amountOutMinA, routesA);\n        }\n        if (tokenIn != tokenB) {\n            if (routesB[routesB.length - 1].to != tokenB)\n                revert InvalidRouteB();\n            _internalSwap(tokenIn, amountInB, zapInPool.amountOutMinB, routesB);\n        }\n    }\n\n    /// @dev Handles liquidity adding component of zap in.\n    function _zapInLiquidity(Zap calldata zapInPool) internal {\n        address tokenA = zapInPool.tokenA;\n        address tokenB = zapInPool.tokenB;\n        bool stable = zapInPool.stable;\n        address factory = zapInPool.factory;\n        address pool = poolFor(tokenA, tokenB, stable, factory);\n        (uint256 amountA, uint256 amountB) = _quoteZapLiquidity(\n            tokenA,\n            tokenB,\n            stable,\n            factory,\n            IERC20(tokenA).balanceOf(address(this)),\n            IERC20(tokenB).balanceOf(address(this)),\n            zapInPool.amountAMin,\n            zapInPool.amountBMin\n        );\n        _safeTransfer(tokenA, pool, amountA);\n        _safeTransfer(tokenB, pool, amountB);\n    }\n\n    /// @dev Similar to _addLiquidity. Assumes a pool exists, and accepts a factory argument.\n    function _quoteZapLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        address _factory,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) internal view returns (uint256 amountA, uint256 amountB) {\n        if (amountADesired < amountAMin) revert InsufficientAmountADesired();\n        if (amountBDesired < amountBMin) revert InsufficientAmountBDesired();\n        (uint256 reserveA, uint256 reserveB) = getReserves(\n            tokenA,\n            tokenB,\n            stable,\n            _factory\n        );\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint256 amountBOptimal = quoteLiquidity(\n                amountADesired,\n                reserveA,\n                reserveB\n            );\n            if (amountBOptimal <= amountBDesired) {\n                if (amountBOptimal < amountBMin) revert InsufficientAmountB();\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal = quoteLiquidity(\n                    amountBDesired,\n                    reserveB,\n                    reserveA\n                );\n                assert(amountAOptimal <= amountADesired);\n                if (amountAOptimal < amountAMin) revert InsufficientAmountA();\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    /// @dev Handles swaps internally for zaps.\n    function _internalSwap(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Route[] memory routes\n    ) internal {\n        uint256[] memory amounts = getAmountsOut(amountIn, routes);\n        if (amounts[amounts.length - 1] < amountOutMin)\n            revert InsufficientOutputAmount();\n        address pool = poolFor(\n            routes[0].from,\n            routes[0].to,\n            routes[0].stable,\n            routes[0].factory\n        );\n        _safeTransfer(tokenIn, pool, amountIn);\n        _swap(amounts, routes, address(this));\n    }\n\n    /// @inheritdoc IRouter\n    function zapOut(\n        address tokenOut,\n        uint256 liquidity,\n        Zap calldata zapOutPool,\n        Route[] calldata routesA,\n        Route[] calldata routesB\n    ) external {\n        address tokenA = zapOutPool.tokenA;\n        address tokenB = zapOutPool.tokenB;\n        address _tokenOut = tokenOut;\n        _zapOutLiquidity(liquidity, zapOutPool);\n\n        uint256 balance;\n        if (tokenA != _tokenOut) {\n            balance = IERC20(tokenA).balanceOf(address(this));\n            if (routesA[routesA.length - 1].to != _tokenOut)\n                revert InvalidRouteA();\n            _internalSwap(tokenA, balance, zapOutPool.amountOutMinA, routesA);\n        }\n        if (tokenB != _tokenOut) {\n            balance = IERC20(tokenB).balanceOf(address(this));\n            if (routesB[routesB.length - 1].to != _tokenOut)\n                revert InvalidRouteB();\n            _internalSwap(tokenB, balance, zapOutPool.amountOutMinB, routesB);\n        }\n\n        _returnAssets(tokenOut);\n    }\n\n    /// @dev Handles liquidity removing component of zap out.\n    function _zapOutLiquidity(\n        uint256 liquidity,\n        Zap calldata zapOutPool\n    ) internal {\n        address tokenA = zapOutPool.tokenA;\n        address tokenB = zapOutPool.tokenB;\n        address pool = poolFor(\n            tokenA,\n            tokenB,\n            zapOutPool.stable,\n            zapOutPool.factory\n        );\n        IERC20(pool).safeTransferFrom(msg.sender, pool, liquidity);\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 amount0, uint256 amount1) = IPool(pool).burn(address(this));\n        (uint256 amountA, uint256 amountB) = tokenA == token0\n            ? (amount0, amount1)\n            : (amount1, amount0);\n        if (amountA < zapOutPool.amountAMin) revert InsufficientAmountA();\n        if (amountB < zapOutPool.amountBMin) revert InsufficientAmountB();\n    }\n\n    /// @inheritdoc IRouter\n    function generateZapInParams(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        address _factory,\n        uint256 amountInA,\n        uint256 amountInB,\n        Route[] calldata routesA,\n        Route[] calldata routesB\n    )\n        external\n        view\n        returns (\n            uint256 amountOutMinA,\n            uint256 amountOutMinB,\n            uint256 amountAMin,\n            uint256 amountBMin\n        )\n    {\n        amountOutMinA = amountInA;\n        amountOutMinB = amountInB;\n        uint256[] memory amounts;\n        if (routesA.length > 0) {\n            amounts = getAmountsOut(amountInA, routesA);\n            amountOutMinA = amounts[amounts.length - 1];\n        }\n        if (routesB.length > 0) {\n            amounts = getAmountsOut(amountInB, routesB);\n            amountOutMinB = amounts[amounts.length - 1];\n        }\n        (amountAMin, amountBMin, ) = quoteAddLiquidity(\n            tokenA,\n            tokenB,\n            stable,\n            _factory,\n            amountOutMinA,\n            amountOutMinB\n        );\n    }\n\n    /// @inheritdoc IRouter\n    function generateZapOutParams(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        address _factory,\n        uint256 liquidity,\n        Route[] calldata routesA,\n        Route[] calldata routesB\n    )\n        external\n        view\n        returns (\n            uint256 amountOutMinA,\n            uint256 amountOutMinB,\n            uint256 amountAMin,\n            uint256 amountBMin\n        )\n    {\n        (amountAMin, amountBMin) = quoteRemoveLiquidity(\n            tokenA,\n            tokenB,\n            stable,\n            _factory,\n            liquidity\n        );\n        amountOutMinA = amountAMin;\n        amountOutMinB = amountBMin;\n        uint256[] memory amounts;\n        if (routesA.length > 0) {\n            amounts = getAmountsOut(amountAMin, routesA);\n            amountOutMinA = amounts[amounts.length - 1];\n        }\n        if (routesB.length > 0) {\n            amounts = getAmountsOut(amountBMin, routesB);\n            amountOutMinB = amounts[amounts.length - 1];\n        }\n    }\n\n    /// @dev Return residual assets from zapping.\n    /// @param token to return.\n    function _returnAssets(address token) internal {\n        address sender = _msgSender();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance > 0) {\n            IERC20(token).safeTransfer(sender, balance);\n        }\n    }\n\n    /// @inheritdoc IRouter\n    function quoteStableLiquidityRatio(\n        address tokenA,\n        address tokenB,\n        address _factory\n    ) external view returns (uint256 ratio) {\n        IPool pool = IPool(poolFor(tokenA, tokenB, true, _factory));\n\n        uint256 decimalsA = 10 ** IERC20Metadata(tokenA).decimals();\n        uint256 decimalsB = 10 ** IERC20Metadata(tokenB).decimals();\n\n        uint256 investment = decimalsA;\n        uint256 out = pool.getAmountOut(investment, tokenA);\n        (uint256 amountA, uint256 amountB, ) = quoteAddLiquidity(\n            tokenA,\n            tokenB,\n            true,\n            _factory,\n            investment,\n            out\n        );\n\n        amountA = (amountA * 1e18) / decimalsA;\n        amountB = (amountB * 1e18) / decimalsB;\n        out = (out * 1e18) / decimalsB;\n        investment = (investment * 1e18) / decimalsA;\n\n        ratio = (((out * 1e18) / investment) * amountA) / amountB;\n\n        return (investment * 1e18) / (ratio + 1e18);\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function _safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(\n                IERC20.transferFrom.selector,\n                from,\n                to,\n                value\n            )\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n}\n"
    },
    "contracts/Splitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {IEpochGovernor} from \"./interfaces/IEpochGovernor.sol\";\nimport {ISplitter} from \"./interfaces/ISplitter.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IRewardsDistributor} from \"./interfaces/IRewardsDistributor.sol\";\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\n\n/// @title Splitter\n/// @notice An abstract contract for tokens splitting between addresses defined\n///         in the implementation contract. Amount of the split tokens depends on\n///         the current position of the gauge needle that can be moved each epoch\n///         by the Epoch Governor.\nabstract contract Splitter is ISplitter {\n    using SafeERC20 for IERC20;\n\n    /// @notice Token for fee distribution.\n    IERC20 public immutable token;\n\n    /// @notice The maximum value of the gauge needle.\n    uint256 public constant MAXIMUM_GAUGE_SCALE = 100;\n\n    /// @notice The minimum value of the gauge needle.\n    uint256 public constant MINIMUM_GAUGE_SCALE = 1;\n\n    /// @notice Duration of epoch.\n    uint256 public constant WEEK = 1 weeks;\n\n    /// @notice Needle tick change per proposal.\n    uint256 public constant TICK = 1;\n\n    /// @notice Start time of currently active epoch.\n    uint256 public activePeriod;\n\n    /// @notice The current position of the gauge needle.\n    uint256 public needle;\n\n    /// @dev activePeriod => proposal existing, used to enforce one proposal per epoch.\n    mapping(uint256 => bool) public proposals;\n\n    /// @dev Emitted when the epoch period is updated.\n    event PeriodUpdated(\n        uint256 oldPeriod,\n        uint256 newPeriod,\n        uint256 firstRecipientAmount,\n        uint256 secondRecipientAmount\n    );\n\n    /// @notice Constructor to set up the fee splitter.\n    constructor(address _ve) {\n        token = IERC20(IVotingEscrow(_ve).token());\n    }\n\n    /// @notice Moves the gauge needle by 1 tick per epoch.\n    function nudge() external {\n        address epochGovernor = epochGovernor();\n        if (msg.sender != epochGovernor) revert NotEpochGovernor();\n\n        uint256 period = activePeriod;\n        if (proposals[period]) revert AlreadyNudged();\n\n        IEpochGovernor.ProposalState state = IEpochGovernor(epochGovernor)\n            .result();\n\n        uint256 oldNeedle = needle;\n        if (state != IEpochGovernor.ProposalState.Expired) {\n            // move the needle up by 1 tick\n            if (state == IEpochGovernor.ProposalState.Succeeded) {\n                needle = oldNeedle + TICK > MAXIMUM_GAUGE_SCALE\n                    ? MAXIMUM_GAUGE_SCALE\n                    : needle + TICK;\n            } else {\n                // move the needle down by 1 tick\n                needle = oldNeedle - TICK < MINIMUM_GAUGE_SCALE\n                    ? MINIMUM_GAUGE_SCALE\n                    : needle - TICK;\n            }\n        }\n\n        proposals[period] = true;\n        // Might happen that needle did not move due to abstained or expired proposal.\n        emit Nudge(period, oldNeedle, needle);\n    }\n\n    /// @notice Updates the period of the current epoch. This function can be called\n    ///         by anyone. Chain fees accumulate in this contract continuously and\n    ///         can be distributed between the first and second recipient after\n    ///         the end of the specified period. In other words, the release of\n    ///         the accumulated fees must wait until the end of the period.\n    /// @dev    Needle position is used to determine the distribution ratio between\n    ///         the first and second recipient.\n    ///         1...first recipient amount..|..second recipient amount..100 [%]\n    ///                                     ^\n    ///                                   needle\n\n    function updatePeriod() external returns (uint256 period) {\n        period = activePeriod;\n        if (block.timestamp >= period + WEEK) {\n            uint256 oldPeriod = period;\n            period = (block.timestamp / WEEK) * WEEK;\n            activePeriod = period;\n\n            uint256 firstRecipientAmount;\n            uint256 secondRecipientAmount;\n\n            uint256 currentBalance = token.balanceOf(address(this));\n            if (currentBalance > 0) {\n                firstRecipientAmount =\n                    (currentBalance * needle) /\n                    MAXIMUM_GAUGE_SCALE;\n                secondRecipientAmount = currentBalance - firstRecipientAmount;\n\n                transferFirstRecipient(firstRecipientAmount);\n                transferSecondRecipient(secondRecipientAmount);\n            }\n\n            emit PeriodUpdated(\n                oldPeriod,\n                period,\n                firstRecipientAmount,\n                secondRecipientAmount\n            );\n        }\n    }\n\n    /// @notice Returns the address of the epoch governor.\n    ///         Must adhere to a 1 week epoch of a splitter.\n    function epochGovernor() internal view virtual returns (address);\n\n    /// @notice Transfers amount to the first recipient.\n    function transferFirstRecipient(uint256 amount) internal virtual;\n\n    /// @notice Transfers amount to the second recipient.\n    function transferSecondRecipient(uint256 amount) internal virtual;\n}\n"
    },
    "contracts/ve/Balance.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\nimport {SafeCastLibrary} from \"../libraries/SafeCastLibrary.sol\";\nimport {VotingEscrowState} from \"./VotingEscrowState.sol\";\n\nlibrary Balance {\n    using SafeCastLibrary for uint256;\n    using SafeCastLibrary for int128;\n\n    uint256 internal constant WEEK = 1 weeks;\n\n    /// @notice Binary search to get the user point index for a token id at or prior to a given timestamp\n    /// @dev If a user point does not exist prior to the timestamp, this will return 0.\n    /// @param _tokenId .\n    /// @param _timestamp .\n    /// @return User point index\n    function getPastUserPointIndex(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        uint256 _timestamp\n    ) internal view returns (uint256) {\n        uint256 _userEpoch = self.userPointEpoch[_tokenId];\n        if (_userEpoch == 0) return 0;\n        // First check most recent balance\n        if (self._userPointHistory[_tokenId][_userEpoch].ts <= _timestamp)\n            return (_userEpoch);\n        // Next check implicit zero balance\n        if (self._userPointHistory[_tokenId][1].ts > _timestamp) return 0;\n\n        uint256 lower = 0;\n        uint256 upper = _userEpoch;\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            IVotingEscrow.UserPoint storage userPoint = self._userPointHistory[\n                _tokenId\n            ][center];\n            if (userPoint.ts == _timestamp) {\n                return center;\n            } else if (userPoint.ts < _timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    /// @notice Binary search to get the global point index at or prior to a given timestamp\n    /// @dev If a checkpoint does not exist prior to the timestamp, this will return 0.\n    /// @param _timestamp .\n    /// @return Global point index\n    function getPastGlobalPointIndex(\n        VotingEscrowState.Storage storage self,\n        uint256 _timestamp\n    ) internal view returns (uint256) {\n        if (self.epoch == 0) return 0;\n        // First check most recent balance\n        if (self._pointHistory[self.epoch].ts <= _timestamp)\n            return (self.epoch);\n        // Next check implicit zero balance\n        if (self._pointHistory[1].ts > _timestamp) return 0;\n\n        uint256 lower = 0;\n        uint256 upper = self.epoch;\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            IVotingEscrow.GlobalPoint storage globalPoint = self._pointHistory[\n                center\n            ];\n            if (globalPoint.ts == _timestamp) {\n                return center;\n            } else if (globalPoint.ts < _timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    /// @notice Get the current voting power for `_tokenId`\n    /// @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\n    ///      Fetches last user point prior to a certain timestamp, then walks forward to timestamp.\n    /// @param _tokenId NFT for lock\n    /// @param _t Epoch time to return voting power at\n    /// @return User voting power\n    function _balanceOfNFTAt(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        uint256 _t\n    ) internal view returns (uint256) {\n        uint256 _epoch = getPastUserPointIndex(self, _tokenId, _t);\n        // epoch 0 is an empty point\n        if (_epoch == 0) return 0;\n        IVotingEscrow.UserPoint memory lastPoint = self._userPointHistory[\n            _tokenId\n        ][_epoch];\n        if (lastPoint.permanent != 0) {\n            return lastPoint.permanent;\n        } else {\n            lastPoint.bias -= lastPoint.slope * (_t - lastPoint.ts).toInt128();\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n            return lastPoint.bias.toUint256();\n        }\n    }\n\n    function _balanceOfNFT(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId\n    ) external view returns (uint256) {\n        if (self.ownershipChange[_tokenId] == block.number) return 0;\n        return _balanceOfNFTAt(self, _tokenId, block.timestamp);\n    }\n\n    /// @notice Calculate total voting power at some point in the past\n    /// @param _t Time to calculate the total voting power at\n    /// @return Total voting power at that time\n    function supplyAt(\n        VotingEscrowState.Storage storage self,\n        uint256 _t\n    ) external view returns (uint256) {\n        uint256 epoch_ = getPastGlobalPointIndex(self, _t);\n        // epoch 0 is an empty point\n        if (epoch_ == 0) return 0;\n        IVotingEscrow.GlobalPoint memory _point = self._pointHistory[epoch_];\n        int128 bias = _point.bias;\n        int128 slope = _point.slope;\n        uint256 ts = _point.ts;\n        uint256 t_i = (ts / WEEK) * WEEK;\n        for (uint256 i = 0; i < 255; ++i) {\n            t_i += WEEK;\n            int128 dSlope = 0;\n            if (t_i > _t) {\n                t_i = _t;\n            } else {\n                dSlope = self.slopeChanges[t_i];\n            }\n            bias -= slope * (t_i - ts).toInt128();\n            if (t_i == _t) {\n                break;\n            }\n            slope += dSlope;\n            ts = t_i;\n        }\n\n        if (bias < 0) {\n            bias = 0;\n        }\n        return bias.toUint256() + _point.permanentLockBalance;\n    }\n}\n"
    },
    "contracts/ve/Delegation.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport {VotingEscrowState} from \"./VotingEscrowState.sol\";\nimport {NFT} from \"./NFT.sol\";\nimport {VeERC2771Context} from \"./VeERC2771Context.sol\";\nimport {SafeCastLibrary} from \"../libraries/SafeCastLibrary.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\nimport {IVotes} from \"../governance/IVotes.sol\";\n\nlibrary Delegation {\n    using SafeCastLibrary for int128;\n    using NFT for VotingEscrowState.Storage;\n    using VeERC2771Context for VotingEscrowState.Storage;\n\n    struct SignatureData {\n        uint256 delegator;\n        uint256 delegatee;\n        uint256 nonce;\n        uint256 expiry;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\n            \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\n        );\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\n            \"Delegation(uint256 delegator,uint256 delegatee,uint256 nonce,uint256 expiry)\"\n        );\n\n    function delegate(\n        VotingEscrowState.Storage storage self,\n        uint256 delegator,\n        uint256 delegatee\n    ) external {\n        if (!self._isApprovedOrOwner(self._msgSender(), delegator))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        return _delegate(self, delegator, delegatee);\n    }\n\n    function delegateBySig(\n        VotingEscrowState.Storage storage self,\n        SignatureData calldata signatureData,\n        string calldata contractName,\n        string calldata contractVersion\n    ) external {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (\n            uint256(signatureData.s) >\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n        ) revert IVotingEscrow.InvalidSignatureS();\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(contractName)),\n                keccak256(bytes(contractVersion)),\n                block.chainid,\n                address(this)\n            )\n        );\n        bytes32 structHash = keccak256(\n            abi.encode(\n                DELEGATION_TYPEHASH,\n                signatureData.delegator,\n                signatureData.delegatee,\n                signatureData.nonce,\n                signatureData.expiry\n            )\n        );\n        bytes32 digest = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n        address signatory = ecrecover(\n            digest,\n            signatureData.v,\n            signatureData.r,\n            signatureData.s\n        );\n        if (!self._isApprovedOrOwner(signatory, signatureData.delegator))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        if (signatory == address(0)) revert IVotingEscrow.InvalidSignature();\n        if (signatureData.nonce != self.nonces[signatory]++)\n            revert IVotingEscrow.InvalidNonce();\n        if (block.timestamp > signatureData.expiry)\n            revert IVotingEscrow.SignatureExpired();\n        return\n            _delegate(self, signatureData.delegator, signatureData.delegatee);\n    }\n\n    /// @notice Record user delegation checkpoints. Used by voting system.\n    /// @dev Skips delegation if already delegated to `delegatee`.\n    function _delegate(\n        VotingEscrowState.Storage storage self,\n        uint256 _delegator,\n        uint256 _delegatee\n    ) internal {\n        IVotingEscrow.LockedBalance memory delegateLocked = self._locked[\n            _delegator\n        ];\n        if (!delegateLocked.isPermanent)\n            revert IVotingEscrow.NotPermanentLock();\n        if (_delegatee != 0 && self._ownerOf(_delegatee) == address(0))\n            revert IVotingEscrow.NonExistentToken();\n        if (self.ownershipChange[_delegator] == block.number)\n            revert IVotingEscrow.OwnershipChange();\n        if (_delegatee == _delegator) _delegatee = 0;\n        uint256 currentDelegate = self._delegates[_delegator];\n        if (currentDelegate == _delegatee) return;\n\n        uint256 delegatedBalance = delegateLocked.amount.toUint256();\n        _checkpointDelegator(\n            self,\n            _delegator,\n            _delegatee,\n            self._ownerOf(_delegator)\n        );\n        _checkpointDelegatee(self, _delegatee, delegatedBalance, true);\n\n        emit IVotes.DelegateChanged(\n            self._msgSender(),\n            currentDelegate,\n            _delegatee\n        );\n    }\n\n    /// @notice Used by `_mint`, `_transferFrom`, `_burn` and `delegate`\n    ///         to update delegator voting checkpoints.\n    ///         Automatically dedelegates, then updates checkpoint.\n    /// @dev This function depends on `_locked` and must be called prior to token state changes.\n    ///      If you wish to dedelegate only, use `_delegate(tokenId, 0)` instead.\n    /// @param _delegator The delegator to update checkpoints for\n    /// @param _delegatee The new delegatee for the delegator. Cannot be equal to `_delegator` (use 0 instead).\n    /// @param _owner The new (or current) owner for the delegator\n    function _checkpointDelegator(\n        VotingEscrowState.Storage storage self,\n        uint256 _delegator,\n        uint256 _delegatee,\n        address _owner\n    ) internal {\n        uint256 delegatedBalance = self._locked[_delegator].amount.toUint256();\n        uint48 numCheckpoint = self.numCheckpoints[_delegator];\n        IVotingEscrow.Checkpoint storage cpOld = numCheckpoint > 0\n            ? self._checkpoints[_delegator][numCheckpoint - 1]\n            : self._checkpoints[_delegator][0];\n        // Dedelegate from delegatee if delegated\n        _checkpointDelegatee(self, cpOld.delegatee, delegatedBalance, false);\n        IVotingEscrow.Checkpoint storage cp = self._checkpoints[_delegator][\n            numCheckpoint\n        ];\n        cp.fromTimestamp = block.timestamp;\n        cp.delegatedBalance = cpOld.delegatedBalance;\n        cp.delegatee = _delegatee;\n        cp.owner = _owner;\n\n        if (_isCheckpointInNewBlock(self, _delegator)) {\n            self.numCheckpoints[_delegator]++;\n        } else {\n            self._checkpoints[_delegator][numCheckpoint - 1] = cp;\n            delete self._checkpoints[_delegator][numCheckpoint];\n        }\n\n        self._delegates[_delegator] = _delegatee;\n    }\n\n    /// @notice Update delegatee's `delegatedBalance` by `balance`.\n    ///         Only updates if delegating to a new delegatee.\n    /// @dev If used with `balance` == `_locked[_tokenId].amount`, then this is the same as\n    ///      delegating or dedelegating from `_tokenId`\n    ///      If used with `balance` < `_locked[_tokenId].amount`, then this is used to adjust\n    ///      `delegatedBalance` when a user's balance is modified (e.g. `increaseAmount`, `merge` etc).\n    ///      If `delegatee` is 0 (i.e. user is not delegating), then do nothing.\n    /// @param _delegatee The delegatee's tokenId\n    /// @param balance_ The delta in balance change\n    /// @param _increase True if balance is increasing, false if decreasing\n    function _checkpointDelegatee(\n        VotingEscrowState.Storage storage self,\n        uint256 _delegatee,\n        uint256 balance_,\n        bool _increase\n    ) internal {\n        if (_delegatee == 0) return;\n        uint48 numCheckpoint = self.numCheckpoints[_delegatee];\n        IVotingEscrow.Checkpoint storage cpOld = numCheckpoint > 0\n            ? self._checkpoints[_delegatee][numCheckpoint - 1]\n            : self._checkpoints[_delegatee][0];\n        IVotingEscrow.Checkpoint storage cp = self._checkpoints[_delegatee][\n            numCheckpoint\n        ];\n        cp.fromTimestamp = block.timestamp;\n        cp.owner = cpOld.owner;\n        // do not expect balance_ > cpOld.delegatedBalance when decrementing but just in case\n        cp.delegatedBalance = _increase\n            ? cpOld.delegatedBalance + balance_\n            : (\n                balance_ < cpOld.delegatedBalance\n                    ? cpOld.delegatedBalance - balance_\n                    : 0\n            );\n        cp.delegatee = cpOld.delegatee;\n\n        if (_isCheckpointInNewBlock(self, _delegatee)) {\n            self.numCheckpoints[_delegatee]++;\n        } else {\n            self._checkpoints[_delegatee][numCheckpoint - 1] = cp;\n            delete self._checkpoints[_delegatee][numCheckpoint];\n        }\n    }\n\n    function _isCheckpointInNewBlock(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId\n    ) internal view returns (bool) {\n        uint48 _nCheckPoints = self.numCheckpoints[_tokenId];\n\n        if (\n            _nCheckPoints > 0 &&\n            self._checkpoints[_tokenId][_nCheckPoints - 1].fromTimestamp ==\n            block.timestamp\n        ) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /// @notice Retrieves historical voting balance for a token id at a given timestamp.\n    /// @dev If a checkpoint does not exist prior to the timestamp, this will return 0.\n    ///      The user must also own the token at the time in order to receive a voting balance.\n    /// @param _account .\n    /// @param _tokenId .\n    /// @param _timestamp .\n    /// @return Total voting balance including delegations at a given timestamp.\n    function getPastVotes(\n        VotingEscrowState.Storage storage self,\n        address _account,\n        uint256 _tokenId,\n        uint256 _timestamp\n    ) external view returns (uint256) {\n        uint48 _checkIndex = getPastVotesIndex(self, _tokenId, _timestamp);\n        IVotingEscrow.Checkpoint memory lastCheckpoint = self._checkpoints[\n            _tokenId\n        ][_checkIndex];\n        // If no point exists prior to the given timestamp, return 0\n        if (lastCheckpoint.fromTimestamp > _timestamp) return 0;\n        // Check ownership\n        if (_account != lastCheckpoint.owner) return 0;\n        uint256 votes = lastCheckpoint.delegatedBalance;\n        return\n            lastCheckpoint.delegatee == 0\n                ? votes +\n                    IVotingEscrow(address(this)).balanceOfNFTAt(\n                        _tokenId,\n                        _timestamp\n                    )\n                : votes;\n    }\n\n    /// @notice Binary search to get the voting checkpoint for a token id at or prior to a given timestamp.\n    /// @dev If a checkpoint does not exist prior to the timestamp, this will return 0.\n    /// @param _tokenId .\n    /// @param _timestamp .\n    /// @return The index of the checkpoint.\n    function getPastVotesIndex(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        uint256 _timestamp\n    ) internal view returns (uint48) {\n        uint48 nCheckpoints = self.numCheckpoints[_tokenId];\n        if (nCheckpoints == 0) return 0;\n        // First check most recent balance\n        if (\n            self._checkpoints[_tokenId][nCheckpoints - 1].fromTimestamp <=\n            _timestamp\n        ) return (nCheckpoints - 1);\n        // Next check implicit zero balance\n        if (self._checkpoints[_tokenId][0].fromTimestamp > _timestamp) return 0;\n\n        uint48 lower = 0;\n        uint48 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint48 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            IVotingEscrow.Checkpoint storage cp = self._checkpoints[_tokenId][\n                center\n            ];\n            if (cp.fromTimestamp == _timestamp) {\n                return center;\n            } else if (cp.fromTimestamp < _timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n}\n"
    },
    "contracts/ve/Escrow.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport {VotingEscrowState} from \"./VotingEscrowState.sol\";\nimport {Delegation} from \"./Delegation.sol\";\nimport {NFT} from \"./NFT.sol\";\nimport {VeERC2771Context} from \"./VeERC2771Context.sol\";\nimport {SafeCastLibrary} from \"../libraries/SafeCastLibrary.sol\";\nimport {IReward} from \"../interfaces/IReward.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC4906} from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nlibrary Escrow {\n    using SafeERC20 for IERC20;\n    using SafeCastLibrary for uint256;\n    using SafeCastLibrary for int128;\n    using NFT for VotingEscrowState.Storage;\n    using Delegation for VotingEscrowState.Storage;\n    using VeERC2771Context for VotingEscrowState.Storage;\n\n    uint256 internal constant WEEK = 1 weeks;\n    uint256 internal constant MAXTIME = 4 * 365 * 86400;\n    int128 internal constant iMAXTIME = 4 * 365 * 86400;\n    uint256 internal constant MULTIPLIER = 1 ether;\n\n    function depositFor(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        uint256 _value\n    ) external {\n        if (\n            self.escrowType[_tokenId] == IVotingEscrow.EscrowType.MANAGED &&\n            self._msgSender() != self.distributor\n        ) revert IVotingEscrow.NotDistributor();\n        _increaseAmountFor(\n            self,\n            _tokenId,\n            _value,\n            IVotingEscrow.DepositType.DEPOSIT_FOR_TYPE\n        );\n    }\n\n    /// @notice Deposit and lock tokens for a user\n    /// @param _tokenId NFT that holds lock\n    /// @param _value Amount to deposit\n    /// @param _unlockTime New time when to unlock the tokens, or 0 if unchanged\n    /// @param _oldLocked Previous locked amount / timestamp\n    /// @param _depositType The type of deposit\n    function _depositFor(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        uint256 _value,\n        uint256 _unlockTime,\n        IVotingEscrow.LockedBalance memory _oldLocked,\n        IVotingEscrow.DepositType _depositType\n    ) internal {\n        uint256 supplyBefore = self.supply;\n        self.supply = supplyBefore + _value;\n\n        // Set newLocked to _oldLocked without mangling memory\n        IVotingEscrow.LockedBalance memory newLocked;\n        (newLocked.amount, newLocked.end, newLocked.isPermanent) = (\n            _oldLocked.amount,\n            _oldLocked.end,\n            _oldLocked.isPermanent\n        );\n\n        // Adding to existing lock, or if a lock is expired - creating a new one\n        newLocked.amount += _value.toInt128();\n        if (_unlockTime != 0) {\n            newLocked.end = _unlockTime;\n        }\n        self._locked[_tokenId] = newLocked;\n\n        // Possibilities:\n        // Both _oldLocked.end could be current or expired (>/< block.timestamp)\n        // or if the lock is a permanent lock, then _oldLocked.end == 0\n        // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\n        // newLocked.end > block.timestamp (always)\n        _checkpoint(self, _tokenId, _oldLocked, newLocked);\n\n        address from = self._msgSender();\n        if (_value != 0) {\n            IERC20(self.token).safeTransferFrom(from, address(this), _value);\n        }\n\n        emit IVotingEscrow.Deposit(\n            from,\n            _tokenId,\n            _depositType,\n            _value,\n            newLocked.end,\n            block.timestamp\n        );\n        emit IVotingEscrow.Supply(supplyBefore, supplyBefore + _value);\n    }\n\n    /// @notice Record global and per-user data to checkpoints. Used by VotingEscrow system.\n    /// @param _tokenId NFT token ID. No user checkpoint if 0\n    /// @param _oldLocked Previous locked amount / end lock time for the user\n    /// @param _newLocked New locked amount / end lock time for the user\n    function _checkpoint(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        IVotingEscrow.LockedBalance memory _oldLocked,\n        IVotingEscrow.LockedBalance memory _newLocked\n    ) internal {\n        IVotingEscrow.UserPoint memory uOld;\n        IVotingEscrow.UserPoint memory uNew;\n        int128 oldDslope = 0;\n        int128 newDslope = 0;\n        uint256 _epoch = self.epoch;\n\n        if (_tokenId != 0) {\n            uNew.permanent = _newLocked.isPermanent\n                ? _newLocked.amount.toUint256()\n                : 0;\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (_oldLocked.end > block.timestamp && _oldLocked.amount > 0) {\n                uOld.slope = _oldLocked.amount / iMAXTIME;\n                uOld.bias =\n                    uOld.slope *\n                    (_oldLocked.end - block.timestamp).toInt128();\n            }\n            if (_newLocked.end > block.timestamp && _newLocked.amount > 0) {\n                uNew.slope = _newLocked.amount / iMAXTIME;\n                uNew.bias =\n                    uNew.slope *\n                    (_newLocked.end - block.timestamp).toInt128();\n            }\n\n            // Read values of scheduled changes in the slope\n            // _oldLocked.end can be in the past and in the future\n            // _newLocked.end can ONLY by in the FUTURE unless everything expired: than zeros\n            oldDslope = self.slopeChanges[_oldLocked.end];\n            if (_newLocked.end != 0) {\n                if (_newLocked.end == _oldLocked.end) {\n                    newDslope = oldDslope;\n                } else {\n                    newDslope = self.slopeChanges[_newLocked.end];\n                }\n            }\n        }\n\n        IVotingEscrow.GlobalPoint memory lastPoint = IVotingEscrow.GlobalPoint({\n            bias: 0,\n            slope: 0,\n            ts: block.timestamp,\n            blk: block.number,\n            permanentLockBalance: 0\n        });\n        if (_epoch > 0) {\n            lastPoint = self._pointHistory[_epoch];\n        }\n        uint256 lastCheckpoint = lastPoint.ts;\n        // initialLastPoint is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        IVotingEscrow.GlobalPoint memory initialLastPoint = IVotingEscrow\n            .GlobalPoint({\n                bias: lastPoint.bias,\n                slope: lastPoint.slope,\n                ts: lastPoint.ts,\n                blk: lastPoint.blk,\n                permanentLockBalance: lastPoint.permanentLockBalance\n            });\n        uint256 blockSlope = 0; // dblock/dt\n        if (block.timestamp > lastPoint.ts) {\n            blockSlope =\n                (MULTIPLIER * (block.number - lastPoint.blk)) /\n                (block.timestamp - lastPoint.ts);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        (_epoch, lastPoint) = _updateHistory(\n            self,\n            _epoch,\n            lastPoint,\n            lastCheckpoint,\n            initialLastPoint,\n            blockSlope\n        );\n\n        if (_tokenId != 0) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            lastPoint.slope += (uNew.slope - uOld.slope);\n            lastPoint.bias += (uNew.bias - uOld.bias);\n            if (lastPoint.slope < 0) {\n                lastPoint.slope = 0;\n            }\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n            lastPoint.permanentLockBalance = self.permanentLockBalance;\n        }\n\n        // If timestamp of last global point is the same, overwrite the last global point\n        // Else record the new global point into history\n        // Exclude epoch 0 (note: _epoch is always >= 1, see above)\n        // Two possible outcomes:\n        // Missing global checkpoints in prior weeks. In this case, _epoch = epoch + x, where x > 1\n        // No missing global checkpoints, but timestamp != block.timestamp. Create new checkpoint.\n        // No missing global checkpoints, but timestamp == block.timestamp. Overwrite last checkpoint.\n        if (\n            _epoch != 1 && self._pointHistory[_epoch - 1].ts == block.timestamp\n        ) {\n            // _epoch = epoch + 1, so we do not increment epoch\n            self._pointHistory[_epoch - 1] = lastPoint;\n        } else {\n            // more than one global point may have been written, so we update epoch\n            self.epoch = _epoch;\n            self._pointHistory[_epoch] = lastPoint;\n        }\n\n        if (_tokenId != 0) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [_newLocked.end]\n            // and add old_user_slope to [_oldLocked.end]\n            if (_oldLocked.end > block.timestamp) {\n                // oldDslope was <something> - uOld.slope, so we cancel that\n                oldDslope += uOld.slope;\n                if (_newLocked.end == _oldLocked.end) {\n                    oldDslope -= uNew.slope; // It was a new deposit, not extension\n                }\n                self.slopeChanges[_oldLocked.end] = oldDslope;\n            }\n\n            if (_newLocked.end > block.timestamp) {\n                // update slope if new lock is greater than old lock and is not permanent or if old lock is permanent\n                if ((_newLocked.end > _oldLocked.end)) {\n                    newDslope -= uNew.slope; // old slope disappeared at this point\n                    self.slopeChanges[_newLocked.end] = newDslope;\n                }\n                // else: we recorded it already in oldDslope\n            }\n            // If timestamp of last user point is the same, overwrite the last user point\n            // Else record the new user point into history\n            // Exclude epoch 0\n            uNew.ts = block.timestamp;\n            uNew.blk = block.number;\n            uint256 userEpoch = self.userPointEpoch[_tokenId];\n            if (\n                userEpoch != 0 &&\n                self._userPointHistory[_tokenId][userEpoch].ts ==\n                block.timestamp\n            ) {\n                self._userPointHistory[_tokenId][userEpoch] = uNew;\n            } else {\n                self.userPointEpoch[_tokenId] = ++userEpoch;\n                self._userPointHistory[_tokenId][userEpoch] = uNew;\n            }\n        }\n    }\n\n    function _updateHistory(\n        VotingEscrowState.Storage storage self,\n        uint256 _epoch,\n        IVotingEscrow.GlobalPoint memory lastPoint,\n        uint256 lastCheckpoint,\n        IVotingEscrow.GlobalPoint memory initialLastPoint,\n        uint256 blockSlope\n    ) internal returns (uint256, IVotingEscrow.GlobalPoint memory) {\n        uint256 t_i = (lastCheckpoint / WEEK) * WEEK;\n        for (uint256 i = 0; i < 255; ++i) {\n            // Hopefully it won't happen that this won't get used in 5 years!\n            // If it does, users will be able to withdraw but vote weight will be broken\n            t_i += WEEK; // Initial value of t_i is always larger than the ts of the last point\n            int128 d_slope = 0;\n            if (t_i > block.timestamp) {\n                t_i = block.timestamp;\n            } else {\n                d_slope = self.slopeChanges[t_i];\n            }\n            lastPoint.bias -=\n                lastPoint.slope *\n                (t_i - lastCheckpoint).toInt128();\n            lastPoint.slope += d_slope;\n            if (lastPoint.bias < 0) {\n                // This can happen\n                lastPoint.bias = 0;\n            }\n            if (lastPoint.slope < 0) {\n                // This cannot happen - just in case\n                lastPoint.slope = 0;\n            }\n            lastCheckpoint = t_i;\n            lastPoint.ts = t_i;\n            lastPoint.blk =\n                initialLastPoint.blk +\n                (blockSlope * (t_i - initialLastPoint.ts)) /\n                MULTIPLIER;\n            _epoch += 1;\n            if (t_i == block.timestamp) {\n                lastPoint.blk = block.number;\n                break;\n            } else {\n                self._pointHistory[_epoch] = lastPoint;\n            }\n        }\n        return (_epoch, lastPoint);\n    }\n\n    /// @dev Deposit `_value` tokens for `_to` and lock for `_lockDuration`\n    /// @param _value Amount to deposit\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    function _createLock(\n        VotingEscrowState.Storage storage self,\n        uint256 _value,\n        uint256 _lockDuration,\n        address _to\n    ) external returns (uint256) {\n        uint256 unlockTime = ((block.timestamp + _lockDuration) / WEEK) * WEEK; // Locktime is rounded down to weeks\n\n        if (_value == 0) revert IVotingEscrow.ZeroAmount();\n        if (unlockTime <= block.timestamp)\n            revert IVotingEscrow.LockDurationNotInFuture();\n        if (unlockTime > block.timestamp + MAXTIME)\n            revert IVotingEscrow.LockDurationTooLong();\n\n        uint256 _tokenId = ++self.tokenId;\n        self._mint(_to, _tokenId);\n\n        _depositFor(\n            self,\n            _tokenId,\n            _value,\n            unlockTime,\n            self._locked[_tokenId],\n            IVotingEscrow.DepositType.CREATE_LOCK_TYPE\n        );\n        return _tokenId;\n    }\n\n    function increaseAmount(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        uint256 _value\n    ) external {\n        if (!self._isApprovedOrOwner(self._msgSender(), _tokenId))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        _increaseAmountFor(\n            self,\n            _tokenId,\n            _value,\n            IVotingEscrow.DepositType.INCREASE_LOCK_AMOUNT\n        );\n    }\n\n    function _increaseAmountFor(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        uint256 _value,\n        IVotingEscrow.DepositType _depositType\n    ) internal {\n        IVotingEscrow.EscrowType _escrowType = self.escrowType[_tokenId];\n        if (_escrowType == IVotingEscrow.EscrowType.LOCKED)\n            revert IVotingEscrow.NotManagedOrNormalNFT();\n\n        IVotingEscrow.LockedBalance memory oldLocked = self._locked[_tokenId];\n\n        if (_value == 0) revert IVotingEscrow.ZeroAmount();\n        if (oldLocked.amount <= 0) revert IVotingEscrow.NoLockFound();\n        if (oldLocked.end <= block.timestamp && !oldLocked.isPermanent)\n            revert IVotingEscrow.LockExpired();\n\n        if (oldLocked.isPermanent) self.permanentLockBalance += _value;\n        self._checkpointDelegatee(self._delegates[_tokenId], _value, true);\n        _depositFor(self, _tokenId, _value, 0, oldLocked, _depositType);\n\n        if (_escrowType == IVotingEscrow.EscrowType.MANAGED) {\n            // increaseAmount called on managed tokens are treated as locked rewards\n            address _lockedManagedReward = self.managedToLocked[_tokenId];\n            address _token = self.token;\n            IERC20(_token).safeApprove(_lockedManagedReward, _value);\n            IReward(_lockedManagedReward).notifyRewardAmount(_token, _value);\n            IERC20(_token).safeApprove(_lockedManagedReward, 0);\n        }\n\n        emit IERC4906.MetadataUpdate(_tokenId);\n    }\n\n    function increaseUnlockTime(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        uint256 _lockDuration\n    ) external {\n        if (!self._isApprovedOrOwner(self._msgSender(), _tokenId))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.NORMAL)\n            revert IVotingEscrow.NotNormalNFT();\n\n        IVotingEscrow.LockedBalance memory oldLocked = self._locked[_tokenId];\n        if (oldLocked.isPermanent) revert IVotingEscrow.PermanentLock();\n        uint256 unlockTime = ((block.timestamp + _lockDuration) / WEEK) * WEEK; // Locktime is rounded down to weeks\n\n        if (oldLocked.end <= block.timestamp)\n            revert IVotingEscrow.LockExpired();\n        if (oldLocked.amount <= 0) revert IVotingEscrow.NoLockFound();\n        if (unlockTime <= oldLocked.end)\n            revert IVotingEscrow.LockDurationNotInFuture();\n        if (unlockTime > block.timestamp + MAXTIME)\n            revert IVotingEscrow.LockDurationTooLong();\n\n        _depositFor(\n            self,\n            _tokenId,\n            0,\n            unlockTime,\n            oldLocked,\n            IVotingEscrow.DepositType.INCREASE_UNLOCK_TIME\n        );\n\n        emit IERC4906.MetadataUpdate(_tokenId);\n    }\n\n    function withdraw(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId\n    ) external {\n        address sender = self._msgSender();\n        if (!self._isApprovedOrOwner(sender, _tokenId))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        if (self.voted[_tokenId]) revert IVotingEscrow.AlreadyVoted();\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.NORMAL)\n            revert IVotingEscrow.NotNormalNFT();\n\n        IVotingEscrow.LockedBalance memory oldLocked = self._locked[_tokenId];\n        if (oldLocked.isPermanent) revert IVotingEscrow.PermanentLock();\n        if (block.timestamp < oldLocked.end)\n            revert IVotingEscrow.LockNotExpired();\n        uint256 value = oldLocked.amount.toUint256();\n\n        // Burn the NFT\n        self._burn(_tokenId);\n        self._locked[_tokenId] = IVotingEscrow.LockedBalance(0, 0, false);\n        uint256 supplyBefore = self.supply;\n        self.supply = supplyBefore - value;\n\n        // oldLocked can have either expired <= timestamp or zero end\n        // oldLocked has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(\n            self,\n            _tokenId,\n            oldLocked,\n            IVotingEscrow.LockedBalance(0, 0, false)\n        );\n\n        IERC20(self.token).safeTransfer(sender, value);\n\n        emit IVotingEscrow.Withdraw(sender, _tokenId, value, block.timestamp);\n        emit IVotingEscrow.Supply(supplyBefore, supplyBefore - value);\n    }\n\n    function merge(\n        VotingEscrowState.Storage storage self,\n        uint256 _from,\n        uint256 _to\n    ) external {\n        address sender = self._msgSender();\n        if (self.voted[_from]) revert IVotingEscrow.AlreadyVoted();\n        if (self.escrowType[_from] != IVotingEscrow.EscrowType.NORMAL)\n            revert IVotingEscrow.NotNormalNFT();\n        if (self.escrowType[_to] != IVotingEscrow.EscrowType.NORMAL)\n            revert IVotingEscrow.NotNormalNFT();\n        if (_from == _to) revert IVotingEscrow.SameNFT();\n        if (!self._isApprovedOrOwner(sender, _from))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        if (!self._isApprovedOrOwner(sender, _to))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        IVotingEscrow.LockedBalance memory oldLockedTo = self._locked[_to];\n        if (oldLockedTo.end <= block.timestamp && !oldLockedTo.isPermanent)\n            revert IVotingEscrow.LockExpired();\n\n        IVotingEscrow.LockedBalance memory oldLockedFrom = self._locked[_from];\n        if (oldLockedFrom.isPermanent) revert IVotingEscrow.PermanentLock();\n        uint256 end = oldLockedFrom.end >= oldLockedTo.end\n            ? oldLockedFrom.end\n            : oldLockedTo.end;\n\n        self._burn(_from);\n        self._locked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\n        _checkpoint(\n            self,\n            _from,\n            oldLockedFrom,\n            IVotingEscrow.LockedBalance(0, 0, false)\n        );\n\n        IVotingEscrow.LockedBalance memory newLockedTo;\n        newLockedTo.amount = oldLockedTo.amount + oldLockedFrom.amount;\n        newLockedTo.isPermanent = oldLockedTo.isPermanent;\n        if (newLockedTo.isPermanent) {\n            self.permanentLockBalance += oldLockedFrom.amount.toUint256();\n        } else {\n            newLockedTo.end = end;\n        }\n        self._checkpointDelegatee(\n            self._delegates[_to],\n            oldLockedFrom.amount.toUint256(),\n            true\n        );\n        _checkpoint(self, _to, oldLockedTo, newLockedTo);\n        self._locked[_to] = newLockedTo;\n\n        emit IVotingEscrow.Merge(\n            sender,\n            _from,\n            _to,\n            oldLockedFrom.amount.toUint256(),\n            oldLockedTo.amount.toUint256(),\n            newLockedTo.amount.toUint256(),\n            newLockedTo.end,\n            block.timestamp\n        );\n        emit IERC4906.MetadataUpdate(_to);\n    }\n\n    function split(\n        VotingEscrowState.Storage storage self,\n        uint256 _from,\n        uint256 _amount\n    ) external returns (uint256 _tokenId1, uint256 _tokenId2) {\n        address sender = self._msgSender();\n        address owner = self._ownerOf(_from);\n        if (owner == address(0)) revert IVotingEscrow.SplitNoOwner();\n        if (!self.canSplit[owner] && !self.canSplit[address(0)])\n            revert IVotingEscrow.SplitNotAllowed();\n        if (self.escrowType[_from] != IVotingEscrow.EscrowType.NORMAL)\n            revert IVotingEscrow.NotNormalNFT();\n        if (self.voted[_from]) revert IVotingEscrow.AlreadyVoted();\n        if (!self._isApprovedOrOwner(sender, _from))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        IVotingEscrow.LockedBalance memory newLocked = self._locked[_from];\n        if (newLocked.end <= block.timestamp && !newLocked.isPermanent)\n            revert IVotingEscrow.LockExpired();\n        int128 _splitAmount = _amount.toInt128();\n        if (_splitAmount == 0) revert IVotingEscrow.ZeroAmount();\n        if (newLocked.amount <= _splitAmount)\n            revert IVotingEscrow.AmountTooBig();\n\n        // Zero out and burn old veNFT\n        self._burn(_from);\n        self._locked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\n        _checkpoint(\n            self,\n            _from,\n            newLocked,\n            IVotingEscrow.LockedBalance(0, 0, false)\n        );\n\n        // Create new veNFT using old balance - amount\n        newLocked.amount -= _splitAmount;\n        _tokenId1 = _createSplitNFT(self, owner, newLocked);\n\n        // Create new veNFT using amount\n        newLocked.amount = _splitAmount;\n        _tokenId2 = _createSplitNFT(self, owner, newLocked);\n\n        emit IVotingEscrow.Split(\n            _from,\n            _tokenId1,\n            _tokenId2,\n            sender,\n            self._locked[_tokenId1].amount.toUint256(),\n            _splitAmount.toUint256(),\n            newLocked.end,\n            block.timestamp\n        );\n    }\n\n    function _createSplitNFT(\n        VotingEscrowState.Storage storage self,\n        address _to,\n        IVotingEscrow.LockedBalance memory _newLocked\n    ) internal returns (uint256 _tokenId) {\n        _tokenId = ++self.tokenId;\n        self._locked[_tokenId] = _newLocked;\n        _checkpoint(\n            self,\n            _tokenId,\n            IVotingEscrow.LockedBalance(0, 0, false),\n            _newLocked\n        );\n        self._mint(_to, _tokenId);\n    }\n\n    function toggleSplit(\n        VotingEscrowState.Storage storage self,\n        address _account,\n        bool _bool\n    ) external {\n        if (self._msgSender() != self.team) revert IVotingEscrow.NotTeam();\n        self.canSplit[_account] = _bool;\n    }\n\n    function lockPermanent(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId\n    ) external {\n        address sender = self._msgSender();\n        if (!self._isApprovedOrOwner(sender, _tokenId))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.NORMAL)\n            revert IVotingEscrow.NotNormalNFT();\n        IVotingEscrow.LockedBalance memory _newLocked = self._locked[_tokenId];\n        if (_newLocked.isPermanent) revert IVotingEscrow.PermanentLock();\n        if (_newLocked.end <= block.timestamp)\n            revert IVotingEscrow.LockExpired();\n        if (_newLocked.amount <= 0) revert IVotingEscrow.NoLockFound();\n\n        uint256 _amount = _newLocked.amount.toUint256();\n        self.permanentLockBalance += _amount;\n        _newLocked.end = 0;\n        _newLocked.isPermanent = true;\n        _checkpoint(self, _tokenId, self._locked[_tokenId], _newLocked);\n        self._locked[_tokenId] = _newLocked;\n\n        emit IVotingEscrow.LockPermanent(\n            sender,\n            _tokenId,\n            _amount,\n            block.timestamp\n        );\n        emit IERC4906.MetadataUpdate(_tokenId);\n    }\n\n    function unlockPermanent(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId\n    ) external {\n        address sender = self._msgSender();\n        if (!self._isApprovedOrOwner(sender, _tokenId))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.NORMAL)\n            revert IVotingEscrow.NotNormalNFT();\n        if (self.voted[_tokenId]) revert IVotingEscrow.AlreadyVoted();\n        IVotingEscrow.LockedBalance memory _newLocked = self._locked[_tokenId];\n        if (!_newLocked.isPermanent) revert IVotingEscrow.NotPermanentLock();\n\n        uint256 _amount = _newLocked.amount.toUint256();\n        self.permanentLockBalance -= _amount;\n        _newLocked.end = ((block.timestamp + MAXTIME) / WEEK) * WEEK;\n        _newLocked.isPermanent = false;\n        self._delegate(_tokenId, 0);\n        _checkpoint(self, _tokenId, self._locked[_tokenId], _newLocked);\n        self._locked[_tokenId] = _newLocked;\n\n        emit IVotingEscrow.UnlockPermanent(\n            sender,\n            _tokenId,\n            _amount,\n            block.timestamp\n        );\n        emit IERC4906.MetadataUpdate(_tokenId);\n    }\n}\n"
    },
    "contracts/ve/ManagedNFT.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport {VotingEscrowState} from \"./VotingEscrowState.sol\";\nimport {Escrow} from \"./Escrow.sol\";\nimport {NFT} from \"./NFT.sol\";\nimport {Delegation} from \"./Delegation.sol\";\nimport {Balance} from \"./Balance.sol\";\nimport {VeERC2771Context} from \"./VeERC2771Context.sol\";\nimport {SafeCastLibrary} from \"../libraries/SafeCastLibrary.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\nimport {IReward} from \"../interfaces/IReward.sol\";\nimport {IVoter} from \"../interfaces/IVoter.sol\";\nimport {IManagedRewardsFactory} from \"../interfaces/factories/IManagedRewardsFactory.sol\";\nimport {IFactoryRegistry} from \"../interfaces/factories/IFactoryRegistry.sol\";\nimport {IERC4906} from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\n\nlibrary ManagedNFT {\n    using SafeCastLibrary for uint256;\n    using SafeCastLibrary for int128;\n    using NFT for VotingEscrowState.Storage;\n    using Escrow for VotingEscrowState.Storage;\n    using Delegation for VotingEscrowState.Storage;\n    using Balance for VotingEscrowState.Storage;\n    using VeERC2771Context for VotingEscrowState.Storage;\n\n    function createManagedLockFor(\n        VotingEscrowState.Storage storage self,\n        address _to\n    ) external returns (uint256 _mTokenId) {\n        address sender = self._msgSender();\n        if (\n            sender != self.allowedManager &&\n            sender != IVoter(self.voter).governor()\n        ) revert IVotingEscrow.NotGovernorOrManager();\n\n        _mTokenId = ++self.tokenId;\n        self._mint(_to, _mTokenId);\n        self._depositFor(\n            _mTokenId,\n            0,\n            0,\n            IVotingEscrow.LockedBalance(0, 0, true),\n            IVotingEscrow.DepositType.CREATE_LOCK_TYPE\n        );\n\n        self.escrowType[_mTokenId] = IVotingEscrow.EscrowType.MANAGED;\n\n        (\n            address _lockedManagedReward,\n            address _freeManagedReward\n        ) = IManagedRewardsFactory(\n                IFactoryRegistry(self.factoryRegistry).managedRewardsFactory()\n            ).createRewards(self.trustedForwarder, self.voter);\n        self.managedToLocked[_mTokenId] = _lockedManagedReward;\n        self.managedToFree[_mTokenId] = _freeManagedReward;\n\n        emit IVotingEscrow.CreateManaged(\n            _to,\n            _mTokenId,\n            sender,\n            _lockedManagedReward,\n            _freeManagedReward\n        );\n    }\n\n    function depositManaged(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        uint256 _mTokenId\n    ) external {\n        if (self._msgSender() != self.voter) revert IVotingEscrow.NotVoter();\n        if (self.escrowType[_mTokenId] != IVotingEscrow.EscrowType.MANAGED)\n            revert IVotingEscrow.NotManagedNFT();\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.NORMAL)\n            revert IVotingEscrow.NotNormalNFT();\n        if (self._balanceOfNFTAt(_tokenId, block.timestamp) == 0)\n            revert IVotingEscrow.ZeroBalance();\n\n        // adjust user nft\n        int128 _amount = self._locked[_tokenId].amount;\n        if (self._locked[_tokenId].isPermanent) {\n            self.permanentLockBalance -= _amount.toUint256();\n            self._delegate(_tokenId, 0);\n        }\n        self._checkpoint(\n            _tokenId,\n            self._locked[_tokenId],\n            IVotingEscrow.LockedBalance(0, 0, false)\n        );\n        self._locked[_tokenId] = IVotingEscrow.LockedBalance(0, 0, false);\n\n        // adjust managed nft\n        uint256 _weight = _amount.toUint256();\n        self.permanentLockBalance += _weight;\n        IVotingEscrow.LockedBalance memory newLocked = self._locked[_mTokenId];\n        newLocked.amount += _amount;\n        self._checkpointDelegatee(self._delegates[_mTokenId], _weight, true);\n        self._checkpoint(_mTokenId, self._locked[_mTokenId], newLocked);\n        self._locked[_mTokenId] = newLocked;\n\n        self.weights[_tokenId][_mTokenId] = _weight;\n        self.idToManaged[_tokenId] = _mTokenId;\n        self.escrowType[_tokenId] = IVotingEscrow.EscrowType.LOCKED;\n\n        address _lockedManagedReward = self.managedToLocked[_mTokenId];\n        IReward(_lockedManagedReward)._deposit(_weight, _tokenId);\n        address _freeManagedReward = self.managedToFree[_mTokenId];\n        IReward(_freeManagedReward)._deposit(_weight, _tokenId);\n\n        emit IVotingEscrow.DepositManaged(\n            self._ownerOf(_tokenId),\n            _tokenId,\n            _mTokenId,\n            _weight,\n            block.timestamp\n        );\n        emit IERC4906.MetadataUpdate(_tokenId);\n    }\n\n    function withdrawManaged(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId\n    ) external {\n        uint256 _mTokenId = self.idToManaged[_tokenId];\n        if (self._msgSender() != self.voter) revert IVotingEscrow.NotVoter();\n        if (_mTokenId == 0) revert IVotingEscrow.InvalidManagedNFTId();\n        if (self.escrowType[_tokenId] != IVotingEscrow.EscrowType.LOCKED)\n            revert IVotingEscrow.NotLockedNFT();\n\n        // update accrued rewards\n        address _lockedManagedReward = self.managedToLocked[_mTokenId];\n        address _freeManagedReward = self.managedToFree[_mTokenId];\n        uint256 _weight = self.weights[_tokenId][_mTokenId];\n        uint256 _reward = IReward(_lockedManagedReward).earned(\n            address(self.token),\n            _tokenId\n        );\n        uint256 _total = _weight + _reward;\n        uint256 _unlockTime = ((block.timestamp + Escrow.MAXTIME) /\n            Escrow.WEEK) * Escrow.WEEK;\n\n        // claim locked rewards (rebases + compounded reward)\n        address[] memory rewards = new address[](1);\n        rewards[0] = address(self.token);\n        IReward(_lockedManagedReward).getReward(_tokenId, rewards);\n\n        _adjustUserNFT(self, _tokenId, _total, _unlockTime);\n        _adjustManagedNFT(self, _mTokenId, _total);\n\n        IReward(_lockedManagedReward)._withdraw(_weight, _tokenId);\n        IReward(_freeManagedReward)._withdraw(_weight, _tokenId);\n\n        delete self.idToManaged[_tokenId];\n        delete self.weights[_tokenId][_mTokenId];\n        delete self.escrowType[_tokenId];\n\n        emit IVotingEscrow.WithdrawManaged(\n            self._ownerOf(_tokenId),\n            _tokenId,\n            _mTokenId,\n            _total,\n            block.timestamp\n        );\n        emit IERC4906.MetadataUpdate(_tokenId);\n    }\n\n    function _adjustUserNFT(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        uint256 _total,\n        uint256 _unlockTime\n    ) internal {\n        IVotingEscrow.LockedBalance memory newLockedNormal = IVotingEscrow\n            .LockedBalance(_total.toInt128(), _unlockTime, false);\n        self._checkpoint(_tokenId, self._locked[_tokenId], newLockedNormal);\n        self._locked[_tokenId] = newLockedNormal;\n    }\n\n    function _adjustManagedNFT(\n        VotingEscrowState.Storage storage self,\n        uint256 _mTokenId,\n        uint256 _total\n    ) internal {\n        IVotingEscrow.LockedBalance memory newLockedManaged = self._locked[\n            _mTokenId\n        ];\n        // do not expect _total > locked.amount / permanentLockBalance but just in case\n        newLockedManaged.amount -= (\n            _total.toInt128() < newLockedManaged.amount\n                ? _total.toInt128()\n                : newLockedManaged.amount\n        );\n        self.permanentLockBalance -= (\n            _total < self.permanentLockBalance\n                ? _total\n                : self.permanentLockBalance\n        );\n        self._checkpointDelegatee(self._delegates[_mTokenId], _total, false);\n        self._checkpoint(_mTokenId, self._locked[_mTokenId], newLockedManaged);\n        self._locked[_mTokenId] = newLockedManaged;\n    }\n\n    function setAllowedManager(\n        VotingEscrowState.Storage storage self,\n        address _allowedManager\n    ) external {\n        if (self._msgSender() != IVoter(self.voter).governor())\n            revert IVotingEscrow.NotGovernor();\n        if (_allowedManager == self.allowedManager)\n            revert IVotingEscrow.SameAddress();\n        if (_allowedManager == address(0)) revert IVotingEscrow.ZeroAddress();\n        self.allowedManager = _allowedManager;\n        emit IVotingEscrow.SetAllowedManager(_allowedManager);\n    }\n\n    function setManagedState(\n        VotingEscrowState.Storage storage self,\n        uint256 _mTokenId,\n        bool _state\n    ) external {\n        if (\n            self._msgSender() != IVoter(self.voter).emergencyCouncil() &&\n            self._msgSender() != IVoter(self.voter).governor()\n        ) revert IVotingEscrow.NotEmergencyCouncilOrGovernor();\n        if (self.escrowType[_mTokenId] != IVotingEscrow.EscrowType.MANAGED)\n            revert IVotingEscrow.NotManagedNFT();\n        if (self.deactivated[_mTokenId] == _state)\n            revert IVotingEscrow.SameState();\n        self.deactivated[_mTokenId] = _state;\n    }\n}\n"
    },
    "contracts/ve/NFT.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport {VotingEscrowState} from \"./VotingEscrowState.sol\";\nimport {Delegation} from \"./Delegation.sol\";\nimport {VeERC2771Context} from \"./VeERC2771Context.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nlibrary NFT {\n    using Delegation for VotingEscrowState.Storage;\n    using VeERC2771Context for VotingEscrowState.Storage;\n\n    function approve(\n        VotingEscrowState.Storage storage self,\n        address _approved,\n        uint256 _tokenId\n    ) external {\n        address sender = self._msgSender();\n        address owner = _ownerOf(self, _tokenId);\n        // Throws if `_tokenId` is not a valid NFT\n        if (owner == address(0)) revert IVotingEscrow.ZeroAddress();\n        // Throws if `_approved` is the current owner\n        if (owner == _approved) revert IVotingEscrow.SameAddress();\n        // Check requirements\n        bool senderIsOwner = (_ownerOf(self, _tokenId) == sender);\n        bool senderIsApprovedForAll = (self.ownerToOperators[owner])[sender];\n        if (!senderIsOwner && !senderIsApprovedForAll)\n            revert IVotingEscrow.NotApprovedOrOwner();\n        // Set the approval\n        self.idToApprovals[_tokenId] = _approved;\n        emit IERC721.Approval(owner, _approved, _tokenId);\n    }\n\n    function setApprovalForAll(\n        VotingEscrowState.Storage storage self,\n        address _operator,\n        bool _approved\n    ) external {\n        address sender = self._msgSender();\n        // Throws if `_operator` is the `msg.sender`\n        if (_operator == sender) revert IVotingEscrow.SameAddress();\n        self.ownerToOperators[sender][_operator] = _approved;\n        emit IERC721.ApprovalForAll(sender, _operator, _approved);\n    }\n\n    function safeTransferFrom(\n        VotingEscrowState.Storage storage self,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory _data\n    ) external {\n        address sender = self._msgSender();\n        _transferFrom(self, _from, _to, _tokenId, sender);\n\n        if (_isContract(_to)) {\n            // Throws if transfer destination is a contract which does not implement 'onERC721Received'\n            try\n                IERC721Receiver(_to).onERC721Received(\n                    sender,\n                    _from,\n                    _tokenId,\n                    _data\n                )\n            returns (bytes4 response) {\n                if (\n                    response != IERC721Receiver(_to).onERC721Received.selector\n                ) {\n                    revert IVotingEscrow.ERC721ReceiverRejectedTokens();\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert IVotingEscrow\n                        .ERC721TransferToNonERC721ReceiverImplementer();\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    function _transferFrom(\n        VotingEscrowState.Storage storage self,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        address _sender\n    ) internal {\n        if (self.escrowType[_tokenId] == IVotingEscrow.EscrowType.LOCKED)\n            revert IVotingEscrow.NotManagedOrNormalNFT();\n        // Check requirements\n        if (!_isApprovedOrOwner(self, _sender, _tokenId))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        // Clear approval. Throws if `_from` is not the current owner\n        if (_ownerOf(self, _tokenId) != _from) revert IVotingEscrow.NotOwner();\n        delete self.idToApprovals[_tokenId];\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\n        _removeTokenFrom(self, _from, _tokenId);\n        // Update voting checkpoints\n        self._checkpointDelegator(_tokenId, 0, _to);\n        // Add NFT\n        _addTokenTo(self, _to, _tokenId);\n        // Set the block of ownership transfer (for Flash NFT protection)\n        self.ownershipChange[_tokenId] = block.number;\n        // Log the transfer\n        emit IERC721.Transfer(_from, _to, _tokenId);\n    }\n\n    function _isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /// @dev Add a NFT to a given address\n    ///      Throws if `_tokenId` is owned by someone.\n    function _addTokenTo(\n        VotingEscrowState.Storage storage self,\n        address _to,\n        uint256 _tokenId\n    ) internal {\n        // Throws if `_tokenId` is owned by someone\n        assert(_ownerOf(self, _tokenId) == address(0));\n        // Change the owner\n        self.idToOwner[_tokenId] = _to;\n        // Update owner token index tracking\n        _addTokenToOwnerList(self, _to, _tokenId);\n        // Change count tracking\n        self.ownerToNFTokenCount[_to] += 1;\n    }\n\n    /// @dev Function to mint tokens\n    ///      Throws if `_to` is zero address.\n    ///      Throws if `_tokenId` is owned by someone.\n    /// @param _to The address that will receive the minted tokens.\n    /// @param _tokenId The token id to mint.\n    /// @return A boolean that indicates if the operation was successful.\n    function _mint(\n        VotingEscrowState.Storage storage self,\n        address _to,\n        uint256 _tokenId\n    ) internal returns (bool) {\n        // Throws if `_to` is zero address\n        assert(_to != address(0));\n        // Add NFT. Throws if `_tokenId` is owned by someone\n        _addTokenTo(self, _to, _tokenId);\n        // Update voting checkpoints\n        self._checkpointDelegator(_tokenId, 0, _to);\n        emit IERC721.Transfer(address(0), _to, _tokenId);\n        return true;\n    }\n\n    /// @dev Add a NFT to an index mapping to a given address\n    /// @param _to address of the receiver\n    /// @param _tokenId uint ID Of the token to be added\n    function _addTokenToOwnerList(\n        VotingEscrowState.Storage storage self,\n        address _to,\n        uint256 _tokenId\n    ) internal {\n        uint256 currentCount = self.ownerToNFTokenCount[_to];\n\n        self.ownerToNFTokenIdList[_to][currentCount] = _tokenId;\n        self.tokenToOwnerIndex[_tokenId] = currentCount;\n    }\n\n    function _ownerOf(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId\n    ) internal view returns (address) {\n        return self.idToOwner[_tokenId];\n    }\n\n    function _isApprovedOrOwner(\n        VotingEscrowState.Storage storage self,\n        address _spender,\n        uint256 _tokenId\n    ) internal view returns (bool) {\n        address owner = _ownerOf(self, _tokenId);\n        bool spenderIsOwner = owner == _spender;\n        bool spenderIsApproved = _spender == self.idToApprovals[_tokenId];\n        bool spenderIsApprovedForAll = (self.ownerToOperators[owner])[_spender];\n        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\n    }\n\n    /// @dev Must be called prior to updating `LockedBalance`\n    function _burn(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId\n    ) internal {\n        address sender = self._msgSender();\n        if (!_isApprovedOrOwner(self, sender, _tokenId))\n            revert IVotingEscrow.NotApprovedOrOwner();\n        address owner = _ownerOf(self, _tokenId);\n\n        // Clear approval\n        delete self.idToApprovals[_tokenId];\n        // Update voting checkpoints\n        self._checkpointDelegator(_tokenId, 0, address(0));\n        // Remove token\n        _removeTokenFrom(self, owner, _tokenId);\n        emit IERC721.Transfer(owner, address(0), _tokenId);\n    }\n\n    /// @dev Remove a NFT from a given address\n    ///      Throws if `_from` is not the current owner.\n    function _removeTokenFrom(\n        VotingEscrowState.Storage storage self,\n        address _from,\n        uint256 _tokenId\n    ) internal {\n        // Throws if `_from` is not the current owner\n        assert(_ownerOf(self, _tokenId) == _from);\n        // Change the owner\n        self.idToOwner[_tokenId] = address(0);\n        // Update owner token index tracking\n        _removeTokenFromOwnerList(self, _from, _tokenId);\n        // Change count tracking\n        self.ownerToNFTokenCount[_from] -= 1;\n    }\n\n    /// @dev Remove a NFT from an index mapping to a given address\n    /// @param _from address of the sender\n    /// @param _tokenId uint ID Of the token to be removed\n    function _removeTokenFromOwnerList(\n        VotingEscrowState.Storage storage self,\n        address _from,\n        uint256 _tokenId\n    ) internal {\n        // Delete\n        uint256 currentCount = self.ownerToNFTokenCount[_from] - 1;\n        uint256 currentIndex = self.tokenToOwnerIndex[_tokenId];\n\n        if (currentCount == currentIndex) {\n            // update ownerToNFTokenIdList\n            self.ownerToNFTokenIdList[_from][currentCount] = 0;\n            // update tokenToOwnerIndex\n            self.tokenToOwnerIndex[_tokenId] = 0;\n        } else {\n            uint256 lastTokenId = self.ownerToNFTokenIdList[_from][\n                currentCount\n            ];\n\n            // Add\n            // update ownerToNFTokenIdList\n            self.ownerToNFTokenIdList[_from][currentIndex] = lastTokenId;\n            // update tokenToOwnerIndex\n            self.tokenToOwnerIndex[lastTokenId] = currentIndex;\n\n            // Delete\n            // update ownerToNFTokenIdList\n            self.ownerToNFTokenIdList[_from][currentCount] = 0;\n            // update tokenToOwnerIndex\n            self.tokenToOwnerIndex[_tokenId] = 0;\n        }\n    }\n}\n"
    },
    "contracts/ve/VeERC2771Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Based on openzeppelin-contracts/contracts/metatx/ERC2771Context.sol\n\npragma solidity 0.8.24;\n\nimport {VotingEscrowState} from \"./VotingEscrowState.sol\";\n\n/**\n * @dev Context variant with ERC2771 support. Extracted to library to allow\n *      easy application inside libraries.\n */\nlibrary VeERC2771Context {\n    function isTrustedForwarder(\n        VotingEscrowState.Storage storage self,\n        address forwarder\n    ) internal view returns (bool) {\n        return forwarder == self.trustedForwarder;\n    }\n\n    function _msgSender(\n        VotingEscrowState.Storage storage self\n    ) internal view returns (address sender) {\n        if (isTrustedForwarder(self, msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            /// @solidity memory-safe-assembly\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return msg.sender;\n        }\n    }\n\n    function _msgData(\n        VotingEscrowState.Storage storage self\n    ) internal view returns (bytes calldata) {\n        if (isTrustedForwarder(self, msg.sender)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return msg.data;\n        }\n    }\n}\n"
    },
    "contracts/ve/VotingEscrowState.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\nimport {VeERC2771Context} from \"./VeERC2771Context.sol\";\nimport {IERC4906} from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\n\nlibrary VotingEscrowState {\n    using VeERC2771Context for Storage;\n\n    struct Storage {\n        /// @dev Address of Meta-tx Forwarder\n        address trustedForwarder;\n        /// @dev Address of FactoryRegistry.sol\n        address factoryRegistry;\n        /// @dev Address of token used to create a veNFT\n        address token;\n        /// @dev Address of RewardsDistributor.sol\n        address distributor;\n        /// @dev Address of Voter.sol\n        address voter;\n        /// @dev Address of Protocol Team multisig\n        address team;\n        /// @dev Address which can create managed NFTs\n        address allowedManager;\n        /// @dev Global point history at a given index (epoch -> unsigned global point)\n        mapping(uint256 => IVotingEscrow.GlobalPoint) _pointHistory;\n        /// @dev Mapping of interface id to bool about whether or not it's supported\n        mapping(bytes4 => bool) supportedInterfaces;\n        /// @dev Current count of token\n        uint256 tokenId;\n        /*///////////////////////////////////////////////////////////////\n                                MANAGED NFT\n        //////////////////////////////////////////////////////////////*/\n\n        /// @dev Mapping of token id to escrow type\n        ///      Takes advantage of the fact default value is EscrowType.NORMAL\n        mapping(uint256 => IVotingEscrow.EscrowType) escrowType;\n        /// @dev Mapping of token id to managed id\n        mapping(uint256 => uint256) idToManaged;\n        /// @dev Mapping of user token id to managed token id to weight of token id\n        mapping(uint256 => mapping(uint256 => uint256)) weights;\n        /// @dev Mapping of managed id to deactivated state\n        mapping(uint256 => bool) deactivated;\n        /// @dev Mapping from managed nft id to locked managed rewards\n        ///      `token` denominated rewards (rebases/rewards) stored in locked\n        ///      managed rewards contract to prevent co-mingling of assets\n        mapping(uint256 => address) managedToLocked;\n        /// @dev Mapping from managed nft id to free managed rewards contract\n        ///      these rewards can be freely withdrawn by users\n        mapping(uint256 => address) managedToFree;\n        /*//////////////////////////////////////////////////////////////\n                            ERC721 BALANCE/OWNER\n        //////////////////////////////////////////////////////////////*/\n\n        /// @dev Mapping from NFT ID to the address that owns it.\n        mapping(uint256 => address) idToOwner;\n        /// @dev Mapping from owner address to count of his tokens.\n        mapping(address => uint256) ownerToNFTokenCount;\n        /*//////////////////////////////////////////////////////////////\n                                ERC721 APPROVAL\n        //////////////////////////////////////////////////////////////*/\n\n        /// @dev Mapping from NFT ID to approved address.\n        mapping(uint256 => address) idToApprovals;\n        /// @dev Mapping from owner address to mapping of operator addresses.\n        mapping(address => mapping(address => bool)) ownerToOperators;\n        mapping(uint256 => uint256) ownershipChange;\n        /*//////////////////////////////////////////////////////////////\n                            INTERNAL MINT/BURN\n        //////////////////////////////////////////////////////////////*/\n\n        /// @dev Mapping from owner address to mapping of index to tokenId\n        mapping(address => mapping(uint256 => uint256)) ownerToNFTokenIdList;\n        /// @dev Mapping from NFT ID to index of owner\n        mapping(uint256 => uint256) tokenToOwnerIndex;\n        /*//////////////////////////////////////////////////////////////\n                                    ESCROW\n        //////////////////////////////////////////////////////////////*/\n\n        /// @dev Total count of epochs witnessed since contract creation\n        uint256 epoch;\n        /// @dev Total amount of token() deposited\n        uint256 supply;\n        mapping(uint256 => IVotingEscrow.LockedBalance) _locked;\n        mapping(uint256 => IVotingEscrow.UserPoint[1000000000]) _userPointHistory;\n        mapping(uint256 => uint256) userPointEpoch;\n        /// @dev time -> signed slope change\n        mapping(uint256 => int128) slopeChanges;\n        /// @dev account -> can split\n        mapping(address => bool) canSplit;\n        /// @dev Aggregate permanent locked balances\n        uint256 permanentLockBalance;\n        /*///////////////////////////////////////////////////////////////\n                                    DAO VOTING\n        //////////////////////////////////////////////////////////////*/\n\n        /// @dev A record of each accounts delegate\n        mapping(uint256 => uint256) _delegates;\n        /// @dev A record of delegated token checkpoints for each tokenId, by index\n        mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint)) _checkpoints;\n        /// @dev The number of checkpoints for each tokenId\n        mapping(uint256 => uint48) numCheckpoints;\n        /// @dev A record of states for signing / validating signatures\n        mapping(address => uint256) nonces;\n        /*///////////////////////////////////////////////////////////////\n                                GAUGE VOTING\n        //////////////////////////////////////////////////////////////*/\n\n        /// @dev Information on whether a tokenId has already voted\n        mapping(uint256 => bool) voted;\n        // Reserved storage space in case we need to add more variables.\n        // The convention from OpenZeppelin suggests the storage space should\n        // add up to 50 slots. Here we want to have more slots as there are\n        // planned upgrades of the VotingEscrow contract. If more entires are\n        // added to the struct in the upcoming versions we need to reduce\n        // the array size.\n        // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n        uint256[50] __gap;\n    }\n\n    function setTeam(\n        VotingEscrowState.Storage storage self,\n        address _team\n    ) internal {\n        if (self._msgSender() != self.team) revert IVotingEscrow.NotTeam();\n        if (_team == address(0)) revert IVotingEscrow.ZeroAddress();\n        self.team = _team;\n    }\n\n    function setVoterAndDistributor(\n        VotingEscrowState.Storage storage self,\n        address _voter,\n        address _distributor\n    ) internal {\n        if (self._msgSender() != self.voter) revert IVotingEscrow.NotVoter();\n        self.voter = _voter;\n        self.distributor = _distributor;\n    }\n\n    function setVoting(\n        VotingEscrowState.Storage storage self,\n        uint256 _tokenId,\n        bool _voted\n    ) internal {\n        if (self._msgSender() != self.voter) revert IVotingEscrow.NotVoter();\n        self.voted[_tokenId] = _voted;\n    }\n}\n"
    },
    "contracts/VeBTC.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.24;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\n\ncontract VeBTC is VotingEscrow {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _forwarder,\n        address _btc,\n        address _factoryRegistry\n    ) external initializer {\n        __VotingEscrow_initialize(_forwarder, _btc, _factoryRegistry);\n    }\n\n    function name() external pure returns (string memory) {\n        return \"veBTC\";\n    }\n\n    function symbol() external pure returns (string memory) {\n        return \"veBTC\";\n    }\n\n    function version() external pure returns (string memory) {\n        return \"1.0.0\";\n    }\n\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n}\n"
    },
    "contracts/Voter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IVotingRewardsFactory} from \"./interfaces/factories/IVotingRewardsFactory.sol\";\nimport {IGauge} from \"./interfaces/IGauge.sol\";\nimport {IGaugeFactory} from \"./interfaces/factories/IGaugeFactory.sol\";\nimport {ISplitter} from \"./interfaces/ISplitter.sol\";\nimport {IPool} from \"./interfaces/IPool.sol\";\nimport {IPoolFactory} from \"./interfaces/factories/IPoolFactory.sol\";\nimport {IReward} from \"./interfaces/IReward.sol\";\nimport {IVoter} from \"./interfaces/IVoter.sol\";\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\nimport {IFactoryRegistry} from \"./interfaces/factories/IFactoryRegistry.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC2771Context} from \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {ProtocolTimeLibrary} from \"./libraries/ProtocolTimeLibrary.sol\";\n\n/// @title Protocol Voter\n/// @author velodrome.finance, @figs999, @pegahcarter\n/// @notice Manage votes, emission distribution, and gauge creation within the Protocol's ecosystem.\n///         Also provides support for depositing and withdrawing from managed veNFTs.\ncontract Voter is IVoter, ERC2771Context, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    /// @inheritdoc IVoter\n    address public immutable forwarder;\n    /// @inheritdoc IVoter\n    address public immutable ve;\n    /// @inheritdoc IVoter\n    address public immutable factoryRegistry;\n    /// @notice Base token of ve contract\n    address internal immutable rewardToken;\n    /// @notice Rewards are released over 7 days\n    uint256 internal constant DURATION = 7 days;\n    /// @inheritdoc IVoter\n    address public splitter;\n    /// @inheritdoc IVoter\n    address public governor;\n    /// @inheritdoc IVoter\n    address public epochGovernor;\n    /// @inheritdoc IVoter\n    address public emergencyCouncil;\n\n    /// @inheritdoc IVoter\n    uint256 public totalWeight;\n    /// @inheritdoc IVoter\n    uint256 public maxVotingNum;\n    uint256 internal constant MIN_MAXVOTINGNUM = 10;\n\n    /// @dev All pools viable for incentives\n    address[] public pools;\n    /// @inheritdoc IVoter\n    mapping(address => address) public gauges;\n    /// @inheritdoc IVoter\n    mapping(address => address) public poolForGauge;\n    /// @inheritdoc IVoter\n    mapping(address => address) public gaugeToFees;\n    /// @inheritdoc IVoter\n    mapping(address => address) public gaugeToBribe;\n    /// @inheritdoc IVoter\n    mapping(address => uint256) public weights;\n    /// @inheritdoc IVoter\n    mapping(uint256 => mapping(address => uint256)) public votes;\n    /// @dev NFT => List of pools voted for by NFT\n    mapping(uint256 => address[]) public poolVote;\n    /// @inheritdoc IVoter\n    mapping(uint256 => uint256) public usedWeights;\n    /// @inheritdoc IVoter\n    mapping(uint256 => uint256) public lastVoted;\n    /// @inheritdoc IVoter\n    mapping(address => bool) public isGauge;\n    /// @inheritdoc IVoter\n    mapping(address => bool) public isWhitelistedToken;\n    /// @inheritdoc IVoter\n    mapping(uint256 => bool) public isWhitelistedNFT;\n    /// @inheritdoc IVoter\n    mapping(address => bool) public isAlive;\n    /// @dev Accumulated distributions per vote\n    uint256 internal index;\n    /// @dev Gauge => Accumulated gauge distributions\n    mapping(address => uint256) internal supplyIndex;\n    /// @inheritdoc IVoter\n    mapping(address => uint256) public claimable;\n\n    constructor(\n        address _forwarder,\n        address _ve,\n        address _factoryRegistry\n    ) ERC2771Context(_forwarder) {\n        forwarder = _forwarder;\n        ve = _ve;\n        factoryRegistry = _factoryRegistry;\n        rewardToken = IVotingEscrow(_ve).token();\n        address _sender = _msgSender();\n        splitter = _sender;\n        governor = _sender;\n        epochGovernor = _sender;\n        emergencyCouncil = _sender;\n        maxVotingNum = 30;\n    }\n\n    modifier onlyNewEpoch(uint256 _tokenId) {\n        // ensure new epoch since last vote\n        if (\n            ProtocolTimeLibrary.epochStart(block.timestamp) <=\n            lastVoted[_tokenId]\n        ) revert AlreadyVotedOrDeposited();\n        if (\n            block.timestamp <=\n            ProtocolTimeLibrary.epochVoteStart(block.timestamp)\n        ) revert DistributeWindow();\n        _;\n    }\n\n    function epochStart(uint256 _timestamp) external pure returns (uint256) {\n        return ProtocolTimeLibrary.epochStart(_timestamp);\n    }\n\n    function epochNext(uint256 _timestamp) external pure returns (uint256) {\n        return ProtocolTimeLibrary.epochNext(_timestamp);\n    }\n\n    function epochVoteStart(\n        uint256 _timestamp\n    ) external pure returns (uint256) {\n        return ProtocolTimeLibrary.epochVoteStart(_timestamp);\n    }\n\n    function epochVoteEnd(uint256 _timestamp) external pure returns (uint256) {\n        return ProtocolTimeLibrary.epochVoteEnd(_timestamp);\n    }\n\n    /// @dev requires initialization with at least rewardToken\n    function initialize(\n        address[] calldata _tokens,\n        address _splitter\n    ) external {\n        if (_msgSender() != splitter) revert NotSplitter();\n        uint256 _length = _tokens.length;\n        for (uint256 i = 0; i < _length; i++) {\n            _whitelistToken(_tokens[i], true);\n        }\n        splitter = _splitter;\n    }\n\n    /// @inheritdoc IVoter\n    function setGovernor(address _governor) public {\n        if (_msgSender() != governor) revert NotGovernor();\n        if (_governor == address(0)) revert ZeroAddress();\n        governor = _governor;\n    }\n\n    /// @inheritdoc IVoter\n    function setEpochGovernor(address _epochGovernor) public {\n        if (_msgSender() != governor) revert NotGovernor();\n        if (_epochGovernor == address(0)) revert ZeroAddress();\n        epochGovernor = _epochGovernor;\n    }\n\n    /// @inheritdoc IVoter\n    function setEmergencyCouncil(address _council) public {\n        if (_msgSender() != emergencyCouncil) revert NotEmergencyCouncil();\n        if (_council == address(0)) revert ZeroAddress();\n        emergencyCouncil = _council;\n    }\n\n    /// @inheritdoc IVoter\n    function setMaxVotingNum(uint256 _maxVotingNum) external {\n        if (_msgSender() != governor) revert NotGovernor();\n        if (_maxVotingNum < MIN_MAXVOTINGNUM)\n            revert MaximumVotingNumberTooLow();\n        if (_maxVotingNum == maxVotingNum) revert SameValue();\n        maxVotingNum = _maxVotingNum;\n    }\n\n    /// @inheritdoc IVoter\n    function reset(\n        uint256 _tokenId\n    ) external onlyNewEpoch(_tokenId) nonReentrant {\n        if (!IVotingEscrow(ve).isApprovedOrOwner(msg.sender, _tokenId))\n            revert NotApprovedOrOwner();\n        _reset(_tokenId);\n    }\n\n    function _reset(uint256 _tokenId) internal {\n        address[] storage _poolVote = poolVote[_tokenId];\n        uint256 _poolVoteCnt = _poolVote.length;\n        uint256 _totalWeight = 0;\n\n        for (uint256 i = 0; i < _poolVoteCnt; i++) {\n            address _pool = _poolVote[i];\n            uint256 _votes = votes[_tokenId][_pool];\n\n            if (_votes != 0) {\n                _updateFor(gauges[_pool]);\n                weights[_pool] -= _votes;\n                delete votes[_tokenId][_pool];\n                IReward(gaugeToFees[gauges[_pool]])._withdraw(_votes, _tokenId);\n                IReward(gaugeToBribe[gauges[_pool]])._withdraw(\n                    _votes,\n                    _tokenId\n                );\n                _totalWeight += _votes;\n                emit Abstained(\n                    _msgSender(),\n                    _pool,\n                    _tokenId,\n                    _votes,\n                    weights[_pool],\n                    block.timestamp\n                );\n            }\n        }\n        IVotingEscrow(ve).voting(_tokenId, false);\n        totalWeight -= _totalWeight;\n        usedWeights[_tokenId] = 0;\n        delete poolVote[_tokenId];\n    }\n\n    /// @inheritdoc IVoter\n    function poke(uint256 _tokenId) external nonReentrant {\n        if (\n            block.timestamp <=\n            ProtocolTimeLibrary.epochVoteStart(block.timestamp)\n        ) revert DistributeWindow();\n        uint256 _weight = IVotingEscrow(ve).balanceOfNFT(_tokenId);\n        _poke(_tokenId, _weight);\n    }\n\n    function _poke(uint256 _tokenId, uint256 _weight) internal {\n        address[] memory _poolVote = poolVote[_tokenId];\n        uint256 _poolCnt = _poolVote.length;\n        uint256[] memory _weights = new uint256[](_poolCnt);\n\n        for (uint256 i = 0; i < _poolCnt; i++) {\n            _weights[i] = votes[_tokenId][_poolVote[i]];\n        }\n        _vote(_tokenId, _weight, _poolVote, _weights);\n    }\n\n    function _vote(\n        uint256 _tokenId,\n        uint256 _weight,\n        address[] memory _poolVote,\n        uint256[] memory _weights\n    ) internal {\n        _reset(_tokenId);\n        uint256 _poolCnt = _poolVote.length;\n        uint256 _totalVoteWeight = 0;\n        uint256 _totalWeight = 0;\n        uint256 _usedWeight = 0;\n\n        for (uint256 i = 0; i < _poolCnt; i++) {\n            _totalVoteWeight += _weights[i];\n        }\n\n        for (uint256 i = 0; i < _poolCnt; i++) {\n            address _pool = _poolVote[i];\n            address _gauge = gauges[_pool];\n            if (_gauge == address(0)) revert GaugeDoesNotExist(_pool);\n            if (!isAlive[_gauge]) revert GaugeNotAlive(_gauge);\n\n            if (isGauge[_gauge]) {\n                uint256 _poolWeight = (_weights[i] * _weight) /\n                    _totalVoteWeight;\n                if (votes[_tokenId][_pool] != 0) revert NonZeroVotes();\n                if (_poolWeight == 0) revert ZeroBalance();\n                _updateFor(_gauge);\n\n                poolVote[_tokenId].push(_pool);\n\n                weights[_pool] += _poolWeight;\n                votes[_tokenId][_pool] += _poolWeight;\n                IReward(gaugeToFees[_gauge])._deposit(_poolWeight, _tokenId);\n                IReward(gaugeToBribe[_gauge])._deposit(_poolWeight, _tokenId);\n                _usedWeight += _poolWeight;\n                _totalWeight += _poolWeight;\n                emit Voted(\n                    _msgSender(),\n                    _pool,\n                    _tokenId,\n                    _poolWeight,\n                    weights[_pool],\n                    block.timestamp\n                );\n            }\n        }\n        if (_usedWeight > 0) IVotingEscrow(ve).voting(_tokenId, true);\n        totalWeight += _totalWeight;\n        usedWeights[_tokenId] = _usedWeight;\n    }\n\n    /// @inheritdoc IVoter\n    function vote(\n        uint256 _tokenId,\n        address[] calldata _poolVote,\n        uint256[] calldata _weights\n    ) external onlyNewEpoch(_tokenId) nonReentrant {\n        address _sender = _msgSender();\n        if (!IVotingEscrow(ve).isApprovedOrOwner(_sender, _tokenId))\n            revert NotApprovedOrOwner();\n        if (_poolVote.length != _weights.length) revert UnequalLengths();\n        if (_poolVote.length > maxVotingNum) revert TooManyPools();\n        if (IVotingEscrow(ve).deactivated(_tokenId))\n            revert InactiveManagedNFT();\n        uint256 _timestamp = block.timestamp;\n        if (\n            (_timestamp > ProtocolTimeLibrary.epochVoteEnd(_timestamp)) &&\n            !isWhitelistedNFT[_tokenId]\n        ) revert NotWhitelistedNFT();\n        lastVoted[_tokenId] = _timestamp;\n        uint256 _weight = IVotingEscrow(ve).balanceOfNFT(_tokenId);\n        _vote(_tokenId, _weight, _poolVote, _weights);\n    }\n\n    /// @inheritdoc IVoter\n    function depositManaged(\n        uint256 _tokenId,\n        uint256 _mTokenId\n    ) external nonReentrant onlyNewEpoch(_tokenId) {\n        address _sender = _msgSender();\n        if (!IVotingEscrow(ve).isApprovedOrOwner(_sender, _tokenId))\n            revert NotApprovedOrOwner();\n        if (IVotingEscrow(ve).deactivated(_mTokenId))\n            revert InactiveManagedNFT();\n        uint256 _timestamp = block.timestamp;\n        if (_timestamp > ProtocolTimeLibrary.epochVoteEnd(_timestamp))\n            revert SpecialVotingWindow();\n        lastVoted[_tokenId] = _timestamp;\n        IVotingEscrow(ve).depositManaged(_tokenId, _mTokenId);\n        uint256 _weight = IVotingEscrow(ve).balanceOfNFTAt(\n            _mTokenId,\n            block.timestamp\n        );\n        _poke(_mTokenId, _weight);\n    }\n\n    /// @inheritdoc IVoter\n    function withdrawManaged(\n        uint256 _tokenId\n    ) external nonReentrant onlyNewEpoch(_tokenId) {\n        if (!IVotingEscrow(ve).isApprovedOrOwner(_msgSender(), _tokenId))\n            revert NotApprovedOrOwner();\n        uint256 _mTokenId = IVotingEscrow(ve).idToManaged(_tokenId);\n        IVotingEscrow(ve).withdrawManaged(_tokenId);\n        // If the NORMAL veNFT was the last tokenId locked into _mTokenId, reset vote as there is\n        // no longer voting power available to the _mTokenId.  Otherwise, updating voting power to accurately\n        // reflect the withdrawn voting power.\n        uint256 _weight = IVotingEscrow(ve).balanceOfNFTAt(\n            _mTokenId,\n            block.timestamp\n        );\n        if (_weight == 0) {\n            _reset(_mTokenId);\n            // clear out lastVoted to allow re-voting in the current epoch\n            delete lastVoted[_mTokenId];\n        } else {\n            _poke(_mTokenId, _weight);\n        }\n    }\n\n    /// @inheritdoc IVoter\n    function whitelistToken(address _token, bool _bool) external {\n        if (_msgSender() != governor) revert NotGovernor();\n        _whitelistToken(_token, _bool);\n    }\n\n    function _whitelistToken(address _token, bool _bool) internal {\n        isWhitelistedToken[_token] = _bool;\n        emit WhitelistToken(_msgSender(), _token, _bool);\n    }\n\n    /// @inheritdoc IVoter\n    function whitelistNFT(uint256 _tokenId, bool _bool) external {\n        address _sender = _msgSender();\n        if (_sender != governor) revert NotGovernor();\n        isWhitelistedNFT[_tokenId] = _bool;\n        emit WhitelistNFT(_sender, _tokenId, _bool);\n    }\n\n    /// @inheritdoc IVoter\n    function createGauge(\n        address _poolFactory,\n        address _pool\n    ) external nonReentrant returns (address) {\n        address sender = _msgSender();\n        if (\n            !IFactoryRegistry(factoryRegistry).isPoolFactoryApproved(\n                _poolFactory\n            )\n        ) revert FactoryPathNotApproved();\n        if (gauges[_pool] != address(0)) revert GaugeExists();\n\n        (address votingRewardsFactory, address gaugeFactory) = IFactoryRegistry(\n            factoryRegistry\n        ).factoriesToPoolFactory(_poolFactory);\n        address[] memory rewards = new address[](2);\n        bool isPool = IPoolFactory(_poolFactory).isPool(_pool);\n        {\n            // stack too deep\n            address token0;\n            address token1;\n            if (isPool) {\n                token0 = IPool(_pool).token0();\n                token1 = IPool(_pool).token1();\n                rewards[0] = token0;\n                rewards[1] = token1;\n            }\n\n            if (sender != governor) {\n                if (!isPool) revert NotAPool();\n                if (!isWhitelistedToken[token0] || !isWhitelistedToken[token1])\n                    revert NotWhitelistedToken();\n            }\n        }\n\n        (\n            address _feeVotingReward,\n            address _bribeVotingReward\n        ) = IVotingRewardsFactory(votingRewardsFactory).createRewards(\n                forwarder,\n                rewards\n            );\n\n        address _gauge = IGaugeFactory(gaugeFactory).createGauge(\n            forwarder,\n            _pool,\n            _feeVotingReward,\n            rewardToken,\n            isPool\n        );\n\n        gaugeToFees[_gauge] = _feeVotingReward;\n        gaugeToBribe[_gauge] = _bribeVotingReward;\n        gauges[_pool] = _gauge;\n        poolForGauge[_gauge] = _pool;\n        isGauge[_gauge] = true;\n        isAlive[_gauge] = true;\n        _updateFor(_gauge);\n        pools.push(_pool);\n\n        emit GaugeCreated(\n            _poolFactory,\n            votingRewardsFactory,\n            gaugeFactory,\n            _pool,\n            _bribeVotingReward,\n            _feeVotingReward,\n            _gauge,\n            sender\n        );\n        return _gauge;\n    }\n\n    /// @inheritdoc IVoter\n    function killGauge(address _gauge) external {\n        if (_msgSender() != emergencyCouncil) revert NotEmergencyCouncil();\n        if (!isAlive[_gauge]) revert GaugeAlreadyKilled();\n        // Return claimable back to splitter\n        uint256 _claimable = claimable[_gauge];\n        if (_claimable > 0) {\n            IERC20(rewardToken).safeTransfer(splitter, _claimable);\n            delete claimable[_gauge];\n        }\n        isAlive[_gauge] = false;\n        emit GaugeKilled(_gauge);\n    }\n\n    /// @inheritdoc IVoter\n    function reviveGauge(address _gauge) external {\n        if (_msgSender() != emergencyCouncil) revert NotEmergencyCouncil();\n        if (isAlive[_gauge]) revert GaugeAlreadyRevived();\n        isAlive[_gauge] = true;\n        emit GaugeRevived(_gauge);\n    }\n\n    /// @inheritdoc IVoter\n    function length() external view returns (uint256) {\n        return pools.length;\n    }\n\n    /// @inheritdoc IVoter\n    function notifyRewardAmount(uint256 _amount) external {\n        address sender = _msgSender();\n        if (sender != splitter) revert NotSplitter();\n        IERC20(rewardToken).safeTransferFrom(sender, address(this), _amount); // transfer the distribution in\n        uint256 _ratio = (_amount * 1e18) / Math.max(totalWeight, 1); // 1e18 adjustment is removed during claim\n        if (_ratio > 0) {\n            index += _ratio;\n        }\n        emit NotifyReward(sender, rewardToken, _amount);\n    }\n\n    /// @inheritdoc IVoter\n    function updateFor(address[] memory _gauges) external {\n        uint256 _length = _gauges.length;\n        for (uint256 i = 0; i < _length; i++) {\n            _updateFor(_gauges[i]);\n        }\n    }\n\n    /// @inheritdoc IVoter\n    function updateFor(uint256 start, uint256 end) external {\n        for (uint256 i = start; i < end; i++) {\n            _updateFor(gauges[pools[i]]);\n        }\n    }\n\n    /// @inheritdoc IVoter\n    function updateFor(address _gauge) external {\n        _updateFor(_gauge);\n    }\n\n    function _updateFor(address _gauge) internal {\n        address _pool = poolForGauge[_gauge];\n        uint256 _supplied = weights[_pool];\n        if (_supplied > 0) {\n            uint256 _supplyIndex = supplyIndex[_gauge];\n            uint256 _index = index; // get global index0 for accumulated distribution\n            supplyIndex[_gauge] = _index; // update _gauge current position to global position\n            uint256 _delta = _index - _supplyIndex; // see if there is any difference that need to be accrued\n            if (_delta > 0) {\n                uint256 _share = (_supplied * _delta) / 1e18; // add accrued difference for each supplied token\n                if (isAlive[_gauge]) {\n                    claimable[_gauge] += _share;\n                } else {\n                    IERC20(rewardToken).safeTransfer(splitter, _share); // send rewards back to Splitter so they're not stuck in Voter\n                }\n            }\n        } else {\n            supplyIndex[_gauge] = index; // new users are set to the default global state\n        }\n    }\n\n    /// @inheritdoc IVoter\n    function claimRewards(address[] memory _gauges) external {\n        uint256 _length = _gauges.length;\n        for (uint256 i = 0; i < _length; i++) {\n            IGauge(_gauges[i]).getReward(_msgSender());\n        }\n    }\n\n    /// @inheritdoc IVoter\n    function claimBribes(\n        address[] memory _bribes,\n        address[][] memory _tokens,\n        uint256 _tokenId\n    ) external {\n        if (!IVotingEscrow(ve).isApprovedOrOwner(_msgSender(), _tokenId))\n            revert NotApprovedOrOwner();\n        uint256 _length = _bribes.length;\n        for (uint256 i = 0; i < _length; i++) {\n            IReward(_bribes[i]).getReward(_tokenId, _tokens[i]);\n        }\n    }\n\n    /// @inheritdoc IVoter\n    function claimFees(\n        address[] memory _fees,\n        address[][] memory _tokens,\n        uint256 _tokenId\n    ) external {\n        if (!IVotingEscrow(ve).isApprovedOrOwner(_msgSender(), _tokenId))\n            revert NotApprovedOrOwner();\n        uint256 _length = _fees.length;\n        for (uint256 i = 0; i < _length; i++) {\n            IReward(_fees[i]).getReward(_tokenId, _tokens[i]);\n        }\n    }\n\n    function _distribute(address _gauge) internal {\n        _updateFor(_gauge); // should set claimable to 0 if killed\n        uint256 _claimable = claimable[_gauge];\n        if (_claimable > IGauge(_gauge).left() && _claimable > DURATION) {\n            claimable[_gauge] = 0;\n            IERC20(rewardToken).safeApprove(_gauge, _claimable);\n            IGauge(_gauge).notifyRewardAmount(_claimable);\n            IERC20(rewardToken).safeApprove(_gauge, 0);\n            emit DistributeReward(_msgSender(), _gauge, _claimable);\n        }\n    }\n\n    /// @inheritdoc IVoter\n    function distribute(uint256 _start, uint256 _finish) external nonReentrant {\n        ISplitter(splitter).updatePeriod();\n        for (uint256 x = _start; x < _finish; x++) {\n            _distribute(gauges[pools[x]]);\n        }\n    }\n\n    /// @inheritdoc IVoter\n    function distribute(address[] memory _gauges) external nonReentrant {\n        ISplitter(splitter).updatePeriod();\n        uint256 _length = _gauges.length;\n        for (uint256 x = 0; x < _length; x++) {\n            _distribute(_gauges[x]);\n        }\n    }\n}\n"
    },
    "contracts/VotingEscrow.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.24;\n\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {VotingEscrowState} from \"./ve/VotingEscrowState.sol\";\nimport {ManagedNFT} from \"./ve/ManagedNFT.sol\";\nimport {NFT} from \"./ve/NFT.sol\";\nimport {Escrow} from \"./ve/Escrow.sol\";\nimport {Delegation} from \"./ve/Delegation.sol\";\nimport {Balance} from \"./ve/Balance.sol\";\nimport {VeERC2771Context} from \"./ve/VeERC2771Context.sol\";\n\n/// @title Voting Escrow\n/// @notice veNFT implementation that escrows ERC-20 tokens in the form of an ERC-721 NFT\n/// @notice Votes have a weight depending on time, so that users are committed to the future of (whatever they are voting for)\n/// @author Modified from Solidly (https://github.com/solidlyexchange/solidly/blob/master/contracts/ve.sol)\n/// @author Modified from Curve (https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy)\n/// @author velodrome.finance, @figs999, @pegahcarter\n/// @dev Vote weight decays linearly over time. Lock time cannot be more than `MAXTIME` (4 years).\nabstract contract VotingEscrow is\n    IVotingEscrow,\n    Initializable,\n    ReentrancyGuardUpgradeable\n{\n    using VotingEscrowState for VotingEscrowState.Storage;\n    using NFT for VotingEscrowState.Storage;\n    using ManagedNFT for VotingEscrowState.Storage;\n    using Escrow for VotingEscrowState.Storage;\n    using Delegation for VotingEscrowState.Storage;\n    using Balance for VotingEscrowState.Storage;\n    using VeERC2771Context for VotingEscrowState.Storage;\n\n    VotingEscrowState.Storage internal self;\n\n    /// @dev ERC165 interface ID of ERC165\n    bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\n\n    /// @dev ERC165 interface ID of ERC721\n    bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\n\n    /// @dev ERC165 interface ID of ERC721Metadata\n    bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n    /// @dev ERC165 interface ID of ERC4906\n    bytes4 internal constant ERC4906_INTERFACE_ID = 0x49064906;\n\n    /// @dev ERC165 interface ID of ERC6372\n    bytes4 internal constant ERC6372_INTERFACE_ID = 0xda287a1d;\n\n    /// @param _trustedForwarder address of trusted forwarder\n    /// @param _token token address\n    /// @param _factoryRegistry Factory Registry address\n    function __VotingEscrow_initialize(\n        address _trustedForwarder,\n        address _token,\n        address _factoryRegistry\n    ) internal {\n        __ReentrancyGuard_init();\n\n        self.trustedForwarder = _trustedForwarder;\n        self.token = _token;\n        self.factoryRegistry = _factoryRegistry;\n        self.team = self._msgSender();\n        self.voter = self._msgSender();\n\n        self._pointHistory[0].blk = block.number;\n        self._pointHistory[0].ts = block.timestamp;\n\n        self.supportedInterfaces[ERC165_INTERFACE_ID] = true;\n        self.supportedInterfaces[ERC721_INTERFACE_ID] = true;\n        self.supportedInterfaces[ERC721_METADATA_INTERFACE_ID] = true;\n        self.supportedInterfaces[ERC4906_INTERFACE_ID] = true;\n        self.supportedInterfaces[ERC6372_INTERFACE_ID] = true;\n\n        // mint-ish\n        emit Transfer(address(0), address(this), self.tokenId);\n        // burn-ish\n        emit Transfer(address(this), address(0), self.tokenId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MANAGED NFT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVotingEscrow\n    function createManagedLockFor(\n        address _to\n    ) external nonReentrant returns (uint256 _mTokenId) {\n        return self.createManagedLockFor(_to);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function depositManaged(\n        uint256 _tokenId,\n        uint256 _mTokenId\n    ) external nonReentrant {\n        self.depositManaged(_tokenId, _mTokenId);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function withdrawManaged(uint256 _tokenId) external nonReentrant {\n        self.withdrawManaged(_tokenId);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function setAllowedManager(address _allowedManager) external {\n        self.setAllowedManager(_allowedManager);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function setManagedState(uint256 _mTokenId, bool _state) external {\n        self.setManagedState(_mTokenId, _state);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    function setTeam(address _team) external {\n        self.setTeam(_team);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function tokenURI(uint256) external pure returns (string memory) {\n        return \"\";\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function ownerOf(uint256 _tokenId) external view returns (address) {\n        return self._ownerOf(_tokenId);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function balanceOf(address _owner) external view returns (uint256) {\n        return self.ownerToNFTokenCount[_owner];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function getApproved(uint256 _tokenId) external view returns (address) {\n        return self.idToApprovals[_tokenId];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function isApprovedForAll(\n        address _owner,\n        address _operator\n    ) external view returns (bool) {\n        return (self.ownerToOperators[_owner])[_operator];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function isApprovedOrOwner(\n        address _spender,\n        uint256 _tokenId\n    ) external view returns (bool) {\n        return self._isApprovedOrOwner(_spender, _tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVotingEscrow\n    function approve(address _approved, uint256 _tokenId) external {\n        self.approve(_approved, _tokenId);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function setApprovalForAll(address _operator, bool _approved) external {\n        self.setApprovalForAll(_operator, _approved);\n    }\n\n    /* TRANSFER FUNCTIONS */\n\n    /// @inheritdoc IVotingEscrow\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external {\n        self._transferFrom(_from, _to, _tokenId, self._msgSender());\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external {\n        safeTransferFrom(_from, _to, _tokenId, \"\");\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory _data\n    ) public {\n        self.safeTransferFrom(_from, _to, _tokenId, _data);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVotingEscrow\n    function supportsInterface(\n        bytes4 _interfaceID\n    ) external view returns (bool) {\n        return self.supportedInterfaces[_interfaceID];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function locked(\n        uint256 _tokenId\n    ) external view returns (LockedBalance memory) {\n        return self._locked[_tokenId];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function userPointHistory(\n        uint256 _tokenId,\n        uint256 _loc\n    ) external view returns (UserPoint memory) {\n        return self._userPointHistory[_tokenId][_loc];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function pointHistory(\n        uint256 _loc\n    ) external view returns (GlobalPoint memory) {\n        return self._pointHistory[_loc];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ESCROW LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVotingEscrow\n    function checkpoint() external nonReentrant {\n        self._checkpoint(\n            0,\n            LockedBalance(0, 0, false),\n            LockedBalance(0, 0, false)\n        );\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function depositFor(\n        uint256 _tokenId,\n        uint256 _value\n    ) external nonReentrant {\n        self.depositFor(_tokenId, _value);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function createLock(\n        uint256 _value,\n        uint256 _lockDuration\n    ) external nonReentrant returns (uint256) {\n        return self._createLock(_value, _lockDuration, self._msgSender());\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function createLockFor(\n        uint256 _value,\n        uint256 _lockDuration,\n        address _to\n    ) external nonReentrant returns (uint256) {\n        return self._createLock(_value, _lockDuration, _to);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function increaseAmount(\n        uint256 _tokenId,\n        uint256 _value\n    ) external nonReentrant {\n        self.increaseAmount(_tokenId, _value);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function increaseUnlockTime(\n        uint256 _tokenId,\n        uint256 _lockDuration\n    ) external nonReentrant {\n        self.increaseUnlockTime(_tokenId, _lockDuration);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function withdraw(uint256 _tokenId) external nonReentrant {\n        self.withdraw(_tokenId);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function merge(uint256 _from, uint256 _to) external nonReentrant {\n        self.merge(_from, _to);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function split(\n        uint256 _from,\n        uint256 _amount\n    ) external nonReentrant returns (uint256 _tokenId1, uint256 _tokenId2) {\n        return self.split(_from, _amount);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function toggleSplit(address _account, bool _bool) external {\n        self.toggleSplit(_account, _bool);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function lockPermanent(uint256 _tokenId) external {\n        self.lockPermanent(_tokenId);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function unlockPermanent(uint256 _tokenId) external {\n        self.unlockPermanent(_tokenId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           GAUGE VOTING STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVotingEscrow\n    function balanceOfNFT(uint256 _tokenId) public view returns (uint256) {\n        return self._balanceOfNFT(_tokenId);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function balanceOfNFTAt(\n        uint256 _tokenId,\n        uint256 _t\n    ) external view returns (uint256) {\n        return self._balanceOfNFTAt(_tokenId, _t);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function totalSupply() external view returns (uint256) {\n        return self.supplyAt(block.timestamp);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function totalSupplyAt(uint256 _timestamp) external view returns (uint256) {\n        return self.supplyAt(_timestamp);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE VOTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVotingEscrow\n    function setVoterAndDistributor(\n        address _voter,\n        address _distributor\n    ) external {\n        self.setVoterAndDistributor(_voter, _distributor);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function voting(uint256 _tokenId, bool _voted) external {\n        self.setVoting(_tokenId, _voted);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function delegates(uint256 delegator) external view returns (uint256) {\n        return self._delegates[delegator];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function checkpoints(\n        uint256 _tokenId,\n        uint48 _index\n    ) external view returns (Checkpoint memory) {\n        return self._checkpoints[_tokenId][_index];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function getPastVotes(\n        address _account,\n        uint256 _tokenId,\n        uint256 _timestamp\n    ) external view returns (uint256) {\n        return self.getPastVotes(_account, _tokenId, _timestamp);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function getPastTotalSupply(\n        uint256 _timestamp\n    ) external view returns (uint256) {\n        return self.supplyAt(_timestamp);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             DAO VOTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVotingEscrow\n    function delegate(uint256 delegator, uint256 delegatee) external {\n        return self.delegate(delegator, delegatee);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function delegateBySig(\n        uint256 delegator,\n        uint256 delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        return\n            self.delegateBySig(\n                Delegation.SignatureData({\n                    delegator: delegator,\n                    delegatee: delegatee,\n                    nonce: nonce,\n                    expiry: expiry,\n                    v: v,\n                    r: r,\n                    s: s\n                }),\n                this.name(),\n                this.version()\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC6372 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVotingEscrow\n    function clock() external view returns (uint48) {\n        return uint48(block.timestamp);\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function CLOCK_MODE() external pure returns (string memory) {\n        return \"mode=timestamp\";\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVotingEscrow\n    function allowedManager() external view returns (address) {\n        return self.allowedManager;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function canSplit(address _account) external view returns (bool) {\n        return self.canSplit[_account];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function deactivated(\n        uint256 _tokenId\n    ) external view returns (bool inactive) {\n        return self.deactivated[_tokenId];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function distributor() external view returns (address) {\n        return self.distributor;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function epoch() external view returns (uint256) {\n        return self.epoch;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function escrowType(uint256 _tokenId) external view returns (EscrowType) {\n        return self.escrowType[_tokenId];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function factoryRegistry() external view returns (address) {\n        return self.factoryRegistry;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function forwarder() external view returns (address) {\n        return self.trustedForwarder;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function idToManaged(uint256 _tokenId) external view returns (uint256) {\n        return self.idToManaged[_tokenId];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function managedToFree(uint256 _tokenId) external view returns (address) {\n        return self.managedToFree[_tokenId];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function managedToLocked(uint256 _tokenId) external view returns (address) {\n        return self.managedToLocked[_tokenId];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function nonces(address _account) external view returns (uint256) {\n        return self.nonces[_account];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function numCheckpoints(uint256 _tokenId) external view returns (uint48) {\n        return self.numCheckpoints[_tokenId];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function ownerToNFTokenIdList(\n        address _owner,\n        uint256 _index\n    ) external view returns (uint256) {\n        return self.ownerToNFTokenIdList[_owner][_index];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function permanentLockBalance() external view returns (uint256) {\n        return self.permanentLockBalance;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function slopeChanges(uint256 _timestamp) external view returns (int128) {\n        return self.slopeChanges[_timestamp];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function supply() external view returns (uint256) {\n        return self.supply;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function team() external view returns (address) {\n        return self.team;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function token() external view returns (address) {\n        return self.token;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function tokenId() external view returns (uint256) {\n        return self.tokenId;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function userPointEpoch(uint256 _tokenId) external view returns (uint256) {\n        return self.userPointEpoch[_tokenId];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function voted(uint256 _tokenId) external view returns (bool) {\n        return self.voted[_tokenId];\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function voter() external view returns (address) {\n        return self.voter;\n    }\n\n    /// @inheritdoc IVotingEscrow\n    function weights(\n        uint256 _tokenId,\n        uint256 _managedTokenId\n    ) external view returns (uint256) {\n        return self.weights[_tokenId][_managedTokenId];\n    }\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    function DOMAIN_TYPEHASH() external pure returns (bytes32) {\n        return Delegation.DOMAIN_TYPEHASH;\n    }\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    function DELEGATION_TYPEHASH() external pure returns (bytes32) {\n        return Delegation.DELEGATION_TYPEHASH;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "evmVersion": "london",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}