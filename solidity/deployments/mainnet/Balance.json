{
  "address": "0xb23b28616Adefb4EeB6F662E9FeD99B8d0b3d256",
  "abi": [
    {
      "inputs": [],
      "name": "SafeCastOverflow",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SafeCastUnderflow",
      "type": "error"
    }
  ],
  "transactionHash": "0xafc7bf1ebe9a0f6b44f0240a10af6b9cfb28275bb9b4168580a9fb98f7baf70a",
  "receipt": {
    "to": null,
    "from": "0x123694886DBf5Ac94DDA07135349534536D14cAf",
    "contractAddress": "0xb23b28616Adefb4EeB6F662E9FeD99B8d0b3d256",
    "transactionIndex": 0,
    "gasUsed": "438501",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x9425e0356e94aac19f09e27565f7aa7062dc65653816ae45d2cb037674dbc680",
    "transactionHash": "0xafc7bf1ebe9a0f6b44f0240a10af6b9cfb28275bb9b4168580a9fb98f7baf70a",
    "logs": [],
    "blockNumber": 2234474,
    "cumulativeGasUsed": "438501",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "8fa39d1f75a81de120cc40b3f4adb866",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"SafeCastOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeCastUnderflow\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"supplyAt(VotingEscrowState.Storage storage,uint256)\":{\"params\":{\"_t\":\"Time to calculate the total voting power at\"},\"returns\":{\"_0\":\"Total voting power at that time\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"supplyAt(VotingEscrowState.Storage storage,uint256)\":{\"notice\":\"Calculate total voting power at some point in the past\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ve/Balance.sol\":\"Balance\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\",\"keccak256\":\"0xd04b0f06e0666f29cf7cccc82894de541e19bb30a765b107b1e40bb7fe5f7d7a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC4906.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4906.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\n\\n/// @title EIP-721 Metadata Update Extension\\ninterface IERC4906 is IERC165, IERC721 {\\n    /// @dev This event emits when the metadata of a token is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFT.\\n    event MetadataUpdate(uint256 _tokenId);\\n\\n    /// @dev This event emits when the metadata of a range of tokens is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFTs.\\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\\n}\\n\",\"keccak256\":\"0x2a9dadb806be80dd451821f1f1190eb9aa6f6edae85b185db29d60767cc0c5f4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC6372.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC6372 {\\n    /**\\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\\n     */\\n    function clock() external view returns (uint48);\\n\\n    /**\\n     * @dev Description of the clock\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function CLOCK_MODE() external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xcaea9aeda3816ba872358c828f4f01455c22ae48ced49c4c7d72bd74176c09b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721.sol\\\";\\n\",\"keccak256\":\"0xaf297d12d8d4a57fe01a70f0ef38908f208e3faedc577056d0b728fa2f3ccf0c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/governance/IVotes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\n/// Modified IVotes interface for tokenId based voting\\ninterface IVotes {\\n    /**\\n     * @dev Emitted when an account changes their delegate.\\n     */\\n    event DelegateChanged(\\n        address indexed delegator,\\n        uint256 indexed fromDelegate,\\n        uint256 indexed toDelegate\\n    );\\n\\n    /**\\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\\n     */\\n    event DelegateVotesChanged(\\n        address indexed delegate,\\n        uint256 previousBalance,\\n        uint256 newBalance\\n    );\\n\\n    /**\\n     * @dev Returns the amount of votes that `tokenId` had at a specific moment in the past.\\n     *      If the account passed in is not the owner, returns 0.\\n     */\\n    function getPastVotes(\\n        address account,\\n        uint256 tokenId,\\n        uint256 timepoint\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\\n     * configured to use block numbers, this will return the value the end of the corresponding block.\\n     *\\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\\n     * vote.\\n     */\\n    function getPastTotalSupply(\\n        uint256 timepoint\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the delegate that `tokenId` has chosen. Can never be equal to the delegator's `tokenId`.\\n     *      Returns 0 if not delegated.\\n     */\\n    function delegates(uint256 tokenId) external view returns (uint256);\\n\\n    /**\\n     * @dev Delegates votes from the sender to `delegatee`.\\n     */\\n    function delegate(uint256 delegator, uint256 delegatee) external;\\n\\n    /**\\n     * @dev Delegates votes from `delegator` to `delegatee`. Signer must own `delegator`.\\n     */\\n    function delegateBySig(\\n        uint256 delegator,\\n        uint256 delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\",\"keccak256\":\"0x9d443ede6b412305137804890806312f30351178fd3781b3a9417bfd3eea558c\",\"license\":\"MIT\"},\"contracts/interfaces/IVotingEscrow.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\nimport {IERC165, IERC721, IERC721Metadata} from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\nimport {IERC6372} from \\\"@openzeppelin/contracts/interfaces/IERC6372.sol\\\";\\nimport {IERC4906} from \\\"@openzeppelin/contracts/interfaces/IERC4906.sol\\\";\\nimport {IVotes} from \\\"../governance/IVotes.sol\\\";\\n\\ninterface IVotingEscrow is IVotes, IERC4906, IERC6372, IERC721Metadata {\\n    struct LockedBalance {\\n        int128 amount;\\n        uint256 end;\\n        bool isPermanent;\\n    }\\n\\n    struct UserPoint {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint256 ts;\\n        uint256 blk; // block\\n        uint256 permanent;\\n    }\\n\\n    struct GlobalPoint {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint256 ts;\\n        uint256 blk; // block\\n        uint256 permanentLockBalance;\\n    }\\n\\n    /// @notice A checkpoint for recorded delegated voting weights at a certain timestamp\\n    struct Checkpoint {\\n        uint256 fromTimestamp;\\n        address owner;\\n        uint256 delegatedBalance;\\n        uint256 delegatee;\\n    }\\n\\n    enum DepositType {\\n        DEPOSIT_FOR_TYPE,\\n        CREATE_LOCK_TYPE,\\n        INCREASE_LOCK_AMOUNT,\\n        INCREASE_UNLOCK_TIME\\n    }\\n\\n    /// @dev Different types of veNFTs:\\n    /// NORMAL  - typical veNFT\\n    /// LOCKED  - veNFT which is locked into a MANAGED veNFT\\n    /// MANAGED - veNFT which can accept the deposit of NORMAL veNFTs\\n    enum EscrowType {\\n        NORMAL,\\n        LOCKED,\\n        MANAGED\\n    }\\n\\n    error AlreadyVoted();\\n    error AmountTooBig();\\n    error ERC721ReceiverRejectedTokens();\\n    error ERC721TransferToNonERC721ReceiverImplementer();\\n    error InvalidNonce();\\n    error InvalidSignature();\\n    error InvalidSignatureS();\\n    error InvalidManagedNFTId();\\n    error LockDurationNotInFuture();\\n    error LockDurationTooLong();\\n    error LockExpired();\\n    error LockNotExpired();\\n    error NoLockFound();\\n    error NonExistentToken();\\n    error NotApprovedOrOwner();\\n    error NotDistributor();\\n    error NotEmergencyCouncilOrGovernor();\\n    error NotGovernor();\\n    error NotGovernorOrManager();\\n    error NotManagedNFT();\\n    error NotManagedOrNormalNFT();\\n    error NotLockedNFT();\\n    error NotNormalNFT();\\n    error NotPermanentLock();\\n    error NotOwner();\\n    error NotTeam();\\n    error NotVoter();\\n    error OwnershipChange();\\n    error PermanentLock();\\n    error SameAddress();\\n    error SameNFT();\\n    error SameState();\\n    error SplitNoOwner();\\n    error SplitNotAllowed();\\n    error SignatureExpired();\\n    error TooManyTokenIDs();\\n    error ZeroAddress();\\n    error ZeroAmount();\\n    error ZeroBalance();\\n    error NotGrantManager();\\n    error UnvestedGrantNFT();\\n\\n    event Deposit(\\n        address indexed provider,\\n        uint256 indexed tokenId,\\n        DepositType indexed depositType,\\n        uint256 value,\\n        uint256 locktime,\\n        uint256 ts\\n    );\\n    event Withdraw(\\n        address indexed provider,\\n        uint256 indexed tokenId,\\n        uint256 value,\\n        uint256 ts\\n    );\\n    event LockPermanent(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 amount,\\n        uint256 _ts\\n    );\\n    event UnlockPermanent(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 amount,\\n        uint256 _ts\\n    );\\n    event Supply(uint256 prevSupply, uint256 supply);\\n    event Merge(\\n        address indexed _sender,\\n        uint256 indexed _from,\\n        uint256 indexed _to,\\n        uint256 _amountFrom,\\n        uint256 _amountTo,\\n        uint256 _amountFinal,\\n        uint256 _locktime,\\n        uint256 _ts\\n    );\\n    event Split(\\n        uint256 indexed _from,\\n        uint256 indexed _tokenId1,\\n        uint256 indexed _tokenId2,\\n        address _sender,\\n        uint256 _splitAmount1,\\n        uint256 _splitAmount2,\\n        uint256 _locktime,\\n        uint256 _ts\\n    );\\n    event CreateManaged(\\n        address indexed _to,\\n        uint256 indexed _mTokenId,\\n        address indexed _from,\\n        address _lockedManagedReward,\\n        address _freeManagedReward\\n    );\\n    event DepositManaged(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 indexed _mTokenId,\\n        uint256 _weight,\\n        uint256 _ts\\n    );\\n    event WithdrawManaged(\\n        address indexed _owner,\\n        uint256 indexed _tokenId,\\n        uint256 indexed _mTokenId,\\n        uint256 _weight,\\n        uint256 _ts\\n    );\\n    event SetAllowedManager(address indexed _allowedManager);\\n    event CreateGrant(\\n        uint256 indexed _tokenId,\\n        address _grantee,\\n        address _grantManager,\\n        uint256 _vestingEnd\\n    );\\n    event SetGrantManager(address indexed _grantManager);\\n\\n    // State variables\\n    /// @notice Address of Meta-tx Forwarder\\n    function forwarder() external view returns (address);\\n\\n    /// @notice Address of FactoryRegistry.sol\\n    function factoryRegistry() external view returns (address);\\n\\n    /// @notice Address of token used to create a veNFT\\n    function token() external view returns (address);\\n\\n    /// @notice Address of RewardsDistributor.sol\\n    function distributor() external view returns (address);\\n\\n    /// @notice Address of Voter.sol\\n    function voter() external view returns (address);\\n\\n    /// @notice Address of Protocol Team multisig\\n    function team() external view returns (address);\\n\\n    /// @dev address which can create managed NFTs\\n    function allowedManager() external view returns (address);\\n\\n    /// @dev Current count of token\\n    function tokenId() external view returns (uint256);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            MANAGED NFT STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Mapping of token id to escrow type\\n    ///      Takes advantage of the fact default value is EscrowType.NORMAL\\n    function escrowType(uint256 tokenId) external view returns (EscrowType);\\n\\n    /// @dev Mapping of token id to managed id\\n    function idToManaged(\\n        uint256 tokenId\\n    ) external view returns (uint256 managedTokenId);\\n\\n    /// @dev Mapping of user token id to managed token id to weight of token id\\n    function weights(\\n        uint256 tokenId,\\n        uint256 managedTokenId\\n    ) external view returns (uint256 weight);\\n\\n    /// @dev Mapping of managed id to deactivated state\\n    function deactivated(uint256 tokenId) external view returns (bool inactive);\\n\\n    /// @dev Mapping from managed nft id to locked managed rewards\\n    ///      `token` denominated rewards (rebases/rewards) stored in locked managed rewards contract\\n    ///      to prevent co-mingling of assets\\n    function managedToLocked(uint256 tokenId) external view returns (address);\\n\\n    /// @dev Mapping from managed nft id to free managed rewards contract\\n    ///      these rewards can be freely withdrawn by users\\n    function managedToFree(uint256 tokenId) external view returns (address);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            MANAGED NFT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Create managed NFT (a permanent lock) for use within ecosystem.\\n    /// @dev Throws if address already owns a managed NFT.\\n    /// @return _mTokenId managed token id.\\n    function createManagedLockFor(\\n        address _to\\n    ) external returns (uint256 _mTokenId);\\n\\n    /// @notice Delegates balance to managed nft\\n    ///         Note that NFTs deposited into a managed NFT will be re-locked\\n    ///         to the maximum lock time on withdrawal.\\n    ///         Permanent locks that are deposited will automatically unlock.\\n    /// @dev Managed nft will remain max-locked as long as there is at least one\\n    ///      deposit or withdrawal per week.\\n    ///      Throws if deposit nft is managed.\\n    ///      Throws if recipient nft is not managed.\\n    ///      Throws if deposit nft is already locked.\\n    ///      Throws if not called by voter.\\n    /// @param _tokenId tokenId of NFT being deposited\\n    /// @param _mTokenId tokenId of managed NFT that will receive the deposit\\n    function depositManaged(uint256 _tokenId, uint256 _mTokenId) external;\\n\\n    /// @notice Retrieves locked rewards and withdraws balance from managed nft.\\n    ///         Note that the NFT withdrawn is re-locked to the maximum lock time.\\n    /// @dev Throws if NFT not locked.\\n    ///      Throws if not called by voter.\\n    /// @param _tokenId tokenId of NFT being deposited.\\n    function withdrawManaged(uint256 _tokenId) external;\\n\\n    /// @notice Permit one address to call createManagedLockFor() that is not Voter.governor()\\n    function setAllowedManager(address _allowedManager) external;\\n\\n    /// @notice Set Managed NFT state. Inactive NFTs cannot be deposited into.\\n    /// @param _mTokenId managed nft state to set\\n    /// @param _state true => inactive, false => active\\n    function setManagedState(uint256 _mTokenId, bool _state) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function version() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function setTeam(address _team) external;\\n\\n    /// @inheritdoc IERC721Metadata\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Mapping from owner address to mapping of index to tokenId\\n    function ownerToNFTokenIdList(\\n        address _owner,\\n        uint256 _index\\n    ) external view returns (uint256 _tokenId);\\n\\n    /// @inheritdoc IERC721\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /// @inheritdoc IERC721\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC721\\n    function getApproved(\\n        uint256 _tokenId\\n    ) external view returns (address operator);\\n\\n    /// @inheritdoc IERC721\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n\\n    /// @notice Check whether spender is owner or an approved user for a given veNFT\\n    /// @param _spender .\\n    /// @param _tokenId .\\n    function isApprovedOrOwner(\\n        address _spender,\\n        uint256 _tokenId\\n    ) external returns (bool);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC721\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /// @inheritdoc IERC721\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /// @inheritdoc IERC721\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /// @inheritdoc IERC721\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /// @inheritdoc IERC721\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(\\n        bytes4 _interfaceID\\n    ) external view returns (bool);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ESCROW STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Total count of epochs witnessed since contract creation\\n    function epoch() external view returns (uint256);\\n\\n    /// @notice Total amount of token() deposited\\n    function supply() external view returns (uint256);\\n\\n    /// @notice Aggregate permanent locked balances\\n    function permanentLockBalance() external view returns (uint256);\\n\\n    function userPointEpoch(\\n        uint256 _tokenId\\n    ) external view returns (uint256 _epoch);\\n\\n    /// @notice time -> signed slope change\\n    function slopeChanges(uint256 _timestamp) external view returns (int128);\\n\\n    /// @notice account -> can split\\n    function canSplit(address _account) external view returns (bool);\\n\\n    /// @notice Global point history at a given index\\n    function pointHistory(\\n        uint256 _loc\\n    ) external view returns (GlobalPoint memory);\\n\\n    /// @notice Get the LockedBalance (amount, end) of a _tokenId\\n    /// @param _tokenId .\\n    /// @return LockedBalance of _tokenId\\n    function locked(\\n        uint256 _tokenId\\n    ) external view returns (LockedBalance memory);\\n\\n    /// @notice User -> UserPoint[userEpoch]\\n    function userPointHistory(\\n        uint256 _tokenId,\\n        uint256 _loc\\n    ) external view returns (UserPoint memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ESCROW LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Record global data to checkpoint\\n    function checkpoint() external;\\n\\n    /// @notice Deposit `_value` tokens for `_tokenId` and add to the lock\\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\\n    ///      cannot extend their locktime and deposit for a brand new user\\n    /// @param _tokenId lock NFT\\n    /// @param _value Amount to add to user's lock\\n    function depositFor(uint256 _tokenId, uint256 _value) external;\\n\\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lockDuration`\\n    /// @param _value Amount to deposit\\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\\n    /// @return TokenId of created veNFT\\n    function createLock(\\n        uint256 _value,\\n        uint256 _lockDuration\\n    ) external returns (uint256);\\n\\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lockDuration`\\n    /// @param _value Amount to deposit\\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\\n    /// @param _to Address to deposit\\n    /// @return TokenId of created veNFT\\n    function createLockFor(\\n        uint256 _value,\\n        uint256 _lockDuration,\\n        address _to\\n    ) external returns (uint256);\\n\\n    /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\\n    /// @param _value Amount of tokens to deposit and add to the lock\\n    function increaseAmount(uint256 _tokenId, uint256 _value) external;\\n\\n    /// @notice Extend the unlock time for `_tokenId`\\n    ///         Cannot extend lock time of permanent locks\\n    /// @param _lockDuration New number of seconds until tokens unlock\\n    function increaseUnlockTime(\\n        uint256 _tokenId,\\n        uint256 _lockDuration\\n    ) external;\\n\\n    /// @notice Withdraw all tokens for `_tokenId`\\n    /// @dev Only possible if the lock is both expired and not permanent\\n    ///      This will burn the veNFT. Any rebases or rewards that are unclaimed\\n    ///      will no longer be claimable. Claim all rebases and rewards prior to calling this.\\n    function withdraw(uint256 _tokenId) external;\\n\\n    /// @notice Merges `_from` into `_to`.\\n    /// @dev Cannot merge `_from` locks that are permanent or have already voted this epoch.\\n    ///      Cannot merge `_to` locks that have already expired.\\n    ///      Cannot merge if either `_from` or `_to` is veNFT created for\\n    ///      a grant that has not fully vested yet.\\n    ///      This will burn the veNFT. Any rebases or rewards that are unclaimed\\n    ///      will no longer be claimable. Claim all rebases and rewards prior to calling this.\\n    /// @param _from VeNFT to merge from.\\n    /// @param _to VeNFT to merge into.\\n    function merge(uint256 _from, uint256 _to) external;\\n\\n    /// @notice Splits veNFT into two new veNFTS - one with oldLocked.amount - `_amount`, and the second with `_amount`\\n    /// @dev    This burns the tokenId of the target veNFT\\n    ///         Callable by approved or owner\\n    ///         If this is called by approved, approved will not have permissions to manipulate the newly created veNFTs\\n    ///         Returns the two new split veNFTs to owner\\n    ///         If `from` is permanent, will automatically dedelegate.\\n    ///         This will burn the veNFT. Any rebases or rewards that are unclaimed\\n    ///         will no longer be claimable. Claim all rebases and rewards prior to calling this.\\n    /// @param _from VeNFT to split.\\n    /// @param _amount Amount to split from veNFT.\\n    /// @return _tokenId1 Return tokenId of veNFT with oldLocked.amount - `_amount`.\\n    /// @return _tokenId2 Return tokenId of veNFT with `_amount`.\\n    function split(\\n        uint256 _from,\\n        uint256 _amount\\n    ) external returns (uint256 _tokenId1, uint256 _tokenId2);\\n\\n    /// @notice Toggle split for a specific address.\\n    /// @dev Toggle split for address(0) to enable or disable for all.\\n    /// @param _account Address to toggle split permissions\\n    /// @param _bool True to allow, false to disallow\\n    function toggleSplit(address _account, bool _bool) external;\\n\\n    /// @notice Permanently lock a veNFT. Voting power will be equal to\\n    ///         `LockedBalance.amount` with no decay. Required to delegate.\\n    /// @dev Only callable by unlocked normal veNFTs.\\n    /// @param _tokenId tokenId to lock.\\n    function lockPermanent(uint256 _tokenId) external;\\n\\n    /// @notice Unlock a permanently locked veNFT. Voting power will decay.\\n    ///         Will automatically dedelegate if delegated.\\n    /// @dev Only callable by permanently locked veNFTs.\\n    ///      Cannot unlock if already voted this epoch.\\n    /// @param _tokenId tokenId to unlock.\\n    function unlockPermanent(uint256 _tokenId) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           GAUGE VOTING STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Get the voting power for _tokenId at the current timestamp\\n    /// @dev Returns 0 if called in the same block as a transfer.\\n    /// @param _tokenId .\\n    /// @return Voting power\\n    function balanceOfNFT(uint256 _tokenId) external view returns (uint256);\\n\\n    /// @notice Get the voting power for _tokenId at a given timestamp\\n    /// @param _tokenId .\\n    /// @param _t Timestamp to query voting power\\n    /// @return Voting power\\n    function balanceOfNFTAt(\\n        uint256 _tokenId,\\n        uint256 _t\\n    ) external view returns (uint256);\\n\\n    /// @notice Calculate total voting power at current timestamp\\n    /// @return Total voting power at current timestamp\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Calculate total voting power at a given timestamp\\n    /// @param _t Timestamp to query total voting power\\n    /// @return Total voting power at given timestamp\\n    function totalSupplyAt(uint256 _t) external view returns (uint256);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            GAUGE VOTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice See if a queried _tokenId has actively voted\\n    /// @param _tokenId .\\n    /// @return True if voted, else false\\n    function voted(uint256 _tokenId) external view returns (bool);\\n\\n    /// @notice Set the global state voter and distributor\\n    /// @dev This is only called once, at setup\\n    function setVoterAndDistributor(\\n        address _voter,\\n        address _distributor\\n    ) external;\\n\\n    /// @notice Set `voted` for _tokenId to true or false\\n    /// @dev Only callable by voter\\n    /// @param _tokenId .\\n    /// @param _voted .\\n    function voting(uint256 _tokenId, bool _voted) external;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            DAO VOTING STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The number of checkpoints for each tokenId\\n    function numCheckpoints(uint256 tokenId) external view returns (uint48);\\n\\n    /// @notice A record of states for signing / validating signatures\\n    function nonces(address account) external view returns (uint256);\\n\\n    /// @inheritdoc IVotes\\n    function delegates(uint256 delegator) external view returns (uint256);\\n\\n    /// @notice A record of delegated token checkpoints for each account, by index\\n    /// @param tokenId .\\n    /// @param index .\\n    /// @return Checkpoint\\n    function checkpoints(\\n        uint256 tokenId,\\n        uint48 index\\n    ) external view returns (Checkpoint memory);\\n\\n    /// @inheritdoc IVotes\\n    function getPastVotes(\\n        address account,\\n        uint256 tokenId,\\n        uint256 timestamp\\n    ) external view returns (uint256);\\n\\n    /// @inheritdoc IVotes\\n    function getPastTotalSupply(\\n        uint256 timestamp\\n    ) external view returns (uint256);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             DAO VOTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IVotes\\n    function delegate(uint256 delegator, uint256 delegatee) external;\\n\\n    /// @inheritdoc IVotes\\n    function delegateBySig(\\n        uint256 delegator,\\n        uint256 delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC6372 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC6372\\n    function clock() external view returns (uint48);\\n\\n    /// @inheritdoc IERC6372\\n    function CLOCK_MODE() external view returns (string memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                TOKEN GRANT\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Deposit `_value` of tokens as a grant and lock for `_vestingEnd`\\n    ///         with the provided `_grantManager`.\\n    /// @param _value Amount to deposit\\n    /// @param _grantee The grantee's address\\n    /// @param _grantManager The grant manager who can revoke the grant\\n    /// @param _vestingEnd The end of the vesting schedule. The lock will be\\n    ///        rounded down to nearest week but the original vesting end is\\n    ///        recorded in the contract.\\n    /// @return TokenId of created veNFT\\n    function createGrantLockFor(\\n        uint256 _value,\\n        address _grantee,\\n        address _grantManager,\\n        uint256 _vestingEnd\\n    ) external returns (uint256);\\n\\n    /// @notice Allows the existing grant manager to set a new grant manager\\n    ///         address.\\n    /// @param _tokenId tokenId of the veNFT\\n    /// @param _newGrantManager The new grant manager address\\n    function setGrantManager(\\n        uint256 _tokenId,\\n        address _newGrantManager\\n    ) external;\\n\\n    /// @notice Returns the grant manager address for the given veNFT\\n    /// @param _tokenId tokenId of the veNFT\\n    function grantManager(uint256 _tokenId) external view returns (address);\\n\\n    /// @notice Returns the vesting schedule end for the given veNFT.\\n    ///         Zero if the veNFT was not created as a grant.\\n    /// @param _tokenId tokenId of the veNFT\\n    function vestingEnd(uint256 _tokenId) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x12fc409f27c9e659dffeedb14c460d993d1cde4df6918f7ec26ec21bbe989845\",\"license\":\"MIT\"},\"contracts/libraries/SafeCastLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.24;\\n\\n/// @title SafeCast Library\\n/// @author velodrome.finance\\n/// @notice Safely convert unsigned and signed integers without overflow / underflow\\nlibrary SafeCastLibrary {\\n    error SafeCastOverflow();\\n    error SafeCastUnderflow();\\n\\n    /// @dev Safely convert uint256 to int128\\n    function toInt128(uint256 value) internal pure returns (int128) {\\n        if (value > uint128(type(int128).max)) revert SafeCastOverflow();\\n        return int128(uint128(value));\\n    }\\n\\n    /// @dev Safely convert int128 to uint256\\n    function toUint256(int128 value) internal pure returns (uint256) {\\n        if (value < 0) revert SafeCastUnderflow();\\n        return uint256(int256(value));\\n    }\\n}\\n\",\"keccak256\":\"0xfc419390f2423ffa802e9a3a11ee859b01fee9ffdb0fca855008d6b7d6b25bd6\",\"license\":\"BUSL-1.1\"},\"contracts/ve/Balance.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.24;\\n\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport {SafeCastLibrary} from \\\"../libraries/SafeCastLibrary.sol\\\";\\nimport {VotingEscrowState} from \\\"./VotingEscrowState.sol\\\";\\n\\nlibrary Balance {\\n    using SafeCastLibrary for uint256;\\n    using SafeCastLibrary for int128;\\n\\n    uint256 internal constant WEEK = 1 weeks;\\n\\n    /// @notice Binary search to get the user point index for a token id at or prior to a given timestamp\\n    /// @dev If a user point does not exist prior to the timestamp, this will return 0.\\n    /// @param _tokenId .\\n    /// @param _timestamp .\\n    /// @return User point index\\n    function getPastUserPointIndex(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        uint256 _timestamp\\n    ) internal view returns (uint256) {\\n        uint256 _userEpoch = self.userPointEpoch[_tokenId];\\n        if (_userEpoch == 0) return 0;\\n        // First check most recent balance\\n        if (self._userPointHistory[_tokenId][_userEpoch].ts <= _timestamp)\\n            return (_userEpoch);\\n        // Next check implicit zero balance\\n        if (self._userPointHistory[_tokenId][1].ts > _timestamp) return 0;\\n\\n        uint256 lower = 0;\\n        uint256 upper = _userEpoch;\\n        while (upper > lower) {\\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            IVotingEscrow.UserPoint storage userPoint = self._userPointHistory[\\n                _tokenId\\n            ][center];\\n            if (userPoint.ts == _timestamp) {\\n                return center;\\n            } else if (userPoint.ts < _timestamp) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return lower;\\n    }\\n\\n    /// @notice Binary search to get the global point index at or prior to a given timestamp\\n    /// @dev If a checkpoint does not exist prior to the timestamp, this will return 0.\\n    /// @param _timestamp .\\n    /// @return Global point index\\n    function getPastGlobalPointIndex(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _timestamp\\n    ) internal view returns (uint256) {\\n        if (self.epoch == 0) return 0;\\n        // First check most recent balance\\n        if (self._pointHistory[self.epoch].ts <= _timestamp)\\n            return (self.epoch);\\n        // Next check implicit zero balance\\n        if (self._pointHistory[1].ts > _timestamp) return 0;\\n\\n        uint256 lower = 0;\\n        uint256 upper = self.epoch;\\n        while (upper > lower) {\\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            IVotingEscrow.GlobalPoint storage globalPoint = self._pointHistory[\\n                center\\n            ];\\n            if (globalPoint.ts == _timestamp) {\\n                return center;\\n            } else if (globalPoint.ts < _timestamp) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return lower;\\n    }\\n\\n    /// @notice Get the current voting power for `_tokenId`\\n    /// @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\\n    ///      Fetches last user point prior to a certain timestamp, then walks forward to timestamp.\\n    /// @param _tokenId NFT for lock\\n    /// @param _t Epoch time to return voting power at\\n    /// @return User voting power\\n    function _balanceOfNFTAt(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        uint256 _t\\n    ) internal view returns (uint256) {\\n        uint256 _epoch = getPastUserPointIndex(self, _tokenId, _t);\\n        // epoch 0 is an empty point\\n        if (_epoch == 0) return 0;\\n        IVotingEscrow.UserPoint memory lastPoint = self._userPointHistory[\\n            _tokenId\\n        ][_epoch];\\n        if (lastPoint.permanent != 0) {\\n            return lastPoint.permanent;\\n        } else {\\n            lastPoint.bias -= lastPoint.slope * (_t - lastPoint.ts).toInt128();\\n            if (lastPoint.bias < 0) {\\n                lastPoint.bias = 0;\\n            }\\n            return lastPoint.bias.toUint256();\\n        }\\n    }\\n\\n    function _balanceOfNFT(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId\\n    ) external view returns (uint256) {\\n        if (self.ownershipChange[_tokenId] == block.number) return 0;\\n        return _balanceOfNFTAt(self, _tokenId, block.timestamp);\\n    }\\n\\n    /// @notice Calculate total voting power at some point in the past\\n    /// @param _t Time to calculate the total voting power at\\n    /// @return Total voting power at that time\\n    function supplyAt(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _t\\n    ) external view returns (uint256) {\\n        uint256 epoch_ = getPastGlobalPointIndex(self, _t);\\n        // epoch 0 is an empty point\\n        if (epoch_ == 0) return 0;\\n        IVotingEscrow.GlobalPoint memory _point = self._pointHistory[epoch_];\\n        int128 bias = _point.bias;\\n        int128 slope = _point.slope;\\n        uint256 ts = _point.ts;\\n        uint256 t_i = (ts / WEEK) * WEEK;\\n        for (uint256 i = 0; i < 255; ++i) {\\n            t_i += WEEK;\\n            int128 dSlope = 0;\\n            if (t_i > _t) {\\n                t_i = _t;\\n            } else {\\n                dSlope = self.slopeChanges[t_i];\\n            }\\n            bias -= slope * (t_i - ts).toInt128();\\n            if (t_i == _t) {\\n                break;\\n            }\\n            slope += dSlope;\\n            ts = t_i;\\n        }\\n\\n        if (bias < 0) {\\n            bias = 0;\\n        }\\n        return bias.toUint256() + _point.permanentLockBalance;\\n    }\\n}\\n\",\"keccak256\":\"0x72bb04eea9375ddae514cd8998c33bba2659d8ef20e5e1b48c14d2ef9d3f2fc4\",\"license\":\"BUSL-1.1\"},\"contracts/ve/VeERC2771Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Based on openzeppelin-contracts/contracts/metatx/ERC2771Context.sol\\n\\npragma solidity 0.8.24;\\n\\nimport {VotingEscrowState} from \\\"./VotingEscrowState.sol\\\";\\n\\n/**\\n * @dev Context variant with ERC2771 support. Extracted to library to allow\\n *      easy application inside libraries.\\n */\\nlibrary VeERC2771Context {\\n    function isTrustedForwarder(\\n        VotingEscrowState.Storage storage self,\\n        address forwarder\\n    ) internal view returns (bool) {\\n        return forwarder == self.trustedForwarder;\\n    }\\n\\n    function _msgSender(\\n        VotingEscrowState.Storage storage self\\n    ) internal view returns (address sender) {\\n        if (msg.data.length >= 20 && isTrustedForwarder(self, msg.sender)) {\\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n        } else {\\n            return msg.sender;\\n        }\\n    }\\n\\n    function _msgData(\\n        VotingEscrowState.Storage storage self\\n    ) internal view returns (bytes calldata) {\\n        if (isTrustedForwarder(self, msg.sender)) {\\n            return msg.data[:msg.data.length - 20];\\n        } else {\\n            return msg.data;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbcd5157897425f73b6819441db0b1a58383c6e92d452d269f5987b63235aeba5\",\"license\":\"MIT\"},\"contracts/ve/VotingEscrowState.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.24;\\n\\nimport {IVotingEscrow} from \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport {VeERC2771Context} from \\\"./VeERC2771Context.sol\\\";\\nimport {IERC4906} from \\\"@openzeppelin/contracts/interfaces/IERC4906.sol\\\";\\n\\nlibrary VotingEscrowState {\\n    using VeERC2771Context for Storage;\\n\\n    struct Storage {\\n        /// @dev Address of Meta-tx Forwarder\\n        address trustedForwarder;\\n        /// @dev Address of FactoryRegistry.sol\\n        address factoryRegistry;\\n        /// @dev Address of token used to create a veNFT\\n        address token;\\n        /// @dev Address of RewardsDistributor.sol\\n        address distributor;\\n        /// @dev Address of Voter.sol\\n        address voter;\\n        /// @dev Address of Protocol Team multisig\\n        address team;\\n        /// @dev Address which can create managed NFTs\\n        address allowedManager;\\n        /// @dev Global point history at a given index (epoch -> unsigned global point)\\n        mapping(uint256 => IVotingEscrow.GlobalPoint) _pointHistory;\\n        /// @dev Mapping of interface id to bool about whether or not it's supported\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        /// @dev Current count of token\\n        uint256 tokenId;\\n        /*///////////////////////////////////////////////////////////////\\n                                MANAGED NFT\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Mapping of token id to escrow type\\n        ///      Takes advantage of the fact default value is EscrowType.NORMAL\\n        mapping(uint256 => IVotingEscrow.EscrowType) escrowType;\\n        /// @dev Mapping of token id to managed id\\n        mapping(uint256 => uint256) idToManaged;\\n        /// @dev Mapping of user token id to managed token id to weight of token id\\n        mapping(uint256 => mapping(uint256 => uint256)) weights;\\n        /// @dev Mapping of managed id to deactivated state\\n        mapping(uint256 => bool) deactivated;\\n        /// @dev Mapping from managed nft id to locked managed rewards\\n        ///      `token` denominated rewards (rebases/rewards) stored in locked\\n        ///      managed rewards contract to prevent co-mingling of assets\\n        mapping(uint256 => address) managedToLocked;\\n        /// @dev Mapping from managed nft id to free managed rewards contract\\n        ///      these rewards can be freely withdrawn by users\\n        mapping(uint256 => address) managedToFree;\\n        /*//////////////////////////////////////////////////////////////\\n                            ERC721 BALANCE/OWNER\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Mapping from NFT ID to the address that owns it.\\n        mapping(uint256 => address) idToOwner;\\n        /// @dev Mapping from owner address to count of his tokens.\\n        mapping(address => uint256) ownerToNFTokenCount;\\n        /*//////////////////////////////////////////////////////////////\\n                                ERC721 APPROVAL\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Mapping from NFT ID to approved address.\\n        mapping(uint256 => address) idToApprovals;\\n        /// @dev Mapping from owner address to mapping of operator addresses.\\n        mapping(address => mapping(address => bool)) ownerToOperators;\\n        mapping(uint256 => uint256) ownershipChange;\\n        /*//////////////////////////////////////////////////////////////\\n                            INTERNAL MINT/BURN\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Mapping from owner address to mapping of index to tokenId\\n        mapping(address => mapping(uint256 => uint256)) ownerToNFTokenIdList;\\n        /// @dev Mapping from NFT ID to index of owner\\n        mapping(uint256 => uint256) tokenToOwnerIndex;\\n        /*//////////////////////////////////////////////////////////////\\n                                    ESCROW\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Total count of epochs witnessed since contract creation\\n        uint256 epoch;\\n        /// @dev Total amount of token() deposited\\n        uint256 supply;\\n        mapping(uint256 => IVotingEscrow.LockedBalance) _locked;\\n        mapping(uint256 => IVotingEscrow.UserPoint[1000000000]) _userPointHistory;\\n        mapping(uint256 => uint256) userPointEpoch;\\n        /// @dev time -> signed slope change\\n        mapping(uint256 => int128) slopeChanges;\\n        /// @dev account -> can split\\n        mapping(address => bool) canSplit;\\n        /// @dev Aggregate permanent locked balances\\n        uint256 permanentLockBalance;\\n        /// @dev Maximum lock time of the veNFT in seconds.\\n        ///      This value SHOULD NOT be changed after deployment\\n        ///      as it affects the voting power of all existing veNFTs.\\n        ///      It is defined here and not as constant because\\n        ///      different veNFT implementations have different\\n        ///      max lock times.\\n        uint256 maxLockTime;\\n        /*///////////////////////////////////////////////////////////////\\n                                    DAO VOTING\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev A record of each accounts delegate\\n        mapping(uint256 => uint256) _delegates;\\n        /// @dev A record of delegated token checkpoints for each tokenId, by index\\n        mapping(uint256 => mapping(uint48 => IVotingEscrow.Checkpoint)) _checkpoints;\\n        /// @dev The number of checkpoints for each tokenId\\n        mapping(uint256 => uint48) numCheckpoints;\\n        /// @dev A record of states for signing / validating signatures\\n        mapping(address => uint256) nonces;\\n        /*///////////////////////////////////////////////////////////////\\n                                GAUGE VOTING\\n        //////////////////////////////////////////////////////////////*/\\n\\n        /// @dev Information on whether a tokenId has already voted\\n        mapping(uint256 => bool) voted;\\n        /*///////////////////////////////////////////////////////////////\\n                                TOKEN GRANT\\n        //////////////////////////////////////////////////////////////*/\\n        /// @dev Mapping from tokenId to grant manager. The grant manager can\\n        ///      revoke a grant converted to veNFT.\\n        mapping(uint256 => address) grantManager;\\n        /// @dev Mapping from tokenId to the end date of the grant vesting\\n        ///      schedule. The end date is a UNIX timestamp.\\n        mapping(uint256 => uint256) vestingEnd;\\n        // Reserved storage space in case we need to add more variables.\\n        // The convention from OpenZeppelin suggests the storage space should\\n        // add up to 50 slots. Here we want to have more slots as there are\\n        // planned upgrades of the VotingEscrow contract. If more entires are\\n        // added to the struct in the upcoming versions we need to reduce\\n        // the array size.\\n        // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n        uint256[50] __gap;\\n    }\\n\\n    function setTeam(\\n        VotingEscrowState.Storage storage self,\\n        address _team\\n    ) internal {\\n        if (self._msgSender() != self.team) revert IVotingEscrow.NotTeam();\\n        if (_team == address(0)) revert IVotingEscrow.ZeroAddress();\\n        self.team = _team;\\n    }\\n\\n    function setVoterAndDistributor(\\n        VotingEscrowState.Storage storage self,\\n        address _voter,\\n        address _distributor\\n    ) internal {\\n        if (self._msgSender() != self.voter) revert IVotingEscrow.NotVoter();\\n        self.voter = _voter;\\n        self.distributor = _distributor;\\n    }\\n\\n    function setVoting(\\n        VotingEscrowState.Storage storage self,\\n        uint256 _tokenId,\\n        bool _voted\\n    ) internal {\\n        if (self._msgSender() != self.voter) revert IVotingEscrow.NotVoter();\\n        self.voted[_tokenId] = _voted;\\n    }\\n}\\n\",\"keccak256\":\"0xaf461d9f918f782e27fcd41ad3b047e7e9cb21286bfbb2fa5a9e6886bb8e8cbf\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x6106f761003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100405760003560e01c806320082913146100455780633332b04a1461006a575b600080fd5b610058610053366004610593565b61007d565b60405190815260200160405180910390f35b610058610078366004610593565b6101e0565b60008061008a8484610212565b90508060000361009e5760009150506101da565b60008181526007850160209081526040808320815160a0810183528154600f81810b808452600160801b909204900b9482018590526001830154938201849052600283015460608301526003909201546080820152939092919062093a8061010681846105cb565b61011091906105ed565b905060005b60ff8110156101a45761012b62093a8083610604565b915060008983111561013f57899250610155565b506000828152601c8b016020526040902054600f0b5b6101676101628585610617565b610304565b610171908661062a565b61017b9087610651565b955089830361018a57506101a4565b610194818661067e565b9450919250829150600101610115565b50600084600f0b12156101b657600093505b84608001516101c785600f0b610332565b6101d19190610604565b96505050505050505b92915050565b6000818152601483016020526040812054439003610200575060006101da565b61020b83834261035e565b9392505050565b60008260170154600003610228575060006101da565b601783015460009081526007840160205260409020600101548210610252575060178201546101da565b6001600081815260078501602052604090200154821015610275575060006101da565b60178301546000905b818111156102fc57600060026102948484610617565b61029e91906105cb565b6102a89083610617565b600081815260078801602052604090206001810154919250908690036102d3575092506101da915050565b85816001015410156102e7578193506102f5565b6102f2600183610617565b92505b505061027e565b509392505050565b600060016001607f1b0382111561032e576040516393dafdf160e01b815260040160405180910390fd5b5090565b60008082600f0b12156103575760405162406f5d60e21b815260040160405180910390fd5b50600f0b90565b60008061036c85858561046c565b90508060000361038057600091505061020b565b6000848152601a86016020526040812082633b9aca0081106103a4576103a46106ab565b6040805160a081018252600492909202929092018054600f81810b8452600160801b909104900b60208301526001810154928201929092526002820154606082015260039091015460808201819052909150156104085760800151915061020b9050565b61041b8160400151856101629190610617565b816020015161042a919061062a565b81518290610439908390610651565b600f90810b90915282516000910b1215905061045457600081525b805161046290600f0b610332565b9695505050505050565b6000828152601b8401602052604081205480820361048e57600091505061020b565b6000848152601a860160205260409020839082633b9aca0081106104b4576104b46106ab565b6004020160010154116104c857905061020b565b6000848152601a860160205260409020600501548310156104ed57600091505061020b565b6000815b8181111561058957600060026105078484610617565b61051191906105cb565b61051b9083610617565b6000888152601a8a01602052604081209192509082633b9aca008110610543576105436106ab565b600402019050868160010154036105605750935061020b92505050565b868160010154101561057457819350610582565b61057f600183610617565b92505b50506104f1565b5095945050505050565b600080604083850312156105a657600080fd5b50508035926020909101359150565b634e487b7160e01b600052601160045260246000fd5b6000826105e857634e487b7160e01b600052601260045260246000fd5b500490565b80820281158282048414176101da576101da6105b5565b808201808211156101da576101da6105b5565b818103818111156101da576101da6105b5565b600082600f0b82600f0b0280600f0b915080821461064a5761064a6105b5565b5092915050565b600f82810b9082900b0360016001607f1b0319811260016001607f1b03821317156101da576101da6105b5565b600f81810b9083900b0160016001607f1b03811360016001607f1b0319821217156101da576101da6105b5565b634e487b7160e01b600052603260045260246000fdfea2646970667358221220ece167bea4f6b3bf5cd9b7324e3a01be9e8d22a7baa57ec2f78387098239ee5664736f6c63430008180033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100405760003560e01c806320082913146100455780633332b04a1461006a575b600080fd5b610058610053366004610593565b61007d565b60405190815260200160405180910390f35b610058610078366004610593565b6101e0565b60008061008a8484610212565b90508060000361009e5760009150506101da565b60008181526007850160209081526040808320815160a0810183528154600f81810b808452600160801b909204900b9482018590526001830154938201849052600283015460608301526003909201546080820152939092919062093a8061010681846105cb565b61011091906105ed565b905060005b60ff8110156101a45761012b62093a8083610604565b915060008983111561013f57899250610155565b506000828152601c8b016020526040902054600f0b5b6101676101628585610617565b610304565b610171908661062a565b61017b9087610651565b955089830361018a57506101a4565b610194818661067e565b9450919250829150600101610115565b50600084600f0b12156101b657600093505b84608001516101c785600f0b610332565b6101d19190610604565b96505050505050505b92915050565b6000818152601483016020526040812054439003610200575060006101da565b61020b83834261035e565b9392505050565b60008260170154600003610228575060006101da565b601783015460009081526007840160205260409020600101548210610252575060178201546101da565b6001600081815260078501602052604090200154821015610275575060006101da565b60178301546000905b818111156102fc57600060026102948484610617565b61029e91906105cb565b6102a89083610617565b600081815260078801602052604090206001810154919250908690036102d3575092506101da915050565b85816001015410156102e7578193506102f5565b6102f2600183610617565b92505b505061027e565b509392505050565b600060016001607f1b0382111561032e576040516393dafdf160e01b815260040160405180910390fd5b5090565b60008082600f0b12156103575760405162406f5d60e21b815260040160405180910390fd5b50600f0b90565b60008061036c85858561046c565b90508060000361038057600091505061020b565b6000848152601a86016020526040812082633b9aca0081106103a4576103a46106ab565b6040805160a081018252600492909202929092018054600f81810b8452600160801b909104900b60208301526001810154928201929092526002820154606082015260039091015460808201819052909150156104085760800151915061020b9050565b61041b8160400151856101629190610617565b816020015161042a919061062a565b81518290610439908390610651565b600f90810b90915282516000910b1215905061045457600081525b805161046290600f0b610332565b9695505050505050565b6000828152601b8401602052604081205480820361048e57600091505061020b565b6000848152601a860160205260409020839082633b9aca0081106104b4576104b46106ab565b6004020160010154116104c857905061020b565b6000848152601a860160205260409020600501548310156104ed57600091505061020b565b6000815b8181111561058957600060026105078484610617565b61051191906105cb565b61051b9083610617565b6000888152601a8a01602052604081209192509082633b9aca008110610543576105436106ab565b600402019050868160010154036105605750935061020b92505050565b868160010154101561057457819350610582565b61057f600183610617565b92505b50506104f1565b5095945050505050565b600080604083850312156105a657600080fd5b50508035926020909101359150565b634e487b7160e01b600052601160045260246000fd5b6000826105e857634e487b7160e01b600052601260045260246000fd5b500490565b80820281158282048414176101da576101da6105b5565b808201808211156101da576101da6105b5565b818103818111156101da576101da6105b5565b600082600f0b82600f0b0280600f0b915080821461064a5761064a6105b5565b5092915050565b600f82810b9082900b0360016001607f1b0319811260016001607f1b03821317156101da576101da6105b5565b600f81810b9083900b0160016001607f1b03811360016001607f1b0319821217156101da576101da6105b5565b634e487b7160e01b600052603260045260246000fdfea2646970667358221220ece167bea4f6b3bf5cd9b7324e3a01be9e8d22a7baa57ec2f78387098239ee5664736f6c63430008180033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "supplyAt(VotingEscrowState.Storage storage,uint256)": {
        "params": {
          "_t": "Time to calculate the total voting power at"
        },
        "returns": {
          "_0": "Total voting power at that time"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "supplyAt(VotingEscrowState.Storage storage,uint256)": {
        "notice": "Calculate total voting power at some point in the past"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}